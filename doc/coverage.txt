[0;36m/home/davejwatson/myprojects/boom/asm_x64.c:
[0m    1|       |#include "asm_x64.h"
    2|       |#include <assert.h> // for assert
    3|       |#ifdef CAPSTONE
    4|       |#include <capstone/capstone.h> // for cs_insn, cs_close, cs_disasm, cs_free
    5|       |#endif
    6|       |#include <inttypes.h>
    7|       |#include <stdbool.h>
    8|       |#include <stdio.h>  // for printf, size_t
    9|       |#include <stdlib.h> // for exit
   10|       |#ifdef VALGRIND
   11|       |#include <valgrind/valgrind.h> // for VALGRIND_DISCARD_TRANSLATIONS
   12|       |#endif
   13|       |// TODO only for runtime symbol
   14|       |#include "bytecode.h" // for INS_OP, INS_B
   15|       |#include "emit_x64.h" // for emit_offset, emit_mov64, emit_mem_reg
   16|       |#include "ir.h"       // for ir_ins, trace_s, ir_ins::(anonymous u...
   17|       |#ifdef JITDUMP
   18|       |#include "jitdump.h" // for jit_dump, jit_reader_add, perf_map
   19|       |#endif
   20|       |#include "opcodes.h" // for JLOOP, FUNC, LOOP
   21|       |// only for tcache
   22|       |#include "record.h" // for trace_cache_get, record_side
   23|       |#include "types.h"  // for CONS_TAG, TAG_MASK, IMMEDIATE_MASK
   24|       |#include "defs.h"
   25|       |
   26|       |#include "vm.h"
   27|       |#include "lru.h"
   28|       |
   29|       |#include "parallel_copy.h"
   30|       |#include "third-party/stb_ds.h"
   31|       |
   32|       |
   33|  12.7G|#define auto __auto_type
   34|  10.0k|#define nullptr NULL
   35|       |
   36|       |extern bool verbose;
   37|       |
   38|       |// TODO
   39|       |long *expand_stack_slowpath(long *frame);
   40|       |extern long *frame_top;
   41|       |extern uint8_t *alloc_ptr;
   42|       |extern uint8_t *alloc_end;
   43|       |
   44|       |EXPORT bool jit_dump_flag = false;
   45|       |
   46|       |int64_t spill_slot[256];
   47|       |lru reg_lru;
   48|       |
   49|      0|void disassemble(const uint8_t *code, int len) [0;41m{[0m
   50|       |[0;41m[0m#ifdef CAPSTONE
   51|       |  csh handle;
   52|       |  cs_insn *insn;
   53|       |  size_t count;
   54|       |
   55|       |  if (cs_open(CS_ARCH_X86, CS_MODE_64, &handle) != CS_ERR_OK) {
   56|       |    return;
   57|       |  }
   58|       |  count = cs_disasm(handle, code, len, (uint64_t)code, 0, &insn);
   59|       |  if (count > 0) {
   60|       |    size_t j;
   61|       |    for (j = 0; j < count; j++) {
   62|       |      printf("0x%" PRIx64 ":\t%s\t\t%s\n", insn[j].address, insn[j].mnemonic,
   63|       |             insn[j].op_str);
   64|       |    }
   65|       |
   66|       |    cs_free(insn, count);
   67|       |  } else {
   68|       |    printf("ERROR: Failed to disassemble given code!\n");
   69|       |  }
   70|       |
   71|       |  cs_close(&handle);
   72|       |#endif[0;41m[0m
   73|      0|[0;41m}[0m
   74|       |
   75|       |// clang-format off
   76|       |const char *reg_names[] = {
   77|       |  "rax",
   78|       |  "rcx",
   79|       |  "rdx",
   80|       |  "rbx",
   81|       |  "rsp",
   82|       |  "rbp",
   83|       |  "rsi",
   84|       |  "rdi",
   85|       |  "r8 ", 
   86|       |  "r9 ", 
   87|       |  "r10", 
   88|       |  "r11", 
   89|       |  "r12", 
   90|       |  "r13", 
   91|       |  "r14", 
   92|       |  "r15",
   93|       |  "   ",
   94|       |};
   95|       |bool reg_callee[] = {
   96|       |  false, // rax
   97|       |  false,  // rcx
   98|       |  false, // rdx
   99|       |  true, // rbx
  100|       |  true,  // rsp
  101|       |  true,  // rbp
  102|       |  false, // rsi
  103|       |  false, // rdi
  104|       |  false, // r8
  105|       |  false, // r9
  106|       |  false, // r10
  107|       |  false, // r11
  108|       |  true,  // r12
  109|       |  true,  // r13
  110|       |  true,  // r14
  111|       |  true,  // r15
  112|       |};
  113|       |// clang-format on
  114|       |
  115|       |// Get a specific reg, spilling if necessary.
  116|  6.55k|void get_reg(uint8_t reg, trace_s *trace, uint32_t *next_spill, int *slot) {
  117|  [0;35m6.55k[0m|  if (slot[reg] != -1) {
  118|       |    // printf("Spilling reg %s\n", reg_names[reg]);
  119|  6.28k|    auto op = slot[reg];
  120|  6.28k|    assert(trace->ops[op].reg != REG_NONE);
  121|       |
  122|  [0;35m6.28k[0m|    auto spill = trace->ops[op].slot;
  123|  [0;35m6.28k[0m|    if (trace->ops[op].slot == SLOT_NONE) {
  124|  5.99k|      spill = (*next_spill)++;
  125|  [0;35m5.99k[0m|      if (*next_spill >= 255) [0;41m{[0m
  126|      0|[0;41m        printf("Too many spill slots\n");[0m
  127|      0|[0;41m        exit(-1);[0m
  128|      0|[0;41m      }[0m
  129|  5.99k|    }
  130|       |
  131|  6.28k|    trace->ops[op].slot = spill;
  132|  6.28k|    emit_mem_reg(OP_MOV_MR, 0, R15, trace->ops[op].reg);
  133|  6.28k|    emit_mov64(R15, (int64_t)&spill_slot[trace->ops[op].slot]);
  134|  6.28k|    trace->ops[op].reg = REG_NONE;
  135|  6.28k|    slot[reg] = -1;
  136|  6.28k|    lru_poke(&reg_lru, reg);
  137|  6.28k|  }
  138|  6.55k|}
  139|       |
  140|       |// Get any free reg, spilling oldest if necessary.
  141|   238k|int get_free_reg(trace_s *trace, uint32_t *next_spill, int *slot, bool callee) {
  142|  [0;35m1.41M[0m|  for (int i = 0; i < regcnt; i++) {
  143|  [0;35m1.40M[0m|    if (slot[i] == -1) {
  144|   [0;35m234k[0m|      if (!callee || [0;41mreg_callee[i][0m) {
  145|   234k|        return i;
  146|   234k|      }
  147|   234k|    }
  148|  1.40M|  }
  149|       |
  150|       |  // Poke the unusable slots.
  151|  3.66k|  lru_poke(&reg_lru, R15);
  152|  3.66k|  lru_poke(&reg_lru, RSP);
  153|  3.66k|  lru_poke(&reg_lru, RDI);
  154|       |
  155|       |  // Spill.
  156|  3.66k|  auto oldest = lru_oldest(&reg_lru);
  157|  3.66k|  assert(oldest < REG_NONE);
  158|       |
  159|  3.66k|  get_reg(oldest, trace, next_spill, slot);
  160|  3.66k|  return oldest;
  161|  3.66k|}
  162|       |
  163|       |// Re-assign non-callee saved regs to callee saved.
  164|    639|void preserve_for_call(trace_s *trace, int *slot, uint32_t *next_spill) {
  165|  [0;35m10.8k[0m|  for (int i = 0; i < regcnt; i++) {
  166|  [0;35m10.2k[0m|    if (i != RDI && slot[i] != -1 && !reg_callee[i]) {
  167|  2.47k|      auto op = slot[i];
  168|  2.47k|      auto spill = trace->ops[op].slot;
  169|  [0;35m2.47k[0m|      if (trace->ops[op].slot == SLOT_NONE) {
  170|       |        // Reload from new spill slot
  171|       |        // We don't need to store here, original instruction will store.
  172|  2.32k|        spill = (*next_spill)++;
  173|  [0;35m2.32k[0m|        if (*next_spill >= 255) [0;41m{[0m
  174|      0|[0;41m          printf("Too many spill slots\n");[0m
  175|      0|[0;41m          exit(-1);[0m
  176|      0|[0;41m        }[0m
  177|  2.32k|      }
  178|  2.47k|      trace->ops[op].slot = spill;
  179|       |      // printf("Assigning spill slot %i to op %i, mov to reg %s\n", spill, op,
  180|       |      // reg_names[trace->ops[op].reg]);
  181|       |
  182|  2.47k|      emit_mem_reg(OP_MOV_MR, 0, R15, trace->ops[op].reg);
  183|  2.47k|      emit_mov64(R15, (int64_t)&spill_slot[trace->ops[op].slot]);
  184|  2.47k|      trace->ops[op].reg = REG_NONE;
  185|  2.47k|      slot[i] = -1;
  186|  2.47k|    }
  187|  10.2k|  }
  188|    639|}
  189|       |
  190|       |void maybe_assign_register(int v, trace_s *trace, int *slot,
  191|   518k|                           uint32_t *next_spill) {
  192|   [0;35m518k[0m|  if ((v & IR_CONST_BIAS) == 0) {
  193|   387k|    auto op = &trace->ops[v];
  194|   [0;35m387k[0m|    if (op->reg == REG_NONE) {
  195|   224k|      op->reg = get_free_reg(trace, next_spill, slot, false);
  196|   224k|      slot[op->reg] = v;
  197|       |
  198|       |      // Reload from spill slot.
  199|       |      /* if (op->slot != SLOT_NONE) { */
  200|       |      /* 	printf("Assigning register %s to op %i spilled slot %i\n", */
  201|       |      /* 	       reg_names[op->reg], v, op->slot); */
  202|       |      /* } */
  203|       |      /* printf("Assigning register %s to op %i\n", reg_names[op->reg], v); */
  204|   224k|    }
  205|   387k|    lru_poke(&reg_lru, op->reg);
  206|   387k|  }
  207|   518k|}
  208|       |
  209|       |void maybe_assign_register_hint(int v, trace_s *trace, int *slot,
  210|    764|				uint32_t *next_spill, uint8_t hint) {
  211|    [0;35m764[0m|  if (!ir_is_const(v)) {
  212|    694|    auto op = &trace->ops[v];
  213|    [0;35m694[0m|    if (op->reg == REG_NONE) {
  214|    [0;35m561[0m|      if (slot[hint] == -1) {
  215|    100|	op->reg = hint;
  216|    100|	slot[hint] = v;
  217|    100|	lru_poke(&reg_lru, op->reg);
  218|    461|      } else {
  219|    461|	maybe_assign_register(v, trace, slot, next_spill);
  220|    461|      }
  221|    561|    }
  222|    694|  }
  223|    764|}
  224|       |void assign_snap_registers(unsigned snap_num, int *slot, trace_s *trace,
  225|   110k|                           uint32_t *next_spill) {
  226|       |  // Get a free register, if any.  If already assigned a slot, do nothing.
  227|       |  // If no free registers, assign a slot.
  228|   110k|  auto snap = &trace->snaps[snap_num];
  229|  [0;35m1.28M[0m|  for (uint64_t i = 0; i < arrlen(snap->slots); i++) {
  230|  1.17M|    auto s = &snap->slots[i];
  231|  [0;35m1.17M[0m|    if ((s->val & IR_CONST_BIAS) == 0) {
  232|   898k|      auto op = &trace->ops[s->val];
  233|   [0;35m898k[0m|      if (op->reg == REG_NONE && op->slot == SLOT_NONE) {
  234|       |	// Try and find a free reg, or assign the next spill slot.
  235|   129k|	bool done = false;
  236|   [0;35m821k[0m|	for (int j = 0; j < regcnt; j++) {
  237|   [0;35m814k[0m|	  if (slot[j] == -1) {
  238|   122k|	    op->reg = j;
  239|   122k|	    slot[op->reg] = s->val;
  240|   122k|	    done = true;
  241|   122k|	    lru_poke(&reg_lru, op->reg);
  242|       |	    /* printf("Assigning snap register %s to op %i\n", reg_names[op->reg], s->val); */
  243|   122k|	    break;
  244|   122k|	  }
  245|   814k|	}
  246|   [0;35m129k[0m|	if (!done) {
  247|       |	  // Couldn't find a free reg, assign a slot.
  248|  7.10k|	  op->slot = (*next_spill)++;
  249|       |	  /* printf("Assigning snap slot %i to op %i\n", op->slot, s->val); */
  250|  [0;35m7.10k[0m|	  if (*next_spill >= 255) [0;41m{[0m
  251|      0|[0;41m	    printf("Too many spill slots\n");[0m
  252|      0|[0;41m	    exit(-1);[0m
  253|      0|[0;41m	  }[0m
  254|  7.10k|	}
  255|   129k|      }
  256|       |      //maybe_assign_register(s->val, trace, slot, next_spill);
  257|   898k|    }
  258|  1.17M|  }
  259|   110k|}
  260|       |
  261|       |typedef struct exit_state {
  262|       |  long regs[regcnt];
  263|       |  trace_s *trace;
  264|       |  long snap;
  265|       |} exit_state;
  266|       |
  267|       |static void __attribute__((noinline)) __attribute__((naked))
  268|  1.36G|jit_entry_stub(long *o_frame, Func fptr, exit_state *regs) {
  269|  1.36G|  asm inline(".intel_syntax noprefix\n"
  270|       |             //  Save callee-saved regs.
  271|  1.36G|             "push rbx\n"
  272|  1.36G|             "push rbp\n"
  273|  1.36G|             "push r12\n"
  274|  1.36G|             "push r13\n"
  275|  1.36G|             "push r14\n"
  276|  1.36G|             "push r15\n"
  277|       |
  278|       |             // RDI: scheme frame ptr.
  279|  1.36G|             "push rdx\n" // state regs
  280|  1.36G|             "push rsi\n" // ptr to call.
  281|       |
  282|  1.36G|             "mov r15, rdx\n" // state regs.
  283|       |
  284|       |             // Put new reg state based on rcx param.
  285|  1.36G|             "mov rax, [r15]\n"
  286|  1.36G|             "mov rcx, [r15 + 8]\n"
  287|  1.36G|             "mov rdx, [r15 + 16]\n"
  288|  1.36G|             "mov rbx, [r15 + 24]\n"
  289|       |             // RSP 32, c stack ptr.
  290|  1.36G|             "mov rbp, [r15 + 40]\n"
  291|  1.36G|             "mov rsi, [r15 + 48]\n"
  292|       |             // RDI 56, scheme frame ptr.
  293|  1.36G|             "mov r8, [r15 + 64]\n"
  294|  1.36G|             "mov r9, [r15 + 72]\n"
  295|  1.36G|             "mov r10, [r15 + 80]\n"
  296|  1.36G|             "mov r11, [r15 + 88]\n"
  297|  1.36G|             "mov r12, [r15 + 96]\n"
  298|  1.36G|             "mov r13, [r15 + 102]\n"
  299|  1.36G|             "mov r14, [r15 + 112]\n"
  300|  1.36G|             "mov r15, [r15 + 120]\n"
  301|       |
  302|  1.36G|             "pop r15\n"
  303|  1.36G|             "jmp r15\n"
  304|  1.36G|             :);
  305|       |  // No need for clobbers, since hopefully the compiler will treat
  306|       |  // jit_entry_stub as the normal sys-v calling convention.
  307|  1.36G|}
  308|       |
  309|  1.36G|static void __attribute__((noinline)) __attribute__((naked)) jit_exit_stub() {
  310|  1.36G|  asm inline(".intel_syntax noprefix\n"
  311|       |             //  Push reg state
  312|  1.36G|             "mov r15, [rsp+16]\n"
  313|  1.36G|             "mov [r15 + 116], r15\n"
  314|  1.36G|             "mov [r15 + 112], r14\n"
  315|  1.36G|             "mov [r15 + 104], r13\n"
  316|  1.36G|             "mov [r15 + 96], r12\n"
  317|  1.36G|             "mov [r15 + 88], r11\n"
  318|  1.36G|             "mov [r15 + 80], r10\n"
  319|  1.36G|             "mov [r15 + 72], r9\n"
  320|  1.36G|             "mov [r15 + 64], r8\n"
  321|  1.36G|             "mov [r15 + 56], rdi\n"
  322|  1.36G|             "mov [r15 + 48], rsi\n"
  323|  1.36G|             "mov [r15 + 40], rbp\n"
  324|  1.36G|             "mov [r15 + 32], rsp\n"
  325|  1.36G|             "mov [r15 + 24], rbx\n"
  326|  1.36G|             "mov [r15 + 16], rdx\n"
  327|  1.36G|             "mov [r15 + 8], rcx\n"
  328|  1.36G|             "mov [r15], rax\n"
  329|  1.36G|             "pop rax\n" // trace
  330|  1.36G|             "mov [r15 + 128], rax\n"
  331|  1.36G|             "pop rax\n" // exit num
  332|  1.36G|             "mov [r15 + 136], rax\n"
  333|       |
  334|       |             //  pop reg state
  335|  1.36G|             "add rsp, 8\n"
  336|       |             // pop callee-saved
  337|  1.36G|             "pop r15\n"
  338|  1.36G|             "pop r14\n"
  339|  1.36G|             "pop r13\n"
  340|  1.36G|             "pop r12\n"
  341|  1.36G|             "pop rbp\n"
  342|  1.36G|             "pop rbx\n"
  343|  1.36G|             "ret\n"
  344|  1.36G|             :);
  345|  1.36G|}
  346|       |
  347|       |void restore_snap(snap_s *snap, trace_s *trace, exit_state *state,
  348|  1.36G|                  long **o_frame, unsigned int **o_pc) {
  349|  1.36G|  (*o_frame) = (long *)state->regs[RDI];
  350|  [0;35m6.35G[0m|  for (uint64_t i = 0; i < arrlen(snap->slots); i++) {
  351|  4.99G|    auto slot = &snap->slots[i];
  352|  [0;35m4.99G[0m|    if ((slot->val & IR_CONST_BIAS) != 0) {
  353|   [0;35m118M[0m|      auto c = trace->consts[slot->val - IR_CONST_BIAS];
  354|   118M|      (*o_frame)[slot->slot] = (long)(c);
  355|  4.87G|    } else {
  356|  [0;35m4.87G[0m|      if (trace->ops[slot->val].slot != SLOT_NONE) {
  357|       |        // Was spilled, restore from spill slot.
  358|  26.7M|        (*o_frame)[slot->slot] = spill_slot[trace->ops[slot->val].slot];
  359|  4.84G|      } else {
  360|       |        // Restore from register.
  361|  4.84G|        (*o_frame)[slot->slot] = state->regs[trace->ops[slot->val].reg];
  362|  4.84G|      }
  363|  4.87G|    }
  364|  4.99G|  }
  365|       |
  366|  1.36G|  (*o_pc) = snap->pc;
  367|  1.36G|  (*o_frame) += snap->offset;
  368|  1.36G|}
  369|       |
  370|  44.8k|uint16_t find_val_for_slot(int slot, snap_s *snap, trace_s *trace) {
  371|   [0;35m285k[0m|  for (uint64_t i = 0; i < arrlen(snap->slots); i++) {
  372|   285k|    auto s = &snap->slots[i];
  373|   [0;35m285k[0m|    if (s->slot == slot) {
  374|  44.8k|      return s->val;
  375|  44.8k|    }
  376|   285k|  }
  377|      0|  assert[0;41m(false)[0m[0;41m;[0m
  378|      0|  [0;41mexit(-1)[0m[0;41m;[0m
  379|      0|[0;41m}[0m
  380|       |
  381|       |static const uint8_t call_regs[] = {RDI, RSI, RDX, RCX, R8, R9};
  382|       |
  383|    984|void assign_call_registers(uint16_t op, trace_s* trace, int*slot, uint32_t *next_spill, int arg) {
  384|       |  // TODO: could put directly in correct reg?
  385|       |  // What happens if we need to MOV them around?
  386|    [0;35m984[0m|  if (!ir_is_const(op)) {
  387|    764|    auto cop = &trace->ops[op];
  388|    [0;35m764[0m|    if(cop->op == IR_CARG) {
  389|    345|      maybe_assign_register_hint(cop->op1, trace, slot, next_spill, call_regs[arg]);
  390|    345|      assign_call_registers(cop->op2, trace, slot, next_spill, arg+1);
  391|    419|    } else {
  392|    419|      maybe_assign_register_hint(op, trace, slot, next_spill, call_regs[arg]);
  393|    419|    }
  394|    764|  }
  395|    984|}
  396|       |
  397|  1.32k|void emit_call_arguments(uint16_t op, trace_s* trace, int arg) {
  398|       |  // R15 is in use for RDI, but RAX is free.
  399|  1.32k|  assert(arg < 6);
  400|  1.32k|  uint8_t reg = call_regs[arg];
  401|  [0;35m1.32k[0m|  if (ir_is_const(op)) {
  402|    [0;35m290[0m|    auto c2 = trace->consts[op - IR_CONST_BIAS];
  403|    290|    auto re = (reloc){emit_offset(), c2, RELOC_ABS};
  404|    290|    arrput(trace->relocs, re);
  405|    290|    emit_mov64(reg, c2);
  406|  1.03k|  } else {
  407|  1.03k|    auto cop = &trace->ops[op];
  408|  [0;35m1.03k[0m|    if(cop->op == IR_CARG) {
  409|    345|      emit_call_arguments(cop->op1, trace, arg);
  410|    345|      emit_call_arguments(cop->op2, trace, arg + 1);
  411|    694|    } else {
  412|       |      //assert(trace->ops[op].slot == REG_NONE);
  413|    [0;35m694[0m|      if (trace->ops[op].reg == REG_NONE) [0;41m{[0m
  414|       |[0;41m[0m	// TODO this branch can never happen???  Either it's in a
  415|       |	// callee-saved reg, or we just assigned it to the correct
  416|       |	// register directly using a hint.  No parallel move
  417|       |	// necessary.[0;41m[0m
  418|      0|[0;41m	assert(trace->ops[op].slot != SLOT_NONE);[0m
  419|      0|[0;41m	[0m[0;41memit_mem_reg(OP_MOV_MR, 0, RAX, reg);[0m
  420|      0|[0;41m	emit_mov64(RAX, (int64_t)&spill_slot[trace->ops[op].slot - [0m[0;41mREG_NONE[0m[0;41m]);[0m
  421|    694|[0;41m      }[0m else {
  422|    694|	emit_reg_reg(OP_MOV, trace->ops[op].reg, reg);
  423|    694|      }
  424|    694|    }
  425|  1.03k|  }
  426|  1.32k|}
  427|       |
  428|  8.73k|void emit_snap(int snap, trace_s *trace, bool all) {
  429|       |   /* printf("EMITSNAP: all %i\n", (int)all); */
  430|  8.73k|  auto sn = &trace->snaps[snap];
  431|  8.73k|  int last_ret = -1;
  432|   [0;35m413k[0m|  for (int i = (int)sn->ir - 1; i >= 0; i--) {
  433|   [0;35m408k[0m|    if (trace->ops[i].op == IR_RET) {
  434|  3.66k|      last_ret = i;
  435|  3.66k|      break;
  436|  3.66k|    }
  437|   408k|  }
  438|   [0;35m101k[0m|  for (uint64_t i = 0; i < arrlen(sn->slots); i++) {
  439|  92.5k|    auto slot = &sn->slots[i];
  440|  92.5k|    emit_check();
  441|       |    /* if (!all && (slot->slot >= sn->offset)) { */
  442|       |    /*   break; */
  443|       |    /* } */
  444|  [0;35m92.5k[0m|    if ((slot->val & IR_CONST_BIAS) != 0) {
  445|  [0;35m17.7k[0m|      auto c = trace->consts[slot->val - IR_CONST_BIAS];
  446|  17.7k|      emit_mem_reg(OP_MOV_RM, slot->slot * 8, RDI, R15);
  447|  17.7k|      auto re = (reloc){emit_offset(), c, RELOC_ABS};
  448|  17.7k|      arrput(trace->relocs, re);
  449|  17.7k|      emit_mov64(R15, (int64_t)(c));
  450|  74.7k|    } else {
  451|  74.7k|      auto op = &trace->ops[slot->val];
  452|       |      // TODO RET check, can't emit past RETS
  453|       |
  454|       |      // TODO with ARGS the value may not be in the slot.
  455|  [0;35m74.7k[0m|      if (false && [0;41mslot->val > last_ret[0m &&
  456|  [0;35m74.7k[0m|          [0;41m([0m[0;41mop->op == IR_SLOAD[0m[0;41m && [0m[0;41m((op->type & [0m[0;41mIR_INS_TYPE_GUARD[0m[0;41m) != 0))[0m &&
  457|  [0;35m74.7k[0m|          [0;41mop->op1 == slot->slot[0m && [0;41mslot->slot < sn->offset[0m) [0;41m{[0m
  458|       |[0;41m[0m        // printf("DROPPING emit snap of slot %i\n", slot->slot);
  459|       |        //  nothing[0;41m[0m
  460|  [0;35m74.7k[0m|[0;41m      }[0m else if (op->slot != SLOT_NONE) {
  461|       |        // Reload from spill.
  462|       |        // TODO could use the real reg, if we did this in the same order as
  463|       |        // allocation (i.e. reverse order??).
  464|  5.06k|        emit_mem_reg(OP_MOV_RM, slot->slot * 8, RDI, R15);
  465|  5.06k|        emit_mem_reg(OP_MOV_MR, 0, R15, R15);
  466|  5.06k|        emit_mov64(R15, (int64_t)&spill_slot[op->slot]);
  467|  69.6k|      } else {
  468|  69.6k|        emit_mem_reg(OP_MOV_RM, slot->slot * 8, RDI, op->reg);
  469|  69.6k|      }
  470|  74.7k|    }
  471|  92.5k|  }
  472|  8.73k|}
  473|       |
  474|       |void emit_arith_op(enum ARITH_CODES arith_code, enum OPCODES op_code,
  475|  91.7k|                   uint8_t reg, uint32_t op2, trace_s *trace, int *slot) {
  476|  [0;35m91.7k[0m|  if ((op2 & IR_CONST_BIAS) != 0U) {
  477|  81.2k|    long v = trace->consts[op2 - IR_CONST_BIAS];
  478|       |    // TODO: check V is of correct type, but we typecheck return pointers also,
  479|       |    // which can move.
  480|  [0;35m81.2k[0m|    if ((long)((int32_t)v) == v && arith_code != OP_ARITH_NONE) {
  481|  31.9k|      emit_arith_imm(arith_code, reg, (int32_t)v);
  482|  49.3k|    } else {
  483|  [0;35m49.3k[0m|      if (op_code == OP_IMUL) {
  484|    422|        emit_reg_reg2(op_code, reg, R15);
  485|    422|        emit_imm8(3);
  486|    422|        emit_reg_reg(OP_SAR_CONST, 7, reg);
  487|  48.9k|      } else {
  488|  48.9k|        emit_reg_reg(op_code, reg, R15);
  489|  48.9k|      }
  490|       |      // This is only necessary for cmp of a closure for call/callt
  491|  49.3k|      auto re = (reloc){emit_offset(), v, RELOC_ABS};
  492|  49.3k|      arrput(trace->relocs, re);
  493|  49.3k|      emit_mov64(R15, v);
  494|  49.3k|    }
  495|  81.2k|  } else {
  496|  10.5k|    auto reg2 = trace->ops[op2].reg;
  497|  [0;35m10.5k[0m|    if (op_code == OP_IMUL) {
  498|    242|      emit_reg_reg2(op_code, reg, reg2);
  499|    242|      emit_imm8(3);
  500|    242|      emit_reg_reg(OP_SAR_CONST, 7, reg);
  501|  10.2k|    } else {
  502|  10.2k|      emit_reg_reg(op_code, reg2, reg);
  503|  10.2k|    }
  504|  10.5k|  }
  505|  91.7k|}
  506|       |
  507|       |void emit_arith(enum ARITH_CODES arith_code, enum OPCODES op_code, ir_ins *op,
  508|       |                trace_s *trace, uint64_t offset, int *slot,
  509|  5.89k|                uint32_t *next_spill) {
  510|  [0;35m5.89k[0m|  if (op->reg == REG_NONE) {
  511|     32|    return;
  512|     32|  }
  513|  5.85k|  maybe_assign_register(op->op1, trace, slot, next_spill);
  514|  5.85k|  maybe_assign_register(op->op2, trace, slot, next_spill);
  515|       |
  516|  5.85k|  emit_jcc32(JO, offset);
  517|       |
  518|  [0;35m5.85k[0m|  auto reg2 = REG_NONE;
  519|  [0;35m5.85k[0m|  if (!(op->op2 & IR_CONST_BIAS)) {
  520|  1.48k|    reg2 = trace->ops[op->op2].reg;
  521|  1.48k|  }
  522|       |
  523|  [0;35m5.85k[0m|  auto reg1 = REG_NONE;
  524|  [0;35m5.85k[0m|  if (!(op->op1 & IR_CONST_BIAS)) {
  525|  5.32k|    reg1 = trace->ops[op->op1].reg;
  526|  5.32k|  }
  527|  5.85k|  auto reg = op->reg;
  528|  [0;35m5.85k[0m|  if (reg != reg1 && reg2 == reg) {
  529|    [0;35m291[0m|    if (op_code == OP_IMUL) {
  530|     58|      emit_reg_reg2(op_code, reg, R15);
  531|     58|      emit_imm8(3);
  532|     58|      emit_reg_reg(OP_SAR_CONST, 7, reg);
  533|    233|    } else {
  534|    233|      emit_reg_reg(op_code, R15, reg);
  535|    233|    }
  536|  5.56k|  } else {
  537|  5.56k|    emit_arith_op(arith_code, op_code, reg, op->op2, trace, slot);
  538|  5.56k|  }
  539|  [0;35m5.85k[0m|  if (op->op1 & IR_CONST_BIAS) {
  540|    [0;35m534[0m|    auto c = trace->consts[op->op1 - IR_CONST_BIAS];
  541|    534|    auto re = (reloc){emit_offset(), c, RELOC_ABS};
  542|    534|    arrput(trace->relocs, re);
  543|    534|    emit_mov64(reg, c);
  544|    [0;35m534[0m|    if (reg == reg2) {
  545|     72|      emit_reg_reg(OP_MOV, reg2, R15);
  546|     72|    }
  547|  5.32k|  } else {
  548|  5.32k|    reg1 = trace->ops[op->op1].reg;
  549|  [0;35m5.32k[0m|    if (reg != reg1) {
  550|       |      // TODO clownshow.  If we have a commutative OP (mul, add), we could just
  551|       |      // run it backwards. ALternatively, ensure the reg allocator never does
  552|       |      // this?
  553|  [0;35m3.86k[0m|      if (reg2 == reg) {
  554|    219|        emit_reg_reg(OP_MOV, reg1, reg);
  555|    219|        emit_reg_reg(OP_MOV, reg2, R15);
  556|  3.64k|      } else {
  557|  3.64k|        emit_reg_reg(OP_MOV, reg1, reg);
  558|  3.64k|      }
  559|  3.86k|    }
  560|  5.32k|  }
  561|  5.85k|}
  562|       |
  563|       |void emit_cmp(enum jcc_cond cmp, ir_ins *op, trace_s *trace, uint64_t offset,
  564|  77.2k|              int *slot, uint32_t *next_spill) {
  565|  77.2k|  maybe_assign_register(op->op1, trace, slot, next_spill);
  566|  77.2k|  maybe_assign_register(op->op2, trace, slot, next_spill);
  567|       |
  568|       |  // TODO pass snap label instead, calculate offset
  569|  77.2k|  emit_jcc32(cmp, offset);
  570|  77.2k|  uint8_t reg;
  571|  [0;35m77.2k[0m|  if (!ir_is_const(op->op1)) {
  572|  64.2k|    reg = trace->ops[op->op1].reg;
  573|  64.2k|  } else {
  574|       |    // Find a tmp reg.
  575|  [0;35m13.0k[0m|    if (ir_is_const(op->op2)) {
  576|  12.3k|      reg = get_free_reg(trace, next_spill, slot, false);
  577|  12.3k|    } else {
  578|    709|      reg = R15;
  579|    709|    }
  580|  13.0k|  }
  581|  77.2k|  emit_arith_op(OP_ARITH_CMP, OP_CMP, reg, op->op2, trace, slot);
  582|  [0;35m77.2k[0m|  if (ir_is_const(op->op1)) {
  583|  [0;35m13.0k[0m|    auto c = trace->consts[op->op1 - IR_CONST_BIAS];
  584|  13.0k|    auto re = (reloc){emit_offset(), c, RELOC_ABS};
  585|  13.0k|    arrput(trace->relocs, re);
  586|  13.0k|    emit_mov64(reg, c);
  587|  13.0k|  }
  588|  77.2k|}
  589|       |
  590|   156k|void emit_op_typecheck(uint8_t reg, uint8_t type, uint64_t offset) {
  591|   [0;35m156k[0m|  if ((type & IR_INS_TYPE_GUARD) != 0) {
  592|   111k|    emit_jcc32(JNE, offset);
  593|   [0;35m111k[0m|    if ((type & ~IR_INS_TYPE_GUARD) == 0) {
  594|  10.3k|      emit_op_imm32(OP_TEST_IMM, 0, reg, 0x7);
  595|   [0;35m101k[0m|    } else if ((type & TAG_MASK) == PTR_TAG) {
  596|  10.4k|      emit_cmp_reg_imm32(R15, type & ~IR_INS_TYPE_GUARD);
  597|  10.4k|      emit_mem_reg(OP_MOV_MR, -PTR_TAG, R15, R15);
  598|  10.4k|      emit_reg_reg(OP_MOV, reg, R15);
  599|       |      // TODO clean offsets up a bit.
  600|  10.4k|      emit_jcc32(JNE, offset);
  601|  10.4k|      emit_cmp_reg_imm32(R15, 1);
  602|  10.4k|      emit_op_imm32(OP_AND_IMM, 4, R15, 0x7);
  603|  10.4k|      emit_reg_reg(OP_MOV, reg, R15);
  604|  [0;35m90.8k[0m|    } else if ((type & TAG_MASK) == LITERAL_TAG) {
  605|  [0;35m9.52k[0m|      auto lit_bits = (type & IMMEDIATE_MASK) & ~IR_INS_TYPE_GUARD;
  606|  9.52k|      emit_cmp_reg_imm32(R15, lit_bits);
  607|  9.52k|      emit_op_imm32(OP_AND_IMM, 4, R15, 0xff);
  608|  9.52k|      emit_reg_reg(OP_MOV, reg, R15);
  609|  81.3k|    } else {
  610|  81.3k|      emit_cmp_reg_imm32(R15, type & ~IR_INS_TYPE_GUARD);
  611|  81.3k|      emit_op_imm32(OP_AND_IMM, 4, R15, 0x7);
  612|  81.3k|      emit_reg_reg(OP_MOV, reg, R15);
  613|  81.3k|    }
  614|   111k|  }
  615|   156k|}
  616|       |
  617|  44.8k|void asm_add_to_pcopy(map* moves, ir_ins* op, uint16_t val, trace_s* trace) {
  618|       |  // If it is a constant, just emit it.
  619|  [0;35m44.8k[0m|  if (val >= IR_CONST_BIAS) {
  620|       |    /* printf("Fill %s with a const\n", reg_names[op->reg]); */
  621|    [0;35m235[0m|    if (op->reg != REG_NONE) {
  622|    [0;35m235[0m|      if (op->slot != SLOT_NONE) {
  623|     17|	emit_mem_reg(OP_MOV_RM, 0, R15, op->reg);
  624|     17|	emit_mov64(R15, (int64_t)&spill_slot[op->slot]);
  625|     17|      }
  626|    [0;35m235[0m|      auto c2 = trace->consts[val - IR_CONST_BIAS];
  627|    235|      auto re = (reloc){emit_offset(), c2, RELOC_ABS};
  628|    235|      arrput(trace->relocs, re);
  629|    235|      emit_mov64(op->reg, c2);
  630|    [0;35m235[0m|    } else [0;41mif ([0m[0;41mop->slot != [0m[0;41mSLOT_NONE[0m[0;41m) [0m[0;41m{[0m
  631|      0|[0;41m      emit_pop(RAX);[0m
  632|      0|[0;41m      emit_mem_reg(OP_MOV_RM, 0, R15, op->reg);[0m
  633|      0|[0;41m      emit_mov64(R15, (int64_t)&spill_slot[op->slot]);[0m
  634|      [0;35m0[0m|[0;41m      [0m[0;41mauto[0m[0;41m c2 = trace->consts[val - [0m[0;41mIR_CONST_BIAS[0m[0;41m];[0m
  635|      0|[0;41m      [0m[0;41mauto[0m[0;41m re = (reloc){emit_offset(), c2, RELOC_ABS};[0m
  636|      0|[0;41m      [0m[0;41marrput[0m[0;41m(trace->relocs, re);[0m
  637|      0|[0;41m      emit_mov64(RAX, c2);[0m
  638|      0|[0;41m      emit_push(RAX);[0m
  639|      0|[0;41m    }[0m
  640|  44.6k|  } else {
  641|  44.6k|    auto old_op = &trace->ops[val];
  642|       |
  643|  44.6k|    uint32_t from = old_op->reg;
  644|       |    // If it was in a slot, then use the slot.
  645|  [0;35m44.6k[0m|    if (old_op->slot != SLOT_NONE) {
  646|  6.17k|      from = old_op->slot + REG_NONE;
  647|  6.17k|    }
  648|  44.6k|    uint32_t to = op->reg;
  649|       |    // if it is to a slot and no reg, move to the slot.
  650|  [0;35m44.6k[0m|    if (op->reg == REG_NONE) {
  651|  [0;35m4.60k[0m|      if (op->slot != SLOT_NONE) {
  652|  4.07k|	to = op->slot + REG_NONE;
  653|  4.07k|      }
  654|  4.60k|    }
  655|  44.6k|    if (verbose)
  656|      [0;35m0[0m|      [0;41mprintf("Insert parallel copy %i  to %i (%s to %s)\n", from, to, [0m[0;41mfrom < 16[0m[0;41m? [0m[0;41mreg_names[from][0m[0;41m : [0m[0;41m""[0m[0;41m, [0m[0;41mto < 16[0m[0;41m ? [0m[0;41mreg_names[to][0m[0;41m : [0m[0;41m""[0m[0;41m)[0m;
  657|       |    // Add it to the map.
  658|  [0;35m44.6k[0m|    if (to != REG_NONE) {
  659|  44.1k|      map_insert(moves, from, to);
  660|  44.1k|    }
  661|       |    // If it has a slot *and* a reg, it was only moved to the reg,
  662|       |    // so emit a mov to the slot also.
  663|  [0;35m44.6k[0m|    if (op->slot != SLOT_NONE && op->reg != REG_NONE) {
  664|       |      /* printf("Also spill %s to slot %i\n", reg_names[op->reg], op->slot); */
  665|  2.47k|      emit_mem_reg(OP_MOV_RM, 0, R15, op->reg);
  666|  2.47k|      emit_mov64(R15, (int64_t)&spill_slot[op->slot]);
  667|  2.47k|    }
  668|  44.6k|  }
  669|  44.8k|}
  670|       |
  671|       |// Given the result map from pcopy, emit the actual series of moves.
  672|       |// Could be slot->slot, slot->reg, reg->slot.  Also we can't use R15,
  673|       |// since that was a tmp var given to pcopy to break cycles.
  674|       |//
  675|       |// TODO: move slots to a RIP relative location, and we can do this without
  676|       |//       a tmp for slot->reg and reg->slot, and a single tmp for slot->slot
  677|  18.7k|void asm_emit_pcopy(map* res) {
  678|  [0;35m47.8k[0m|  for (int64_t i = (int64_t)res->mp_sz - 1; i >= 0; i--) {
  679|       |    // printf("Doing copy from %i to %i\n", res->mp[i].from, res->mp[i].to);
  680|  [0;35m29.1k[0m|    if (res->mp[i].from >= REG_NONE && res->mp[i].to >= REG_NONE) {
  681|       |      // Move from spill to spill.
  682|       |      // Need two tmp.
  683|  1.64k|      emit_pop(RAX);
  684|  1.64k|      emit_pop(R15);
  685|  1.64k|      emit_mem_reg(OP_MOV_RM, 0, R15, RAX);
  686|  1.64k|      emit_mov64(R15, (int64_t)&spill_slot[res->mp[i].to - REG_NONE]);
  687|  1.64k|      emit_mem_reg(OP_MOV_MR, 0, R15, RAX);
  688|  1.64k|      emit_mov64(R15, (int64_t)&spill_slot[res->mp[i].from - REG_NONE]);
  689|  1.64k|      emit_push(R15);
  690|  1.64k|      emit_push(RAX);
  691|  1.64k|      if (verbose)
  692|      0|	[0;41mprintf("WARNING slow spill to spill move\n")[0m;
  693|  [0;35m27.5k[0m|    } else if (res->mp[i].from >= REG_NONE) {
  694|       |      // Move from spill to reg.  Need a tmp.
  695|  [0;35m3.56k[0m|      if (res->mp[i].to != R15) {
  696|  3.54k|	emit_pop(R15);
  697|  3.54k|      }
  698|  3.56k|      emit_mem_reg(OP_MOV_MR, 0, R15, res->mp[i].to);
  699|  3.56k|      emit_mov64(R15, (int64_t)&spill_slot[res->mp[i].from - REG_NONE]);
  700|  [0;35m3.56k[0m|      if (res->mp[i].to != R15) {
  701|  3.54k|	emit_push(R15);
  702|  3.54k|      }
  703|  [0;35m23.9k[0m|    } else if (res->mp[i].to >= REG_NONE) {
  704|       |      // Move from reg to spill.  Need a tmp.
  705|  1.41k|      uint8_t tmp = R15;
  706|  [0;35m1.41k[0m|      if (res->mp[i].from == tmp) {
  707|     14|	tmp = RAX;
  708|     14|      }
  709|  1.41k|      emit_pop(tmp);
  710|  1.41k|      emit_mem_reg(OP_MOV_RM, 0, tmp, res->mp[i].from);
  711|  1.41k|      emit_mov64(tmp, (int64_t)&spill_slot[res->mp[i].to - REG_NONE]);
  712|  1.41k|      emit_push(tmp);
  713|  22.5k|    } else {
  714|  22.5k|      emit_reg_reg(OP_MOV, res->mp[i].from, res->mp[i].to);
  715|  22.5k|    }
  716|  29.1k|  }
  717|  18.7k|}
  718|       |
  719|  8.72k|void asm_jit_args(trace_s *trace, trace_s* dest_trace) {
  720|       |  //printf("ASM JIT ARGS END %p\n", emit_offset());
  721|  [0;35m8.72k[0m|  auto last_snap = &trace->snaps[arrlen(trace->snaps)-1];
  722|       |  // Parallel move if there are args
  723|       |
  724|  8.72k|  map moves;
  725|  8.72k|  map res;
  726|  8.72k|  moves.mp_sz = 0;
  727|  8.72k|  long cnt = 0;
  728|  [0;35m18.6k[0m|  for (size_t op_cnt2 = 0; op_cnt2 < arrlen(dest_trace->ops); op_cnt2++) {
  729|  18.5k|    auto op = &dest_trace->ops[op_cnt2];
  730|  [0;35m18.5k[0m|    if (op->op != IR_ARG) {
  731|  8.61k|      break;
  732|  8.61k|    }
  733|       |    /* printf("Trace needs to fill %li (slot %i) reg %s\n", op_cnt2, op->op1, reg_names[op->reg]); */
  734|  [0;35m9.92k[0m|    auto val = find_val_for_slot(op->op1 + last_snap->offset, last_snap, trace);
  735|  9.92k|    asm_add_to_pcopy(&moves, op, val, trace);
  736|  9.92k|  }
  737|  8.72k|  serialize_parallel_copy(&moves, &res, R15);
  738|  8.72k|  asm_emit_pcopy(&res);
  739|       |  //printf("ASM JIT ARGS START %p CNT %i\n", emit_offset());
  740|  8.72k|}
  741|       |
  742|  10.0k|void asm_jit(trace_s *trace, snap_s *side_exit, trace_s *parent) {
  743|  10.0k|  emit_init();
  744|  10.0k|  lru_init(&reg_lru);
  745|       |
  746|  10.0k|  uint32_t next_spill = 1;
  747|       |
  748|       |  // Reg allocation
  749|  10.0k|  int slot[regcnt];
  750|   [0;35m170k[0m|  for (int i = 0; i < regcnt; i++) {
  751|   160k|    slot[i] = -1;
  752|   160k|  }
  753|       |  // Unallocatable.
  754|  10.0k|  slot[R15] = 0; // tmp.
  755|  10.0k|  slot[RSP] = 0; // stack ptr.
  756|  10.0k|  slot[RDI] = 0; // scheme frame ptr.
  757|       |
  758|  10.0k|  uint64_t snap_labels[arrlen(trace->snaps)];
  759|       |
  760|  10.0k|  auto end = emit_offset();
  761|       |
  762|  10.0k|  emit_check();
  763|  10.0k|  emit_jmp_abs(R15);
  764|  10.0k|  emit_mov64(R15, (int64_t)jit_exit_stub);
  765|  10.0k|  emit_check();
  766|  10.0k|  emit_push(R15);
  767|  10.0k|  emit_mov64(R15, (int64_t)trace);
  768|  10.0k|  emit_push(R15);
  769|       |
  770|  10.0k|  auto exit_label = emit_offset();
  771|       |
  772|   [0;35m111k[0m|  for (long i = arrlen(trace->snaps) - 1; i >= 0; i--) {
  773|   101k|    emit_check();
  774|       |    // Funny embed here, so we can patch later.
  775|       |    // emit_jmp_rel(exit_label - emit_offset());
  776|   101k|    trace->snaps[i].patchpoint = emit_offset();
  777|       |    // TODO check int32_t
  778|   101k|    emit_jmp32((int32_t)(exit_label - emit_offset()));
  779|   101k|    emit_mov64(R15, i);
  780|   101k|    snap_labels[i] = emit_offset();
  781|   101k|  }
  782|       |
  783|  10.0k|  uint64_t loop_offset_label = 0;
  784|       |
  785|  [0;35m10.0k[0m|  if (trace->link != -1) {
  786|  8.72k|    auto *otrace = trace_cache_get(trace->link);
  787|  8.72k|    emit_check();
  788|       |
  789|  [0;35m8.72k[0m|    if (otrace != trace) {
  790|  8.27k|      emit_jmp_abs(R15);
  791|  8.27k|      emit_mov64(R15, (int64_t)otrace->fn);
  792|  8.27k|    } else {
  793|       |      // Patched at top.
  794|    441|      loop_offset_label = emit_offset();
  795|    441|      emit_jmp32(0);
  796|    441|    }
  797|       |
  798|  8.72k|    emit_check();
  799|  [0;35m8.72k[0m|    auto last_snap = &trace->snaps[arrlen(trace->snaps) - 1];
  800|  [0;35m8.72k[0m|    if (last_snap->offset != 0U) {
  801|  5.80k|      emit_arith_imm(OP_ARITH_ADD, RDI, last_snap->offset * 8);
  802|  5.80k|      auto ok = emit_offset();
  803|       |      // Emit a stack overflow check
  804|  [0;35m5.80k[0m|      if (last_snap->offset > 0) {
  805|  5.80k|        emit_reg_reg(OP_MOV, RAX, RDI);
  806|  5.80k|        emit_call_indirect(R15);
  807|  5.80k|        emit_mov64(R15, (int64_t)&expand_stack_slowpath);
  808|       |        // TODO check offset
  809|  5.80k|        emit_jcc32(JBE, ok);
  810|  5.80k|        emit_reg_reg(OP_CMP, R15, RDI);
  811|       |        // TODO merge if in top?
  812|  5.80k|        emit_mem_reg(OP_MOV_MR, 0L, R15, R15);
  813|  5.80k|        emit_mov64(R15, (int64_t)&frame_top);
  814|  5.80k|      }
  815|  5.80k|    }
  816|       |
  817|  8.72k|    assign_snap_registers(arrlen(trace->snaps) - 1, slot, trace, &next_spill);
  818|  [0;35m8.72k[0m|    if (trace->link != trace->num) {
  819|       |      /* printf("Linking trace %li to trace %li\n", trace->num, trace->link); */
  820|  8.27k|      asm_jit_args(trace, otrace);
  821|  8.27k|    }
  822|       |  
  823|  8.72k|    emit_snap(arrlen(trace->snaps) - 1, trace,
  824|  [0;35m8.72k[0m|              (INS_OP(otrace->startpc) != FUNC && INS_OP(otrace->startpc) != LOOP));
  825|  8.72k|  } else {
  826|       |    // No link, jump back to interpreter loop.
  827|  1.29k|    emit_check();
  828|       |    // TODO check offset
  829|  1.29k|    emit_jmp32((int32_t)(exit_label - emit_offset()));
  830|  1.29k|    emit_mov64(R15, arrlen(trace->snaps) - 1);
  831|  1.29k|  }
  832|       |
  833|       |  // Main generation loop
  834|  10.0k|  long cur_snap = arrlen(trace->snaps) - 1;
  835|  10.0k|  long op_cnt = arrlen(trace->ops) - 1;
  836|  10.0k|  assign_snap_registers(cur_snap, slot, trace, &next_spill);
  837|   [0;35m449k[0m|  for (; op_cnt >= 0; op_cnt--) {
  838|   [0;35m545k[0m|    while (cur_snap >= 0 && trace->snaps[cur_snap].ir > op_cnt) {
  839|  [0;35m98.7k[0m|      if (cur_snap > 0) {
  840|  91.5k|        assign_snap_registers(cur_snap - 1, slot, trace, &next_spill);
  841|  91.5k|      }
  842|  98.7k|      cur_snap--;
  843|  98.7k|    }
  844|   446k|    auto op = &trace->ops[op_cnt];
  845|       |
  846|       |    // Check for spill
  847|   [0;35m446k[0m|    if (op->slot != SLOT_NONE) {
  848|  [0;35m10.6k[0m|      if (op->reg == REG_NONE) {
  849|  2.59k|        maybe_assign_register(op_cnt, trace, slot, &next_spill);
  850|  2.59k|      }
  851|       |      // printf("Spilling op %li to slot %i from reg %s\n", op_cnt, op->slot,
  852|       |      // reg_names[op->reg]);
  853|  10.6k|      emit_mem_reg(OP_MOV_RM, 0, R15, op->reg);
  854|  10.6k|      emit_mov64(R15, (int64_t)&spill_slot[op->slot]);
  855|  10.6k|    }
  856|       |    /* if (op->reg == REG_NONE) { */
  857|       |    /*   printf("WARNING: emitting op with no reg: %i\n", op_cnt); */
  858|       |    /* } */
  859|       |
  860|       |    // free current register.
  861|   [0;35m446k[0m|    if (op->reg != REG_NONE && op->reg != RDI && op->op != IR_ARG) {
  862|   311k|      assert(slot[op->reg] == op_cnt);
  863|   311k|      slot[op->reg] = -1;
  864|   311k|    }
  865|       |
  866|   446k|    emit_check();
  867|   446k|    switch (op->op) {
  868|  3.75k|    case IR_ARG: {
  869|       |      // Used for typecheck only
  870|  [0;35m3.75k[0m|      if (op->reg == REG_NONE) {
  871|     28|        op->reg = get_free_reg(trace, &next_spill, slot, false);
  872|       |        // printf("EMIT LOAD ONLY\n");
  873|     28|      }
  874|       |      // JIT will load ARG on start.
  875|  3.75k|      emit_op_typecheck(op->reg, op->type, snap_labels[cur_snap]);
  876|       |      /* if (op->slot != SLOT_NONE) { */
  877|       |      /* 	// TODO this is debugging */
  878|       |      /* 	auto offset = emit_offset(); */
  879|       |      /* 	emit_imm8(0xcc); */
  880|       |      /* 	emit_jcc32(JE, offset); */
  881|       |      /* 	emit_mem_reg(OP_CMP, 0, R15, op->reg); */
  882|       |      /* 	emit_mov64(R15, (int64_t)&spill_slot[op->slot]); */
  883|       |      /* } */
  884|       |      /* if (op->reg != REG_NONE) { */
  885|       |      /* 	// TODO this is debugging */
  886|       |      /* 	auto offset = emit_offset(); */
  887|       |      /* 	emit_imm8(0xcc); */
  888|       |      /* 	emit_jcc32(JE, offset); */
  889|       |      /* 	emit_mem_reg(OP_CMP, op->op1 * 8, RDI, op->reg); */
  890|       |      /* } */
  891|  3.75k|      break;
  892|      0|    }
  893|  23.7k|    case IR_SLOAD: {
  894|       |      // Used for typecheck only
  895|  [0;35m23.7k[0m|      if (op->reg == REG_NONE) {
  896|    154|        op->reg = get_free_reg(trace, &next_spill, slot, false);
  897|       |        // printf("EMIT LOAD ONLY\n");
  898|    154|      }
  899|       |      // frame pointer in RDI
  900|  23.7k|      auto reg = op->reg;
  901|  [0;35m23.7k[0m|      if ((op->type & IR_INS_TYPE_GUARD) == 0) {
  902|  7.13k|        goto done;
  903|  7.13k|      }
  904|  16.5k|      emit_op_typecheck(reg, op->type, snap_labels[cur_snap]);
  905|  16.5k|      emit_mem_reg(OP_MOV_MR, op->op1 * 8, RDI, reg);
  906|  16.5k|      break;
  907|  23.7k|    }
  908|  38.3k|    case IR_GGET: {
  909|       |      // Used for typecheck only
  910|  [0;35m38.3k[0m|      if (op->reg == REG_NONE) {
  911|     94|        op->reg = get_free_reg(trace, &next_spill, slot, false);
  912|     94|      }
  913|  38.3k|      auto *sym =
  914|  [0;35m38.3k[0m|          (symbol *)(trace->consts[op->op1 - IR_CONST_BIAS] - SYMBOL_TAG);
  915|  38.3k|      auto reg = op->reg;
  916|  38.3k|      emit_op_typecheck(reg, op->type, snap_labels[cur_snap]);
  917|  38.3k|      emit_mem_reg(OP_MOV_MR, 0, reg, reg);
  918|  [0;35m38.3k[0m|      auto re = (reloc){emit_offset(), trace->consts[op->op1 - IR_CONST_BIAS],
  919|  38.3k|                        RELOC_SYM_ABS};
  920|  38.3k|      arrput(trace->relocs, re);
  921|  38.3k|      emit_mov64(reg, (int64_t)&sym->val);
  922|  38.3k|      break;
  923|  23.7k|    }
  924|    611|    case IR_GSET: {
  925|    611|      maybe_assign_register(op->op2, trace, slot, &next_spill);
  926|    611|      auto *sym =
  927|    [0;35m611[0m|          (symbol *)(trace->consts[op->op1 - IR_CONST_BIAS] - SYMBOL_TAG);
  928|    [0;35m611[0m|      if (ir_is_const(op->op2)) {
  929|    [0;35m122[0m|        auto c = trace->consts[op->op2 - IR_CONST_BIAS];
  930|    122|        auto r = get_free_reg(trace, &next_spill, slot, false);
  931|    122|        emit_mem_reg(OP_MOV_RM, 0, R15, r);
  932|    122|        auto re = (reloc){emit_offset(), c, RELOC_ABS};
  933|    122|        arrput(trace->relocs, re);
  934|    122|        emit_mov64(r, c);
  935|    489|      } else {
  936|    489|        emit_mem_reg(OP_MOV_RM, 0, R15, trace->ops[op->op2].reg);
  937|    489|      }
  938|    [0;35m611[0m|      auto re = (reloc){emit_offset(), trace->consts[op->op1 - IR_CONST_BIAS],
  939|    611|                        RELOC_SYM_ABS};
  940|    611|      arrput(trace->relocs, re);
  941|    611|      emit_mov64(R15, (int64_t)&sym->val);
  942|    611|      break;
  943|  23.7k|    }
  944|    322|    case IR_STRST: {
  945|    322|      maybe_assign_register(op->op1, trace, slot, &next_spill);
  946|    322|      maybe_assign_register(op->op2, trace, slot, &next_spill);
  947|    322|      assert(!(op->op1 & IR_CONST_BIAS));
  948|    322|      assert(trace->ops[op->op1].op == IR_STRREF);
  949|    [0;35m322[0m|      if (op->op2 & IR_CONST_BIAS) {
  950|     17|        emit_mem_reg(OP_MOV8, 0, trace->ops[op->op1].reg, R15);
  951|       |        // must be fixnum
  952|     17|        uint8_t c = trace->consts[op->op2 - IR_CONST_BIAS] >> 8;
  953|     17|        emit_mov64(R15, c);
  954|    305|      } else {
  955|    305|        emit_mem_reg(OP_MOV8, 0, trace->ops[op->op1].reg, R15);
  956|    305|        emit_imm8(8); // untag
  957|    305|        emit_reg_reg(OP_SAR_CONST, 7, R15);
  958|    305|        emit_reg_reg(OP_MOV_MR, R15, trace->ops[op->op2].reg);
  959|    305|      }
  960|    322|      break;
  961|    322|    }
  962|  37.6k|    case IR_STORE: {
  963|  37.6k|      maybe_assign_register(op->op1, trace, slot, &next_spill);
  964|  37.6k|      maybe_assign_register(op->op2, trace, slot, &next_spill);
  965|  37.6k|      assert(!(op->op1 & IR_CONST_BIAS));
  966|  37.6k|      assert(trace->ops[op->op1].op == IR_REF ||
  967|  37.6k|             trace->ops[op->op1].op == IR_VREF);
  968|  [0;35m37.6k[0m|      if (op->op2 & IR_CONST_BIAS) {
  969|  20.0k|        emit_mem_reg(OP_MOV_RM, 0, trace->ops[op->op1].reg, R15);
  970|  [0;35m20.0k[0m|        auto c = trace->consts[op->op2 - IR_CONST_BIAS];
  971|  20.0k|        auto re = (reloc){emit_offset(), c, RELOC_ABS};
  972|  20.0k|        arrput(trace->relocs, re);
  973|  20.0k|        emit_mov64(R15, c);
  974|  20.0k|      } else {
  975|  17.6k|        emit_mem_reg(OP_MOV_RM, 0, trace->ops[op->op1].reg,
  976|  17.6k|                     trace->ops[op->op2].reg);
  977|  17.6k|      }
  978|  37.6k|      break;
  979|  37.6k|    }
  980|    450|    case IR_STRLD: {
  981|    450|      maybe_assign_register(op->op1, trace, slot, &next_spill);
  982|    450|      maybe_assign_register(op->op2, trace, slot, &next_spill);
  983|       |
  984|    450|      uint8_t reg1 = op->reg;
  985|    [0;35m450[0m|      if (!ir_is_const(op->op1)) {
  986|    446|        reg1 = trace->ops[op->op1].reg;
  987|    446|      }
  988|       |
  989|    450|      emit_arith_imm(OP_ARITH_ADD, op->reg, CHAR_TAG);
  990|    450|      emit_imm8(8);
  991|    450|      emit_reg_reg(OP_SAR_CONST, 4, op->reg);
  992|    450|      emit_mem_reg2(OP_MOVZX8, 0, op->reg, op->reg);
  993|    [0;35m450[0m|      if (!ir_is_const(op->op2)) {
  994|    353|        emit_mem_reg_sib(OP_LEA, 16 - PTR_TAG, 0, R15, reg1, op->reg);
  995|    353|        emit_imm8(3);
  996|    353|        emit_reg_reg(OP_SAR_CONST, 7, R15);
  997|    353|        emit_reg_reg(OP_MOV_MR, R15, trace->ops[op->op2].reg);
  998|    353|      } else {
  999|       |        // Must be a fixnum.
 1000|     [0;35m97[0m|        auto c = trace->consts[op->op2 - IR_CONST_BIAS];
 1001|     97|        emit_mem_reg(OP_LEA, 16 - PTR_TAG - (c >> 3), reg1, op->reg);
 1002|     97|      }
 1003|    [0;35m450[0m|      if (ir_is_const(op->op1)) {
 1004|      [0;35m4[0m|        auto c = trace->consts[op->op1 - IR_CONST_BIAS];
 1005|      4|        auto re = (reloc){emit_offset(), c, RELOC_ABS};
 1006|      4|        arrput(trace->relocs, re);
 1007|      4|        emit_mov64(reg1, (int64_t)(c));
 1008|      4|      }
 1009|    450|      break;
 1010|  37.6k|    }
 1011|  97.2k|    case IR_LOAD: {
 1012|       |      // Used for typecheck only
 1013|  [0;35m97.2k[0m|      if (op->reg == REG_NONE) {
 1014|    770|        op->reg = get_free_reg(trace, &next_spill, slot, false);
 1015|       |        // printf("EMIT LOAD ONLY\n");
 1016|    770|      }
 1017|  97.2k|      maybe_assign_register(op->op1, trace, slot, &next_spill);
 1018|  97.2k|      assert(op->reg != REG_NONE);
 1019|  97.2k|      assert(!ir_is_const(op->op1));
 1020|       |      // sassert(!ir_is_const(op->op2));
 1021|  97.2k|      assert(trace->ops[op->op1].op == IR_REF ||
 1022|  97.2k|             trace->ops[op->op1].op == IR_VREF);
 1023|  97.2k|      emit_op_typecheck(op->reg, op->type, snap_labels[cur_snap]);
 1024|  97.2k|      emit_mem_reg(OP_MOV_MR, 0, trace->ops[op->op1].reg, op->reg);
 1025|  97.2k|      break;
 1026|  97.2k|    }
 1027|  8.97k|    case IR_ABC: {
 1028|  8.97k|      maybe_assign_register(op->op1, trace, slot, &next_spill);
 1029|  8.97k|      maybe_assign_register(op->op2, trace, slot, &next_spill);
 1030|  8.97k|      emit_jcc32(JL, snap_labels[cur_snap]);
 1031|  8.97k|      emit_arith_op(OP_ARITH_CMP, OP_CMP, R15, op->op2, trace, slot);
 1032|  [0;35m8.97k[0m|      if(!ir_is_const(op->op1)) {
 1033|  8.89k|	emit_mem_reg(OP_MOV_MR, 8-PTR_TAG, trace->ops[op->op1].reg, R15);
 1034|  8.89k|      } else {
 1035|     [0;35m86[0m|	vector_s*v = (vector_s*)(trace->consts[op->op1 - IR_CONST_BIAS] - PTR_TAG);
 1036|     86|	emit_mov64(R15, v->len);
 1037|     86|      }
 1038|  8.97k|      break;
 1039|  97.2k|    }
 1040|  8.20k|    case IR_VREF: {
 1041|       |      // TODO: fuse.
 1042|  8.20k|      maybe_assign_register(op->op1, trace, slot, &next_spill);
 1043|  8.20k|      maybe_assign_register(op->op2, trace, slot, &next_spill);
 1044|  8.20k|      assert(op->reg != REG_NONE);
 1045|  [0;35m8.20k[0m|      if (ir_is_const(op->op1)) {
 1046|     [0;35m82[0m|        if (ir_is_const(op->op2)) [0;41m{[0m
 1047|       |[0;41m[0m          // Must be fixnum
 1048|       |
 1049|       |          // TODO could be a special reloc type and one mov.[0;41m[0m
 1050|      [0;35m0[0m|[0;41m          [0m[0;41mauto[0m[0;41m c2 = trace->consts[op->op2 - [0m[0;41mIR_CONST_BIAS[0m[0;41m];[0m
 1051|      0|[0;41m          emit_mem_reg(OP_LEA, 16 - [0m[0;41mPTR_TAG[0m[0;41m + c2, R15, op->reg);[0m
 1052|       |[0;41m[0m[0;41m[0m
 1053|      [0;35m0[0m|[0;41m          [0m[0;41mauto[0m[0;41m c1 = trace->consts[op->op1 - [0m[0;41mIR_CONST_BIAS[0m[0;41m];[0m
 1054|      0|[0;41m          [0m[0;41mauto[0m[0;41m re = (reloc){emit_offset(), c1, RELOC_ABS};[0m
 1055|      0|[0;41m          [0m[0;41marrput[0m[0;41m(trace->relocs, re);[0m
 1056|      0|[0;41m          emit_mov64(R15, c1);[0m
 1057|     82|[0;41m        }[0m else {
 1058|     82|          emit_mem_reg_sib(OP_LEA, 16 - PTR_TAG, 0, trace->ops[op->op2].reg,
 1059|     82|                           R15, op->reg);
 1060|       |
 1061|     [0;35m82[0m|          auto c1 = trace->consts[op->op1 - IR_CONST_BIAS];
 1062|     82|          auto re = (reloc){emit_offset(), c1, RELOC_ABS};
 1063|     82|          arrput(trace->relocs, re);
 1064|     82|          emit_mov64(R15, c1);
 1065|     82|        }
 1066|  8.12k|      } else {
 1067|  [0;35m8.12k[0m|        if (ir_is_const(op->op2)) {
 1068|       |          // Must be fixnum
 1069|  [0;35m5.79k[0m|          auto c = trace->consts[op->op2 - IR_CONST_BIAS];
 1070|  5.79k|          emit_mem_reg(OP_LEA, 16 - PTR_TAG + c, trace->ops[op->op1].reg,
 1071|  5.79k|                       op->reg);
 1072|  5.79k|        } else {
 1073|  2.32k|          emit_mem_reg_sib(OP_LEA, 16 - PTR_TAG, 0, trace->ops[op->op2].reg,
 1074|  2.32k|                           trace->ops[op->op1].reg, op->reg);
 1075|  2.32k|        }
 1076|  8.12k|      }
 1077|  8.20k|      break;
 1078|  8.20k|    }
 1079|   126k|    case IR_REF: {
 1080|       |      // TODO: fuse.
 1081|   126k|      maybe_assign_register(op->op1, trace, slot, &next_spill);
 1082|   [0;35m126k[0m|      if (ir_is_const(op->op1)) {
 1083|     81|        emit_mem_reg(OP_LEA, op->op2, R15, op->reg);
 1084|     [0;35m81[0m|        auto c = trace->consts[op->op1 - IR_CONST_BIAS];
 1085|     81|        auto re = (reloc){emit_offset(), c, RELOC_ABS};
 1086|     81|        arrput(trace->relocs, re);
 1087|     81|        emit_mov64(R15, c);
 1088|   126k|      } else {
 1089|   126k|        emit_mem_reg(OP_LEA, op->op2, trace->ops[op->op1].reg, op->reg);
 1090|   126k|      }
 1091|   126k|      break;
 1092|  8.20k|    }
 1093|    322|    case IR_STRREF: {
 1094|       |      // TODO: fuse.
 1095|    322|      maybe_assign_register(op->op1, trace, slot, &next_spill);
 1096|    322|      maybe_assign_register(op->op2, trace, slot, &next_spill);
 1097|    322|      assert(!ir_is_const(op->op1));
 1098|    [0;35m322[0m|      if (!ir_is_const(op->op2)) {
 1099|    296|        emit_mem_reg_sib(OP_LEA, 16 - PTR_TAG, 0, R15, trace->ops[op->op1].reg,
 1100|    296|                         op->reg);
 1101|    296|        emit_imm8(3);
 1102|    296|        emit_reg_reg(OP_SAR_CONST, 7, R15);
 1103|    296|        emit_reg_reg(OP_MOV_MR, R15, trace->ops[op->op2].reg);
 1104|    296|      } else {
 1105|       |        // must be fixnum
 1106|     [0;35m26[0m|        auto c = trace->consts[op->op2 - IR_CONST_BIAS] >> 3;
 1107|     26|        emit_mem_reg(OP_LEA, 16 - PTR_TAG + c, trace->ops[op->op1].reg,
 1108|     26|                     op->reg);
 1109|     26|      }
 1110|    322|      break;
 1111|    322|    }
 1112|  9.07k|    case IR_ALLOC: {
 1113|  9.07k|      slot[op->reg] = op_cnt; // TODO must be different than op->reg and op->op1 reg
 1114|  9.07k|      maybe_assign_register(op->op1, trace, slot, &next_spill);
 1115|  9.07k|      uint8_t reg_sz = REG_NONE;
 1116|  9.07k|      bool tmp = false;
 1117|  [0;35m9.07k[0m|      if(!ir_is_const(op->op1)) {
 1118|    232|	reg_sz = get_free_reg(trace, &next_spill, slot, false);
 1119|    232|	tmp = true;
 1120|    232|      }
 1121|  9.07k|	slot[op->reg] = -1;
 1122|  9.07k|      emit_arith_imm(OP_ARITH_ADD, op->reg, op->op2 & TAG_MASK);
 1123|  9.07k|      emit_mem_reg(OP_MOV_RM, 0, op->reg, R15);
 1124|  9.07k|      emit_mov64(R15, op->type & ~IR_INS_TYPE_GUARD);
 1125|  [0;35m9.07k[0m|      if (ir_is_const(op->op1)) {
 1126|  [0;35m8.84k[0m|	auto c = trace->consts[op->op1 - IR_CONST_BIAS] >> 3;
 1127|  8.84k|	emit_arith_imm(OP_ARITH_SUB, op->reg, c);
 1128|  8.84k|      } else {
 1129|    232|	emit_reg_reg(OP_SUB, reg_sz, op->reg);
 1130|    232|      }
 1131|  9.07k|      emit_mem_reg(OP_MOV_RM, 0, R15, op->reg);
 1132|  9.07k|      emit_mov64(R15, (int64_t)&alloc_ptr);
 1133|       |      // TODO call GC directly?
 1134|  9.07k|      emit_jcc32(JGE, snap_labels[cur_snap]);
 1135|  9.07k|      emit_reg_reg(OP_CMP, R15, op->reg);
 1136|  [0;35m9.07k[0m|      if (ir_is_const(op->op1)) {
 1137|  [0;35m8.84k[0m|	auto c = trace->consts[op->op1 - IR_CONST_BIAS] >> 3;
 1138|  8.84k|	emit_arith_imm(OP_ARITH_ADD, op->reg, c);
 1139|  8.84k|      } else {
 1140|    232|	emit_reg_reg(OP_ADD, reg_sz, op->reg);
 1141|    232|      }
 1142|  9.07k|      emit_mem_reg(OP_MOV_MR, 0, op->reg, op->reg);
 1143|  9.07k|      emit_mem_reg(OP_MOV_MR, 0, R15, R15);
 1144|  9.07k|      emit_mov64(op->reg, (int64_t)&alloc_ptr);
 1145|  9.07k|      emit_mov64(R15, (int64_t)&alloc_end);
 1146|  [0;35m9.07k[0m|      if (tmp) {
 1147|    232|	emit_imm8(3);
 1148|    232|	emit_reg_reg(OP_SAR_CONST, 7, reg_sz);
 1149|    232|	emit_reg_reg(OP_MOV, trace->ops[op->op1].reg, reg_sz);
 1150|    232|      }
 1151|       |
 1152|  9.07k|      break;
 1153|    322|    }
 1154|    345|    case IR_CARG: {
 1155|    345|      break;
 1156|    322|    }
 1157|     55|    case IR_CCRES: {
 1158|     55|      assert(op->reg == REG_NONE);
 1159|     55|      op->reg = RDI;
 1160|       |      // Fallthrough
 1161|     55|    }
 1162|    639|    case IR_CALLXS: {
 1163|       |      // Used for typecheck only
 1164|    [0;35m639[0m|      if (op->reg == REG_NONE) {
 1165|    350|        op->reg = RAX; // if unused, assign to call result reg.
 1166|    350|      }
 1167|    639|      preserve_for_call(trace, slot, &next_spill);
 1168|       |
 1169|    639|      assign_call_registers(op->op1, trace, slot, &next_spill, 0);
 1170|       |
 1171|       |      // Restore scheme frame ptr
 1172|       |      // C here is function ptr, const, nonGC
 1173|    [0;35m639[0m|      auto c = trace->consts[op->op2 - IR_CONST_BIAS];
 1174|    639|      emit_op_typecheck(op->reg, op->type, snap_labels[cur_snap]);
 1175|       |
 1176|    639|      emit_reg_reg(OP_MOV, RAX, op->reg);
 1177|    639|      emit_reg_reg(OP_MOV, R15, RDI);
 1178|       |      // TODO probably in low mem, no need for mov64
 1179|    639|      emit_call_indirect(RAX);
 1180|    639|      emit_mov64(RAX, c);
 1181|       |      // args
 1182|    639|      emit_call_arguments(op->op1, trace, 0);
 1183|       |
 1184|       |      // Save scheme frame ptr
 1185|    639|      emit_reg_reg(OP_MOV, RDI, R15);
 1186|    639|      break;
 1187|     55|    }
 1188|  55.0k|    case IR_EQ: {
 1189|  55.0k|      emit_cmp(JNE, op, trace, snap_labels[cur_snap], slot, &next_spill);
 1190|  55.0k|      break;
 1191|     55|    }
 1192|  16.6k|    case IR_NE: {
 1193|  16.6k|      emit_cmp(JE, op, trace, snap_labels[cur_snap], slot, &next_spill);
 1194|  16.6k|      break;
 1195|     55|    }
 1196|  2.30k|    case IR_GE: {
 1197|  2.30k|      emit_cmp(JL, op, trace, snap_labels[cur_snap], slot, &next_spill);
 1198|  2.30k|      break;
 1199|     55|    }
 1200|  1.55k|    case IR_LT: {
 1201|  1.55k|      emit_cmp(JGE, op, trace, snap_labels[cur_snap], slot, &next_spill);
 1202|  1.55k|      break;
 1203|     55|    }
 1204|  1.17k|    case IR_GT: {
 1205|  1.17k|      emit_cmp(JLE, op, trace, snap_labels[cur_snap], slot, &next_spill);
 1206|  1.17k|      break;
 1207|     55|    }
 1208|    501|    case IR_LE: {
 1209|    501|      emit_cmp(JG, op, trace, snap_labels[cur_snap], slot, &next_spill);
 1210|    501|      break;
 1211|     55|    }
 1212|  3.71k|    case IR_ADD: {
 1213|  3.71k|      emit_arith(OP_ARITH_ADD, OP_ADD, op, trace, snap_labels[cur_snap], slot,
 1214|  3.71k|                 &next_spill);
 1215|  3.71k|      break;
 1216|     55|    }
 1217|    722|    case IR_MUL: {
 1218|    722|      emit_arith(OP_ARITH_NONE, OP_IMUL, op, trace, snap_labels[cur_snap], slot,
 1219|    722|                 &next_spill);
 1220|    722|      break;
 1221|     55|    }
 1222|    766|    case IR_SHR: {
 1223|    766|      maybe_assign_register(op->op1, trace, slot, &next_spill);
 1224|    [0;35m766[0m|      if (ir_is_const(op->op1)) {
 1225|    [0;35m301[0m|        auto c = trace->consts[op->op1 - IR_CONST_BIAS];
 1226|       |        //assert((c & TAG_MASK) == FIXNUM_TAG);
 1227|    301|        emit_mov64(op->reg, c >> op->op2);
 1228|    465|      } else {
 1229|    465|	emit_imm8(op->op2);
 1230|    465|	emit_reg_reg(OP_SAR_CONST, 7, op->reg);
 1231|    465|        emit_reg_reg(OP_MOV, trace->ops[op->op1].reg, op->reg);
 1232|    465|      }
 1233|    766|      break;
 1234|     55|    }
 1235|    121|    case IR_AND: {
 1236|    121|      maybe_assign_register(op->op1, trace, slot, &next_spill);
 1237|    121|      assert(ir_is_const(op->op2));
 1238|    [0;35m121[0m|      if (ir_is_const(op->op1)) [0;41m{[0m
 1239|      [0;35m0[0m|[0;41m        [0m[0;41mauto[0m[0;41m c = trace->consts[op->op1 - [0m[0;41mIR_CONST_BIAS[0m[0;41m];[0m
 1240|       |[0;41m[0m        //assert((c & TAG_MASK) == FIXNUM_TAG);[0;41m[0m
 1241|      0|[0;41m        emit_mov64(op->reg, c >> op->op2);[0m
 1242|    121|[0;41m      }[0m else {
 1243|    121|	emit_op_imm32(OP_AND_IMM, 4, op->reg, trace->consts[op->op2 - IR_CONST_BIAS]);
 1244|    121|        emit_reg_reg(OP_MOV, trace->ops[op->op1].reg, op->reg);
 1245|    121|      }
 1246|    121|      break;
 1247|    121|    }
 1248|    105|    case IR_CHGTYPE: {
 1249|    105|      assert(op->reg != REG_NONE);
 1250|    105|      maybe_assign_register(op->op1, trace, slot, &next_spill);
 1251|    [0;35m105[0m|      if (ir_is_const(op->op1)) [0;41m{[0m
 1252|      [0;35m0[0m|[0;41m        [0m[0;41mauto[0m[0;41m c = trace->consts[op->op1 - [0m[0;41mIR_CONST_BIAS[0m[0;41m];[0m
 1253|      0|[0;41m        assert((c & TAG_MASK) == FIXNUM_TAG);[0m
 1254|      [0;35m0[0m|[0;41m        [0m[0;41memit_mov64(op->reg, (c << 5) + [0m[0;41mCHAR_TAG[0m[0;41m);[0m
 1255|    105|[0;41m      }[0m else {
 1256|    105|	emit_arith_imm(OP_ARITH_ADD, op->reg, CHAR_TAG);
 1257|    105|	emit_imm8(5);
 1258|    105|	emit_reg_reg(OP_SHL_CONST, 4, op->reg);
 1259|    105|        emit_reg_reg(OP_MOV, trace->ops[op->op1].reg, op->reg);
 1260|    105|      }
 1261|    105|      break;
 1262|    105|    }
 1263|    758|    case IR_REM:
 1264|  1.59k|    case IR_DIV: {
 1265|       |      // DIV is a pain on x86_64.
 1266|       |      // get op1 to RAX.  acquire RDX also.  op2 can be anywhere.
 1267|       |      // sar both operands.
 1268|       |      // cqo to sign-extend RAX to RDX.
 1269|       |      // idiv op2reg
 1270|       |      // shl rax.  Result in rax.
 1271|  [0;35m1.59k[0m|      if (op->reg != RDX) {
 1272|  1.36k|        get_reg(RDX, trace, &next_spill, slot);
 1273|  1.36k|        slot[RDX] = op_cnt;
 1274|  1.36k|      }
 1275|       |
 1276|  [0;35m1.59k[0m|      if (op->reg != RAX) {
 1277|  1.52k|        get_reg(RAX, trace, &next_spill, slot);
 1278|  1.52k|        slot[RAX] = op_cnt;
 1279|  1.52k|      }
 1280|  1.59k|      maybe_assign_register(op->op1, trace, slot, &next_spill);
 1281|  1.59k|      maybe_assign_register(op->op2, trace, slot, &next_spill);
 1282|       |
 1283|  [0;35m1.59k[0m|      if (op->reg != RAX) {
 1284|  1.52k|        slot[RAX] = -1;
 1285|  1.52k|      }
 1286|  [0;35m1.59k[0m|      if (op->reg != RDX) {
 1287|  1.36k|        slot[RDX] = -1;
 1288|  1.36k|      }
 1289|       |
 1290|  1.59k|      uint8_t reg2 = R15;
 1291|       |
 1292|  [0;35m1.59k[0m|      if (op->op == IR_DIV && op->reg != RAX) {
 1293|    822|        emit_reg_reg(OP_MOV, RAX, op->reg);
 1294|    822|      }
 1295|  [0;35m1.59k[0m|      if (op->op == IR_REM && op->reg != RDX) {
 1296|    666|        emit_reg_reg(OP_MOV, RDX, op->reg);
 1297|    666|      }
 1298|       |
 1299|  [0;35m1.59k[0m|      if (op->op == IR_DIV) {
 1300|    839|        emit_imm8(3);
 1301|    839|        emit_reg_reg(OP_SHL_CONST, 4, RAX);
 1302|    839|      } else {
 1303|    758|        emit_imm8(3);
 1304|    758|        emit_reg_reg(OP_SHL_CONST, 4, RDX);
 1305|    758|      }
 1306|       |      // idiv
 1307|  1.59k|      emit_reg_reg(OP_IDIV, 7, reg2);
 1308|       |      // cqo
 1309|  1.59k|      emit_imm8(OP_CQO);
 1310|  1.59k|      emit_rex(1, 0, 0, 0);
 1311|       |
 1312|  [0;35m1.59k[0m|      if (ir_is_const(op->op1)) {
 1313|     [0;35m27[0m|        auto c = trace->consts[op->op1 - IR_CONST_BIAS];
 1314|       |        // C must be fixnum
 1315|     27|        emit_mov64(RAX, c >> 3);
 1316|  1.57k|      } else {
 1317|  1.57k|        emit_imm8(3);
 1318|  1.57k|        emit_reg_reg(OP_SAR_CONST, 7, RAX);
 1319|  [0;35m1.57k[0m|        if (trace->ops[op->op1].reg != RAX) {
 1320|  1.55k|          emit_reg_reg(OP_MOV, trace->ops[op->op1].reg, RAX);
 1321|  1.55k|        }
 1322|  1.57k|      }
 1323|       |
 1324|  [0;35m1.59k[0m|      if (ir_is_const(op->op2)) {
 1325|  [0;35m1.43k[0m|        auto c = trace->consts[op->op2 - IR_CONST_BIAS];
 1326|       |        // C must be fixnum
 1327|  1.43k|        emit_mov64(R15, c >> 3);
 1328|  1.43k|      } else {
 1329|    167|        emit_imm8(3);
 1330|    167|        emit_reg_reg(OP_SAR_CONST, 7, reg2);
 1331|    167|        emit_reg_reg(OP_MOV, trace->ops[op->op2].reg, R15);
 1332|    167|      }
 1333|       |
 1334|  1.59k|      break;
 1335|    758|    }
 1336|  1.45k|    case IR_SUB: {
 1337|  1.45k|      emit_arith(OP_ARITH_SUB, OP_SUB, op, trace, snap_labels[cur_snap], slot,
 1338|  1.45k|                 &next_spill);
 1339|  1.45k|      break;
 1340|    758|    }
 1341|     12|    case IR_FLUSH: {
 1342|     12|      assert(op->reg != REG_NONE);
 1343|     12|      emit_snap(cur_snap, trace, true);
 1344|     12|      emit_arith_imm(OP_ARITH_ADD, op->reg, (trace->snaps[cur_snap].offset) << 3);
 1345|     12|      emit_reg_reg(OP_MOV, RDI, op->reg);
 1346|     12|      break;
 1347|     12|    }
 1348|       |      //     case IR_LOOP: {
 1349|       |      //       printf("------------LOOP-------------\n");
 1350|       |      //       a.bind(loop_label);
 1351|       |      //       use_loop = true;
 1352|       |      //       break;
 1353|       |      //     }
 1354|       |      //     case IR_PHI: {
 1355|       |      //       auto reg1 = ir_to_asmjit[trace->ops[op->op1].reg];
 1356|       |      //       auto reg2 = ir_to_asmjit[trace->ops[op->op2].reg];
 1357|       |      //       if(reg1 != reg2) {
 1358|       |      // 	a.mov(reg1, reg2);
 1359|       |      //       }
 1360|       |      //       break;
 1361|       |      //     }
 1362|  4.92k|    case IR_RET: {
 1363|       |      // TODO reloc if functions can move.
 1364|       |      // FIXNUM
 1365|  [0;35m4.92k[0m|      auto retadd = (int64_t)(trace->consts[op->op1 - IR_CONST_BIAS]);
 1366|       |      // Constant return address ptr.
 1367|  [0;35m4.92k[0m|      auto b = (int32_t)trace->consts[op->op2 - IR_CONST_BIAS];
 1368|       |
 1369|  4.92k|      emit_arith_imm(OP_ARITH_SUB, RDI, b);
 1370|  4.92k|      emit_jcc32(JNE, snap_labels[cur_snap]);
 1371|       |
 1372|  4.92k|      emit_mem_reg(OP_CMP, -8, RDI, R15);
 1373|       |
 1374|  4.92k|      emit_mov64(R15, retadd);
 1375|       |
 1376|  4.92k|      break;
 1377|     12|    }
 1378|      0|    [0;41mdefault: {[0m
 1379|      0|[0;41m      printf("Can't jit op: %s\n", ir_names[(int)op->op]);[0m
 1380|      0|[0;41m      exit(-1)[0m;
 1381|     12|    }
 1382|   446k|    }
 1383|   446k|  }
 1384|       |
 1385|  10.0k|done:
 1386|       |  // TODO parent loads should have separate TAG
 1387|  10.0k|  {
 1388|  10.0k|    map moves;
 1389|  10.0k|    map res;
 1390|  10.0k|    moves.mp_sz = 0;
 1391|  [0;35m44.9k[0m|    for (; op_cnt >= 0; op_cnt--) {
 1392|  34.9k|      auto op = &trace->ops[op_cnt];
 1393|  34.9k|      auto val = find_val_for_slot(op->op1, side_exit, parent);
 1394|  34.9k|      asm_add_to_pcopy(&moves, op, val, parent);
 1395|  34.9k|    }
 1396|  10.0k|    serialize_parallel_copy(&moves, &res, R15);
 1397|  10.0k|    asm_emit_pcopy(&res);
 1398|  10.0k|  }
 1399|       |
 1400|  10.0k|  trace->fn = (Func)emit_offset();
 1401|       |  
 1402|  [0;35m10.0k[0m|  if (trace->link == trace->num) {
 1403|       |    // It's a self loop.
 1404|    441|    asm_jit_args(trace, trace);
 1405|    441|  }
 1406|       |  
 1407|  [0;35m10.0k[0m|  if (loop_offset_label != 0U) {
 1408|    441|    emit_bind(emit_offset(), loop_offset_label);
 1409|    441|  }
 1410|       |
 1411|  10.0k|  auto start = emit_offset();
 1412|  10.0k|  Func fn = (Func)start;
 1413|       |
 1414|  10.0k|  auto len = (int)(end - start);
 1415|  [0;35m10.0k[0m|  if (verbose) [0;41m{[0m
 1416|      0|[0;41m    disassemble((const uint8_t *)fn, len);[0m
 1417|      0|[0;41m  }[0m
 1418|       |
 1419|  [0;35m10.0k[0m|  if (side_exit != nullptr) {
 1420|  8.11k|    assert(fn == trace->fn);
 1421|  8.11k|    emit_bind(trace->fn, side_exit->patchpoint);
 1422|  8.11k|  }
 1423|       |
 1424|  [0;35m10.0k[0m|  char* dumpname = parent ? "Side Trace" : "Trace";
 1425|       |#ifdef JITDUMP
 1426|       |  perf_map((uint64_t)fn, len, dumpname);
 1427|       |  if (jit_dump_flag) {
 1428|       |    jit_dump(len, (uint64_t)fn, dumpname);
 1429|       |  }
 1430|       |  jit_reader_add(len, (uint64_t)fn, 0, 0, dumpname);
 1431|       |#endif
 1432|       |#ifdef VALGRIND
 1433|       |  VALGRIND_DISCARD_TRANSLATIONS(fn, len);
 1434|       |#endif
 1435|  10.0k|}
 1436|       |
 1437|       |extern unsigned int *patchpc;
 1438|       |extern unsigned int patchold;
 1439|  1.36G|int jit_run(unsigned int tnum, unsigned int **o_pc, long **o_frame, long* argcnt) {
 1440|  1.36G|  exit_state state;
 1441|  1.36G|  auto *trace = trace_cache_get(tnum);
 1442|       |
 1443|  [0;35m4.88G[0m|  for (uint64_t i = 0; i < arrlen(trace->ops); i++) {
 1444|  4.88G|    auto op = &trace->ops[i];
 1445|  [0;35m4.88G[0m|    if (op->op != IR_ARG) {
 1446|  1.35G|      break;
 1447|  1.35G|    }
 1448|  [0;35m3.52G[0m|    if (op->reg != REG_NONE) {
 1449|       |      /* printf("Set reg %s to %li\n", reg_names[op->reg], (*o_frame)[op->op1]); */
 1450|  3.52G|      state.regs[op->reg] = (*o_frame)[op->op1];
 1451|  3.52G|    }
 1452|       |    // TODO this also spills above for IR_ARG, unnecessarily
 1453|  [0;35m3.52G[0m|    if (op->slot != SLOT_NONE) {
 1454|       |      /* printf("Set slot %i to %li\n", op->slot, (*o_frame)[op->op1]); */
 1455|  13.4M|      spill_slot[op->slot] = (*o_frame)[op->op1];
 1456|  13.4M|    }
 1457|  3.52G|  }
 1458|       |
 1459|       |   /* printf("FN start %i\n", tnum); */
 1460|  1.36G|  jit_entry_stub(*o_frame, trace->fn, &state);
 1461|  1.36G|  trace = state.trace;
 1462|  1.36G|  long unsigned exit = state.snap;
 1463|  1.36G|  auto *snap = &trace->snaps[exit];
 1464|  1.36G|  *argcnt = snap->argcnt;
 1465|       |
 1466|       |  /* bcfunc* func = find_func_for_frame(snap->pc); */
 1467|       |  /* assert(func); */
 1468|       |  /*  printf("exit %li from trace %i new pc %li func %s\n", exit, trace->num, */
 1469|       |  /*  snap->pc - &func->code[0], func->name); */
 1470|       |  /*  fflush(stdout); */
 1471|       |
 1472|  1.36G|  restore_snap(snap, trace, &state, o_frame, o_pc);
 1473|       |
 1474|  [0;35m1.36G[0m|  if (exit != arrlen(trace->snaps) - 1) {
 1475|   [0;35m228M[0m|    if (snap->exits < 255) {
 1476|   129k|      snap->exits++;
 1477|   [0;35m129k[0m|      if (snap->exits == 255) {
 1478|    103|        if (verbose)
 1479|      0|          [0;41mprintf("Blacklist: Side max in trace %i exit %lu\n", trace->num,[0m
 1480|      0|[0;41m                 exit)[0m;
 1481|    103|      }
 1482|   129k|    }
 1483|   [0;35m228M[0m|    if (snap->exits < 10) {
 1484|       |
 1485|   228M|    } else {
 1486|       |
 1487|   [0;35m228M[0m|      if (snap->exits % 10 == 0 && snap->exits < 250) {
 1488|       |        // printf("Hot snap %li\n", exit);
 1489|  [0;35m12.2k[0m|        if (INS_OP(**o_pc) == JLOOP) {
 1490|       |          // printf("HOT SNAP to JLOOP\n");
 1491|    930|          patchpc = *o_pc;
 1492|    930|          patchold = **o_pc;
 1493|    [0;35m930[0m|          auto *otrace = trace_cache_get(INS_D(**o_pc));
 1494|    930|          **o_pc = otrace->startpc;
 1495|    930|        }
 1496|  12.2k|        record_side(trace, snap);
 1497|  12.2k|        return 1;
 1498|  12.2k|      }
 1499|   228M|    }
 1500|       |    // TODO this may or may not be working as intended:
 1501|       |    // Should only replace if *this trace*'s start PC is o_pc,
 1502|       |    // and it's originaly a RET, i.e. we predicted the RET wrong.
 1503|   [0;35m228M[0m|    if (INS_OP(**o_pc) == JLOOP) {
 1504|       |      // TODO make work for both RET1 and JLOOP
 1505|  [0;35m67.5k[0m|      auto *otrace = trace_cache_get(INS_D(**o_pc));
 1506|  [0;35m67.5k[0m|      if (INS_OP(otrace->startpc) == LOOP) [0;41m{[0m
 1507|      0|[0;41m        (*o_pc)++;[0m
 1508|  67.5k|[0;41m      }[0m else {
 1509|  67.5k|        *o_pc = &otrace->startpc;
 1510|  67.5k|      }
 1511|       |      // printf("Exit to loop\n");
 1512|  67.5k|      return 0;
 1513|  67.5k|    }
 1514|   228M|  }
 1515|       |
 1516|       |  // printf("FN return\n");
 1517|  1.36G|  return 0;
 1518|  1.36G|}

[0;36m/home/davejwatson/myprojects/boom/asm_x64.h:
[0m    1|       |#pragma once
    2|       |
    3|       |#include "ir.h"
    4|       |
    5|       |void assign_registers(trace_s *trace);
    6|       |void asm_jit(trace_s *trace, snap_s *side, trace_s *parent);
    7|       |
    8|  2.41M|#define regcnt 16
    9|  3.52G|#define REG_NONE 16
   10|  8.39G|#define SLOT_NONE 0
   11|       |extern const char *reg_names[];
   12|       |
   13|       |int jit_run(unsigned int tnum, unsigned int **o_pc, long **o_frame, long* argcnt);

[0;36m/home/davejwatson/myprojects/boom/boom.c:
[0m    1|       |#include <getopt.h>  // for no_argument, getopt_long, option
    2|       |#include <stdbool.h> // for bool, false, true
    3|       |#include <stdio.h>   // for printf
    4|       |#include <stdlib.h>  // for exit
    5|       |#include <string.h>  // for strcmp, strcpy, strlen
    6|       |
    7|       |#include "gc.h" // for GC_init
    8|       |#ifdef JITDUMP
    9|       |#include "jitdump.h" // for jit_dump_close, jit_dump_init
   10|       |#endif
   11|       |#ifdef PROFILER
   12|       |#include "profiler.h" // for profiler_start, profiler_stop
   13|       |#endif
   14|       |#include "bytecode.h"
   15|       |#include "readbc.h"       // for readbc_file, readbc_image
   16|       |#include "symbol_table.h" // for symbol_table_find_cstr
   17|       |#include "types.h"        // for from_c_str, symbol, CLOSURE_TAG, TRUE_REP
   18|       |#include "vm.h"           // for run
   19|       |
   20|       |#include "record.h"
   21|       |
   22|    392|#define auto __auto_type
   23|    224|#define nullptr NULL
   24|       |
   25|       |extern int joff;
   26|       |#ifdef JITDUMP
   27|       |extern bool jit_dump_flag;
   28|       |#endif
   29|       |
   30|       |static struct option long_options[] = {
   31|       |    {"verbose", no_argument, nullptr, 'v'},
   32|       |    {"profile", no_argument, nullptr, 'p'},
   33|       |    {"joff", no_argument, nullptr, 'o'},
   34|       |#ifdef JITDUMP
   35|       |    {"dump", no_argument, nullptr, 'd'},
   36|       |#endif
   37|       |    {"help", no_argument, nullptr, 'h'},
   38|       |    {"list", no_argument, nullptr, 'l'},
   39|       |    {"max-trace", required_argument, nullptr, 'm'},
   40|       |    {"heap-sz", required_argument, nullptr, 's'},
   41|       |    {"exe", no_argument, nullptr, 'e'},
   42|       |    {nullptr, no_argument, nullptr, 0},
   43|       |};
   44|       |
   45|      0|void print_help() [0;41m{[0m
   46|      0|[0;41m  printf("Usage: boom [OPTION]\n");[0m
   47|      0|[0;41m  printf("Available options are:\n");[0m
   48|      0|[0;41m#ifdef JIT[0m
   49|      0|[0;41m  printf("      --joff     \tTurn off jit\n");[0m
   50|      0|[0;41m  printf("  -m, --max-trace\tStop JITting after # trace\n");[0m
   51|      0|[0;41m#endif[0m
   52|       |[0;41m[0m#ifdef JITDUMP
   53|       |  printf("      --dump     \tDump linux perf jit info\n");
   54|       |#endif[0;41m[0m
   55|      0|[0;41m  printf("  -l, --list     \tList bytecode and stop\n");[0m
   56|      0|[0;41m#ifdef PROFILER[0m
   57|      0|[0;41m  printf("  -p, --profile  \tSampling profiler\n");[0m
   58|      0|[0;41m#endif[0m
   59|      0|[0;41m  printf("      --exe      \tGenerate an executable from the scheme file\n");[0m
   60|       |[0;41m[0m[0;41m[0m
   61|      0|[0;41m  printf("  -s, --heap-sz  \tHeap size (in pages)\n");[0m
   62|      0|[0;41m  printf("  -v, --verbose  \tTurn on verbose jit mode\n");[0m
   63|      0|[0;41m  printf("  -h, --help     \tPrint this help\n");[0m
   64|      0|[0;41m}[0m
   65|       |
   66|       |static bool list = false;
   67|       |extern unsigned TRACE_MAX;
   68|       |
   69|       |// Call in to the compiled bytecode function (define (compile-file file) ...)
   70|     56|void compile_file(const char *file) {
   71|       |  // Watch out for GC safety, from_c_str allocates.
   72|     56|  auto str = from_c_str(file);
   73|     56|  auto *sym = symbol_table_find_cstr("compile-file"); // DOes not allocate.
   74|     56|  long args[3] = {0, str, TRUE_REP};
   75|     [0;35m56[0m|  if ((sym == nullptr) || sym->val == UNDEFINED_TAG) [0;41m{[0m
   76|      0|[0;41m    printf("Error: Attempting to compile a scm file, but can't find "[0m
   77|      0|[0;41m           "compile-file\n");[0m
   78|      0|[0;41m    exit(-1);[0m
   79|      0|[0;41m  }[0m
   80|     [0;35m56[0m|  auto *clo = (closure_s *)(sym->val - CLOSURE_TAG);
   81|     56|  auto *func = (bcfunc *)clo->v[0];
   82|       |
   83|     [0;35m56[0m|  run(func, list ? [0;41m3[0m : 2, args);
   84|     56|}
   85|       |
   86|      0|void generate_exe(char* filename, const char* bc_name) [0;41m{[0m
   87|      0|[0;41m  char tmp[512];[0m
   88|       |[0;41m[0m[0;41m[0m
   89|      0|[0;41m  strcpy(tmp, filename);[0m
   90|      0|[0;41m  strcpy(tmp + strlen(filename), ".c");[0m
   91|      0|[0;41m  [0m[0;41mauto[0m[0;41m f = fopen(tmp, "w");[0m
   92|      0|[0;41m  [0m[0;41mauto[0m[0;41m fin = fopen(bc_name, "r");[0m
   93|      0|[0;41m  fputs("unsigned char exe_scm_bc[] = {\n", f);[0m
   94|      0|[0;41m  int res = fgetc(fin);[0m
   95|      0|[0;41m  long cnt = 0;[0m
   96|      [0;35m0[0m|[0;41m  while([0m[0;41mres != EOF[0m[0;41m) [0m[0;41m{[0m
   97|      0|[0;41m    fprintf(f, "%i, ", res);[0m
   98|      0|[0;41m    res = fgetc(fin);[0m
   99|      0|[0;41m    cnt++;[0m
  100|      0|[0;41m  }[0m[0;41m[0m
  101|      0|[0;41m  fprintf(f, "};\nunsigned int exe_scm_bc_len = %li;\n", cnt);[0m
  102|      0|[0;41m  fclose(fin);[0m
  103|      0|[0;41m  fclose(f);[0m
  104|       |[0;41m[0m[0;41m[0m
  105|      0|[0;41m  filename[strlen(filename)-4] = '\0';[0m
  106|       |[0;41m[0m[0;41m[0m
  107|      0|[0;41m  char tmp2[512];[0m
  108|      0|[0;41m  snprintf(tmp2, 511, "clang -flto -o %s $LDFLAGS -L. -lboom_exe -lboom_vm %s -lcapstone -lm", filename, tmp);[0m
  109|      0|[0;41m  printf("Running: %s\n", tmp2);[0m
  110|      0|[0;41m  system(tmp2);[0m
  111|      0|[0;41m}[0m
  112|       |
  113|       |extern bool verbose;
  114|       |extern int profile;
  115|       |extern size_t page_cnt;
  116|     56|int main(int argc, char *argv[]) {
  117|       |
  118|     56|  int c;
  119|     56|  bool exe = false;
  120|    [0;35m112[0m|  while ((c = getopt_long(argc, argv, "vslphjd:", long_options, nullptr)) !=
  121|    112|         -1) {
  122|     56|    switch (c) {
  123|      0|    [0;41mcase 'e':[0m
  124|      0|[0;41m      exe = true;[0m
  125|      0|[0;41m      break[0m[0;41m;[0m
  126|      0|    [0;41mcase 'p':[0m
  127|      0|[0;41m      profile = 1;[0m
  128|      0|[0;41m      break[0m[0;41m;[0m
  129|      0|    [0;41mcase 'v':[0m
  130|      0|[0;41m      verbose = true;[0m
  131|      0|[0;41m      break[0m[0;41m;[0m
  132|      0|    [0;41mcase 'o':[0m
  133|      0|[0;41m      joff = 1;[0m
  134|      0|[0;41m      break[0m[0;41m;[0m
  135|      0|    [0;41mcase 'l':[0m
  136|      0|[0;41m      list = true;[0m
  137|      0|[0;41m      break[0m[0;41m;[0m
  138|     56|    case 's':
  139|     56|      page_cnt = atoi(optarg);
  140|     56|      printf("Heap size %li MB\n", (page_cnt * 4096) / 1024 / 1024);
  141|     56|      break;
  142|       |#ifdef JITDUMP
  143|       |    case 'd':
  144|       |      jit_dump_flag = true;
  145|       |      break;
  146|       |#endif      
  147|      0|    [0;41mcase 'm':[0m
  148|      0|[0;41m      TRACE_MAX = atoi(optarg);[0m
  149|      0|[0;41m      printf("MAX TRACE is %i\n", TRACE_MAX);[0m
  150|      0|[0;41m      break[0m[0;41m;[0m
  151|      0|    [0;41mdefault:[0m
  152|      0|[0;41m      print_help();[0m
  153|      0|[0;41m      exit(-1)[0m;
  154|     56|    }
  155|     56|  }
  156|       |
  157|     56|  GC_init();
  158|       |// GC_expand_hp(50000000);
  159|       |#ifdef JITDUMP
  160|       |  if (jit_dump_flag) {
  161|       |    jit_dump_init();
  162|       |  }
  163|       |#endif
  164|     56|#ifdef PROFILER
  165|     [0;35m56[0m|  if (profile != 0) [0;41m{[0m
  166|      0|[0;41m    profiler_start();[0m
  167|      0|[0;41m  }[0m
  168|     56|#endif
  169|     56|  auto ojoff = joff;
  170|     56|  joff = 1;
  171|     56|  load_bootstrap();
  172|       |
  173|    [0;35m112[0m|  for (int i = optind; i < argc; i++) {
  174|     56|    auto len = strlen(argv[i]);
  175|     [0;35m56[0m|    if (len >= 4 && strcmp(".scm", argv[i] + len - 4) == 0) {
  176|     56|      char tmp[len + 1 + 3];
  177|     56|      strcpy(tmp, argv[i]);
  178|     56|      strcpy(tmp + len, ".bc");
  179|     56|      printf("Compiling script %s\n", argv[i]);
  180|     56|      compile_file(argv[i]);
  181|     [0;35m56[0m|      if (exe) [0;41m{[0m
  182|      0|[0;41m	generate_exe(argv[i], tmp);[0m
  183|      0|[0;41m      }[0m
  184|     [0;35m56[0m|      if (list || exe) [0;41m{[0m
  185|      0|[0;41m        break;[0m
  186|      0|[0;41m      }[0m
  187|     56|      printf("Running script %s\n", tmp);
  188|     56|      joff = ojoff;
  189|     56|      auto *start_func = readbc_file(tmp);
  190|     56|      run(start_func, 0, nullptr);
  191|     [0;35m56[0m|    } else [0;41mif ([0m[0;41mlen >= 3[0m[0;41m && [0m[0;41mstrcmp(".bc", argv[i] + len - 3) == 0[0m[0;41m) [0m[0;41m{[0m
  192|      0|[0;41m      printf("Running script %s\n", argv[i]);[0m
  193|      0|[0;41m      joff = ojoff;[0m
  194|      0|[0;41m      [0m[0;41mauto[0m[0;41m *start_func = readbc_file(argv[i]);[0m
  195|      0|[0;41m      run(start_func, 0, [0m[0;41mnullptr[0m[0;41m);[0m
  196|      0|[0;41m    } else [0m[0;41m{[0m
  197|      0|[0;41m      printf("Unknown file type %s\n", argv[i]);[0m
  198|      0|[0;41m    }[0m
  199|     56|  }
  200|       |
  201|     56|#ifdef PROFILER
  202|     [0;35m56[0m|  if (profile != 0) [0;41m{[0m
  203|      0|[0;41m    profiler_stop();[0m
  204|      0|[0;41m  }[0m
  205|     56|#endif
  206|       |
  207|       |#ifdef JITDUMP
  208|       |  if (jit_dump_flag) {
  209|       |    jit_dump_close();
  210|       |  }
  211|       |#endif
  212|     56|#ifdef JIT
  213|     56|  free_trace();
  214|     56|#endif
  215|     56|  free_script();
  216|     56|  free_vm();
  217|       |
  218|     56|  return 0;
  219|     56|}

[0;36m/home/davejwatson/myprojects/boom/bytecode.h:
[0m    1|       |#pragma once
    2|       |
    3|       |#include <stdint.h>
    4|       |
    5|       |extern const char *ins_names[];
    6|       |extern long *const_table;
    7|       |extern unsigned long const_table_sz;
    8|       |
    9|    334|#define CODE(i, a, b, c) (((c) << 24) | ((b) << 16) | ((a) << 8) | (i))
   10|   [0;35m256k[0m|#define CODE_D(i, a, d) (((d) << 16) | ((a) << 8) | (i))
   11|  5.68G|#define INS_OP(i) (i & 0xff)
   12|  2.51G|#define INS_A(i) ((i >> 8) & 0xff)
   13|  1.20M|#define INS_B(i) ((i >> 16) & 0xff)
   14|   353k|#define INS_C(i) ((i >> 24) & 0xff)
   15|  1.76G|#define INS_D(i) (i >> 16)
   16|       |
   17|       |typedef struct bcfunc {
   18|       |  char *name;
   19|       |  uint32_t codelen;
   20|       |  uint8_t poly_cnt;
   21|       |  unsigned int code[];
   22|       |} bcfunc;

[0;36m/home/davejwatson/myprojects/boom/emit_x64.c:
[0m    1|       |#define _DEFAULT_SOURCE
    2|       |
    3|       |#include <assert.h>
    4|       |#include <stdint.h>
    5|       |#include <stdio.h>
    6|       |#include <stdlib.h>
    7|       |#include <sys/mman.h>
    8|       |
    9|       |#include "emit_x64.h"
   10|       |
   11|       |static uint8_t *mtop = NULL;
   12|       |static uint8_t *mend = NULL;
   13|       |static uint8_t *p = NULL;
   14|       |
   15|       |static const size_t page_cnt = 4000;
   16|       |static const size_t msize = page_cnt * 4096;
   17|       |
   18|  8.56k|#define auto __auto_type
   19|       |
   20|       |/////////////////// instruction encoding
   21|       |
   22|  1.47M|void emit_rex(uint8_t w, uint8_t r, uint8_t x, uint8_t b) {
   23|  1.47M|  *(--p) = 0x40 | (w << 3) | (r << 2) | (x << 1) | b;
   24|  1.47M|}
   25|       |
   26|  1.08M|void emit_modrm(uint8_t mod, uint8_t reg, uint8_t rm) {
   27|  1.08M|  *(--p) = (mod << 6) | (reg << 3) | rm;
   28|  1.08M|}
   29|       |
   30|  12.8k|void emit_sib(uint8_t scale, uint8_t index, uint8_t base) {
   31|  12.8k|  *(--p) = (scale << 6) | ((0x7 & index) << 3) | ((0x7 & base));
   32|  12.8k|}
   33|       |
   34|  7.85k|void emit_imm8(uint8_t imm) { *(--p) = imm; }
   35|       |
   36|   220k|void emit_imm64(int64_t imm) {
   37|   220k|  p -= sizeof(int64_t);
   38|   220k|  *(int64_t *)p = imm;
   39|   220k|}
   40|       |
   41|   595k|void emit_imm32(int32_t imm) {
   42|   595k|  p -= sizeof(int32_t);
   43|   595k|  *(int32_t *)p = imm;
   44|   595k|}
   45|       |
   46|   362k|void emit_mov64(uint8_t r, int64_t imm) {
   47|       |  // Note that 'imm' isn't necessarily a number here,
   48|       |  // so we can't narrow negative numbers.
   49|   [0;35m362k[0m|  if (imm & 0xffffffff00000000) {
   50|   220k|    emit_imm64(imm);
   51|   220k|    *(--p) = 0xb8 | (0x7 & r);
   52|   220k|    emit_rex(1, 0, 0, r >> 3);
   53|   220k|  } else {
   54|   141k|    emit_imm32((int32_t)imm);
   55|   141k|    *(--p) = 0xb8 | (0x7 & r);
   56|   141k|    emit_rex(0, 0, 0, r >> 3);
   57|   141k|  }
   58|   362k|}
   59|       |
   60|  6.44k|void emit_call_indirect(uint8_t r) {
   61|  6.44k|  emit_modrm(0x3, 0x2, 0x7 & r);
   62|  6.44k|  *(--p) = 0xff;
   63|  6.44k|  emit_rex(1, 0, 0, r >> 3);
   64|  6.44k|}
   65|       |
   66|      0|void emit_call32(int32_t offset) [0;41m{[0m
   67|      0|[0;41m  emit_imm32(offset);[0m
   68|      0|[0;41m  *(--p) = 0xe8;[0m
   69|      0|[0;41m}[0m
   70|       |
   71|      0|void emit_ret() [0;41m{ *(--p) = 0xc3; }[0m
   72|       |
   73|   111k|void emit_cmp_reg_imm32(uint8_t r, int32_t imm) {
   74|   [0;35m111k[0m|  if ((int32_t)((int8_t)imm) != imm) [0;41m{[0m
   75|      0|[0;41m  emit_imm32(imm);[0m
   76|      0|[0;41m  emit_reg_reg(0x81, 7, r);[0m
   77|   111k|[0;41m  }[0m else {
   78|   111k|    *(--p) = imm;
   79|   111k|    emit_reg_reg(0x83, 7, r);
   80|   111k|  }
   81|   111k|}
   82|       |
   83|      0|void emit_cmp_reg_reg(uint8_t src, uint8_t dst) [0;41m{[0m
   84|      0|[0;41m  emit_modrm(0x3, 0x7 & src, 0x7 & dst);[0m
   85|      0|[0;41m  *(--p) = 0x3b;[0m
   86|      0|[0;41m  emit_rex(1, src >> 3, 0, dst >> 3);[0m
   87|      0|[0;41m}[0m
   88|       |
   89|   233k|void emit_jcc32(enum jcc_cond cond, uint64_t offset) {
   90|   233k|  int64_t off = (int64_t)offset - (int64_t)emit_offset();
   91|       |  // TODO check fits in int32_t.
   92|   [0;35m233k[0m|  if ((int32_t)((int8_t)off) == off) {
   93|  18.3k|    *(--p) = (int8_t)off;
   94|  18.3k|    *(--p) = cond - 0x10;
   95|   215k|  } else {
   96|   215k|    emit_imm32(off);
   97|   215k|    *(--p) = cond;
   98|   215k|    *(--p) = 0x0f;
   99|   215k|  }
  100|   233k|}
  101|       |
  102|   103k|void emit_jmp32(int32_t offset) {
  103|   103k|  emit_imm32(offset);
  104|   103k|  *(--p) = 0xe9;
  105|   103k|}
  106|       |
  107|      0|void emit_jmp_indirect(int32_t offset) [0;41m{[0m
  108|      0|[0;41m  emit_imm32(offset);[0m
  109|      0|[0;41m  emit_modrm(0x0, 4, RBP);[0m
  110|      0|[0;41m  *(--p) = 0xff;[0m
  111|      0|[0;41m}[0m
  112|       |
  113|  18.2k|void emit_jmp_abs(enum registers r) {
  114|  18.2k|  emit_modrm(0x3, 4, 0x7 & r);
  115|  18.2k|  *(--p) = 0xff;
  116|  [0;35m18.2k[0m|  if (r >> 3) {
  117|  18.2k|    emit_rex(0, 0, 0, r >> 3);
  118|  18.2k|  }
  119|  18.2k|}
  120|       |
  121|   527k|void emit_reg_reg(uint8_t opcode, uint8_t src, uint8_t dst) {
  122|   527k|  emit_modrm(0x3, 0x7 & src, 0x7 & dst);
  123|   527k|  *(--p) = opcode;
  124|   527k|  emit_rex(1, src >> 3, 0, dst >> 3);
  125|   527k|}
  126|       |
  127|    722|void emit_reg_reg2(uint8_t opcode, uint8_t src, uint8_t dst) {
  128|    722|  emit_modrm(0x3, 0x7 & src, 0x7 & dst);
  129|    722|  *(--p) = opcode;
  130|    722|  *(--p) = 0x0f;
  131|    722|  emit_rex(1, src >> 3, 0, dst >> 3);
  132|    722|}
  133|       |
  134|       |void emit_mem_reg_sib(uint8_t opcode, int32_t offset, uint8_t scale,
  135|  12.7k|                      uint8_t index, uint8_t base, uint8_t reg) {
  136|  [0;35m12.7k[0m|  if ((int32_t)((int8_t)offset) == offset) {
  137|  12.7k|    *(--p) = (int8_t)offset;
  138|  12.7k|    emit_sib(scale, index, base);
  139|  12.7k|    emit_modrm(0x1, 0x7 & reg, 0x4);
  140|  12.7k|  } else {
  141|      9|    emit_imm32(offset);
  142|      9|    emit_sib(scale, index, base);
  143|      9|    emit_modrm(0x2, 0x7 & reg, 0x4);
  144|      9|  }
  145|  12.7k|  *(--p) = opcode;
  146|  12.7k|  emit_rex(1, reg >> 3, index >> 3, base >> 3);
  147|  12.7k|}
  148|       |
  149|       |void emit_mem_reg_sib2(uint8_t opcode, int32_t offset, uint8_t scale,
  150|     49|                       uint8_t index, uint8_t base, uint8_t reg) {
  151|     [0;35m49[0m|  if ((int32_t)((int8_t)offset) == offset) {
  152|     49|    *(--p) = (int8_t)offset;
  153|     49|    emit_sib(scale, index, base);
  154|     49|    emit_modrm(0x1, 0x7 & reg, 0x4);
  155|     49|  } else [0;41m{[0m
  156|      0|[0;41m    emit_imm32(offset);[0m
  157|      0|[0;41m    emit_sib(scale, index, base);[0m
  158|      0|[0;41m    emit_modrm(0x2, 0x7 & reg, 0x4);[0m
  159|      0|[0;41m  }[0m
  160|     49|  *(--p) = opcode;
  161|     49|  *(--p) = 0xf;
  162|     49|  emit_rex(1, reg >> 3, index >> 3, base >> 3);
  163|     49|}
  164|       |
  165|   517k|void emit_mem_reg(uint8_t opcode, int32_t offset, uint8_t r1, uint8_t r2) {
  166|   [0;35m517k[0m|  if ((0x7 & r1) == RSP) {
  167|  9.69k|    emit_mem_reg_sib(opcode, offset, 0, RSP, r1, r2);
  168|   507k|  } else {
  169|   [0;35m507k[0m|    if ((int32_t)((int8_t)offset) == offset) {
  170|   488k|      *(--p) = (int8_t)offset;
  171|   488k|      emit_modrm(0x1, 0x7 & r2, 0x7 & r1);
  172|   488k|    } else {
  173|  19.1k|      emit_imm32(offset);
  174|  19.1k|      emit_modrm(0x2, 0x7 & r2, 0x7 & r1);
  175|  19.1k|    }
  176|   507k|    *(--p) = opcode;
  177|   507k|    emit_rex(1, r2 >> 3, 0, r1 >> 3);
  178|   507k|  }
  179|   517k|}
  180|       |
  181|       |// TODO merge the '2' byte versions
  182|    450|void emit_mem_reg2(uint8_t opcode, int32_t offset, uint8_t r1, uint8_t r2) {
  183|    [0;35m450[0m|  if ((0x7 & r1) == RSP) {
  184|     49|    emit_mem_reg_sib2(opcode, offset, 0, RSP, r1, r2);
  185|    401|  } else {
  186|    [0;35m401[0m|    if ((int32_t)((int8_t)offset) == offset) {
  187|    401|      *(--p) = (int8_t)offset;
  188|    401|      emit_modrm(0x1, 0x7 & r2, 0x7 & r1);
  189|    401|    } else [0;41m{[0m
  190|      0|[0;41m      emit_imm32(offset);[0m
  191|      0|[0;41m      emit_modrm(0x2, 0x7 & r2, 0x7 & r1);[0m
  192|      0|[0;41m    }[0m
  193|    401|    *(--p) = opcode;
  194|    401|    *(--p) = 0xF;
  195|    401|    emit_rex(1, r2 >> 3, 0, r1 >> 3);
  196|    401|  }
  197|    450|}
  198|       |
  199|       |/////////////////// opcodes
  200|       |
  201|   111k|void emit_op_imm32(uint8_t opcode, uint8_t r1, uint8_t r2, int32_t imm) {
  202|   111k|  emit_imm32(imm);
  203|   111k|  emit_reg_reg(opcode, r1, r2);
  204|   111k|}
  205|       |
  206|  70.0k|void emit_arith_imm(enum ARITH_CODES op, uint8_t src, int32_t imm) {
  207|  [0;35m70.0k[0m|  if ((int32_t)((int8_t)imm) != imm) {
  208|  4.26k|  emit_imm32(imm);
  209|  4.26k|  emit_reg_reg(0x81, op, src);
  210|  65.7k|  } else {
  211|  65.7k|    *(--p) = imm;
  212|  65.7k|    emit_reg_reg(0x83, op, src);
  213|  65.7k|  }
  214|  70.0k|}
  215|       |
  216|  28.2k|void emit_push(uint8_t r) {
  217|  28.2k|  *(--p) = 0x50 + (0x7 & r);
  218|  [0;35m28.2k[0m|  if (r >> 3) {
  219|  26.6k|    emit_rex(0, 0, 0, r >> 3);
  220|  26.6k|  }
  221|  28.2k|}
  222|       |
  223|  8.25k|void emit_pop(uint8_t r) {
  224|  8.25k|  emit_modrm(0x3, 0, 0x7 & r);
  225|  8.25k|  *(--p) = 0x8f;
  226|  8.25k|  emit_rex(1, 0, 0, r >> 3);
  227|  8.25k|}
  228|       |
  229|      0|void emit_cmovl(uint8_t dst, uint8_t src) [0;41m{[0m
  230|      0|[0;41m  emit_modrm(0x3, 0x7 & src, 0x7 & dst);[0m
  231|      0|[0;41m  *(--p) = 0x4c;[0m
  232|      0|[0;41m  *(--p) = 0x0f;[0m
  233|      0|[0;41m  emit_rex(1, src >> 3, 0, dst >> 3);[0m
  234|      0|[0;41m}[0m
  235|       |
  236|       |/////////////////// memory
  237|       |
  238|   727k|uint64_t emit_offset() { return (uint64_t)p; }
  239|       |
  240|  8.56k|void emit_bind(uint64_t label, uint64_t jmp) {
  241|  8.56k|  assert(jmp);
  242|  8.56k|  assert(label);
  243|  [0;35m8.56k[0m|  auto offset = (int32_t)((int64_t)label - (int64_t)jmp);
  244|  8.56k|  *(int32_t *)(jmp - 4) = offset;
  245|  8.56k|}
  246|      0|void emit_advance(int64_t offset) [0;41m{ p -= offset; }[0m
  247|       |
  248|   679k|void emit_check() {
  249|   [0;35m679k[0m|  if (p - mtop <= 64) [0;41m{[0m
  250|      0|[0;41m    printf("Fail: Out of jit memory\n");[0m
  251|      0|[0;41m    exit(-1);[0m
  252|      0|[0;41m  }[0m
  253|   679k|}
  254|       |
  255|  10.0k|void emit_init() {
  256|  [0;35m10.0k[0m|  if (mtop) {
  257|  9.96k|    return;
  258|  9.96k|  }
  259|       |
  260|     51|  mtop = (uint8_t *)mmap(NULL, msize, PROT_READ | PROT_WRITE | PROT_EXEC,
  261|     51|                         MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  262|     51|  assert(mtop);
  263|     51|  p = mtop + msize;
  264|     51|  mend = p;
  265|     51|}
  266|       |
  267|      0|void emit_cleanup() [0;41m{ munmap(mtop, msize); }[0m
  268|       |
  269|       |/*
  270|       |int main() {
  271|       |  emit_init();
  272|       |  auto end = emit_offset();
  273|       |  emit_check();
  274|       |
  275|       |  emit_ret();
  276|       |  //emit_mov64(RAX, 101);
  277|       |
  278|       |  //emit_imm32(101);
  279|       |  // *(--p) = 0xb8 | RAX;
  280|       |
  281|       |  long foo = 101;
  282|       |  emit_imm64((int64_t)&foo);
  283|       |  *(--p) = 0xa1;
  284|       |  emit_rex(1, 0, 0, 0);
  285|       |
  286|       |  //disassemble(emit_offset(), end - emit_offset());
  287|       |
  288|       |  long (*res)(void) = emit_offset();
  289|       |
  290|       |  long result = res();
  291|       |  printf("Res: %li\n", result);
  292|       |
  293|       |  emit_cleanup();
  294|       |
  295|       |  return 0;
  296|       |}
  297|       |*/

[0;36m/home/davejwatson/myprojects/boom/gc.c:
[0m    1|       |#include "gc.h"
    2|       |#include "bytecode.h"     // for const_table, const_table_sz
    3|       |#include "ir.h"           // for reloc, trace_s, RELOC_ABS, RELOC_SYM_ABS
    4|       |#include "symbol_table.h" // for sym_table, table, TOMBSTONE
    5|       |#include "third-party/stb_ds.h"
    6|       |#include "defs.h"
    7|       |#include "types.h"    // for TAG_MASK, FORWARD_TAG, SYMBOL_TAG, symbol
    8|       |#include <assert.h>   // for assert
    9|       |#include <stdint.h>   // for uint8_t, int64_t
   10|       |#include <stdio.h>    // for printf
   11|       |#include <stdlib.h>   // for free, realloc
   12|       |#include <string.h>   // for memcpy
   13|       |#include <sys/mman.h> // for mprotect, mmap, PROT_NONE, PROT_READ, PROT...
   14|       |
   15|  5.91G|#define auto __auto_type
   16|       |
   17|       |extern bool verbose;
   18|       |
   19|       |extern long *stack;
   20|       |extern unsigned int stacksz;
   21|       |
   22|       |static bool gc_enable = true;
   23|       |
   24|       |uint8_t *alloc_ptr = NULL;
   25|       |uint8_t *alloc_end = NULL;
   26|       |
   27|       |long **pushed_roots = NULL;
   28|       |
   29|  [0;35m11.7M[0m|void GC_push_root(long *root) { arrput(pushed_roots, root); }
   30|       |
   31|  11.7M|void GC_pop_root(const long *root) {
   32|  11.7M|  assert(arrlen(pushed_roots) != 0);
   33|  [0;35m11.7M[0m|  auto b = arrpop(pushed_roots);
   34|  11.7M|  assert(b == root);
   35|  11.7M|}
   36|       |
   37|      0|void GC_enable(bool en) [0;41m{ gc_enable = en; }[0m
   38|       |
   39|   191M|static bool is_forwarded(long obj) {
   40|   191M|  auto *ptr = (long *)obj;
   41|   [0;35m191M[0m|  return ((*ptr) & TAG_MASK) == FORWARD_TAG;
   42|   191M|}
   43|       |
   44|  69.3M|static void set_forward(long *ptr, void *to) {
   45|  69.3M|  assert(((*ptr) & TAG_MASK) != FORWARD_TAG);
   46|  [0;35m69.3M[0m|  *ptr = (long)to + FORWARD_TAG;
   47|  69.3M|}
   48|       |
   49|  61.1M|static long get_forward(long obj) {
   50|  61.1M|  assert(is_forwarded(obj));
   51|  [0;35m61.1M[0m|  auto *ptr = (long *)obj;
   52|       |  // printf("Obj %p forwarded to %lx\n", ptr, (*ptr) - FORWARD_TAG);
   53|  61.1M|  return (*ptr) - FORWARD_TAG;
   54|  61.1M|}
   55|       |
   56|   138M|size_t __attribute__((always_inline)) heap_object_size(long *obj) {
   57|   138M|  auto type = *obj;
   58|   138M|  assert((type * TAG_MASK) != FORWARD_TAG);
   59|   138M|  switch (type) {
   60|   [0;35m163k[0m|  case FLONUM_TAG:
   61|   163k|    return sizeof(flonum_s);
   62|   [0;35m177k[0m|  case STRING_TAG: {
   63|   177k|    auto *str = (vector_s *)obj;
   64|   177k|    return (str->len >> 3) * sizeof(char) + 16 + 1 /* null tag */;
   65|      0|  }
   66|   [0;35m151k[0m|  case SYMBOL_TAG:
   67|   151k|    return sizeof(symbol);
   68|  [0;35m3.46k[0m|  case CONT_TAG:
   69|  [0;35m11.8M[0m|  case VECTOR_TAG: {
   70|  11.8M|    auto *vec = (vector_s *)obj;
   71|  11.8M|    return (vec->len >> 3) * sizeof(long) + 16;
   72|  3.46k|  }
   73|   [0;35m126M[0m|  case CONS_TAG:
   74|   126M|    return sizeof(cons_s);
   75|  [0;35m79.6k[0m|  case CLOSURE_TAG: {
   76|  79.6k|    auto *clo = (closure_s *)obj;
   77|  79.6k|    return (clo->len >> 3) * sizeof(long) + 16;
   78|  3.46k|  }
   79|    [0;35m496[0m|  case PORT_TAG:
   80|    496|    return sizeof(port_s);
   81|      0|  [0;41mdefault:[0m
   82|      0|[0;41m    printf("Unknown heap object: %li\n", type);[0m
   83|      0|[0;41m    assert(false)[0m[0;41m;[0m
   84|      0|    [0;41mreturn -1[0m;
   85|   138M|  }
   86|   138M|}
   87|       |
   88|   [0;35m138M[0m|size_t align(size_t sz) { return (sz + 7) & (~TAG_MASK); }
   89|       |
   90|  69.3M|void *copy(long *obj) {
   91|       |  // printf("COPY obj %p, type %li\n", obj, *obj);
   92|  69.3M|  size_t sz = heap_object_size(obj);
   93|  69.3M|  auto *res = alloc_ptr;
   94|       |  // printf("Memcpy %li bytes to %p\n", sz, res);
   95|  69.3M|  memcpy(res, obj, sz);
   96|  69.3M|  set_forward(obj, res);
   97|  69.3M|  alloc_ptr += align(sz);
   98|  69.3M|  assert(alloc_ptr < alloc_end);
   99|  69.3M|  return res;
  100|  69.3M|}
  101|       |
  102|   160M|void visit(long *field) {
  103|   160M|  auto from = *field;
  104|   [0;35m160M[0m|  auto tag = from & TAG_MASK;
  105|       |  //  printf("TAG %li\n", tag);
  106|   [0;35m160M[0m|  if (tag == PTR_TAG || tag == FLONUM_TAG || tag == CONS_TAG ||
  107|   [0;35m160M[0m|      tag == CLOSURE_TAG || tag == SYMBOL_TAG) {
  108|   [0;35m130M[0m|    auto p = from & (~TAG_MASK);
  109|       |    //     printf("Visiting ptr field %lx\n", p);
  110|   [0;35m130M[0m|    auto to = is_forwarded(p) ? get_forward(p) : (long)copy((long *)p);
  111|       |    //     printf("Visiting ptr field %lx moved to %lx \n", p, to);
  112|   130M|    *field = to + tag;
  113|   130M|  }
  114|   160M|}
  115|       |
  116|  69.3M|void trace_heap_object(long *obj) {
  117|       |  // printf("Trace heap obj %p\n", obj);
  118|  69.3M|  auto type = *obj;
  119|  69.3M|  assert((type & TAG_MASK) != FORWARD_TAG);
  120|  69.3M|  switch (type) {
  121|  [0;35m81.5k[0m|  case FLONUM_TAG:
  122|   [0;35m170k[0m|  case STRING_TAG:
  123|   170k|    break;
  124|  [0;35m75.6k[0m|  case SYMBOL_TAG: {
  125|  75.6k|    auto *sym = (symbol *)obj;
  126|       |    // temporarily add back the tag
  127|  75.6k|    visit(&sym->name);
  128|  75.6k|    visit(&sym->val);
  129|  75.6k|    break;
  130|  81.5k|  }
  131|  [0;35m1.73k[0m|  case CONT_TAG:
  132|  [0;35m5.91M[0m|  case VECTOR_TAG: {
  133|  5.91M|    auto *vec = (vector_s *)obj;
  134|  [0;35m39.1M[0m|    for (long i = 0; i < (vec->len >> 3); i++) {
  135|  33.2M|      visit(&vec->v[i]);
  136|  33.2M|    }
  137|  5.91M|    break;
  138|  1.73k|  }
  139|  [0;35m63.1M[0m|  case CONS_TAG: {
  140|  63.1M|    auto *cons = (cons_s *)obj;
  141|  63.1M|    visit(&cons->a);
  142|  63.1M|    visit(&cons->b);
  143|  63.1M|    break;
  144|  1.73k|  }
  145|  [0;35m39.8k[0m|  case CLOSURE_TAG: {
  146|  39.8k|    auto *clo = (closure_s *)obj;
  147|       |    // Note start from 1: first field is bcfunc* pointer.
  148|  [0;35m93.9k[0m|    for (long i = 1; i < (clo->len >> 3); i++) {
  149|  54.1k|      visit(&clo->v[i]);
  150|  54.1k|    }
  151|  39.8k|    break;
  152|  1.73k|  }
  153|    [0;35m248[0m|  case PORT_TAG:
  154|    248|    break;
  155|      0|  [0;41mdefault:[0m
  156|      0|[0;41m    printf("Unknown heap object: %li\n", type);[0m
  157|      0|[0;41m    assert[0m(false);
  158|  69.3M|  }
  159|  69.3M|}
  160|       |
  161|       |// Static roots are the stack - stacksz,
  162|       |// the symbol table,
  163|       |// and the constant table.
  164|       |// and symbols?????? shit
  165|       |extern trace_s *trace;
  166|       |extern trace_s **traces;
  167|       |extern long *symbols;
  168|       |
  169|  7.20k|static void visit_trace(trace_s *t) {
  170|   [0;35m135k[0m|  for (size_t i = 0; i < arrlen(t->consts); i++) {
  171|   [0;35m128k[0m|    if (t->consts[i]) {
  172|       |      // printf("Visit const ");
  173|       |      // print_obj(t->consts[i]);
  174|       |      // printf("\n");
  175|   125k|      visit(&t->consts[i]);
  176|   125k|    }
  177|   128k|  }
  178|   [0;35m106k[0m|  for (uint64_t i = 0; i < arrlen(t->relocs); i++) {
  179|  99.3k|    auto reloc = &t->relocs[i];
  180|  99.3k|    auto old = reloc->obj;
  181|  99.3k|    visit(&reloc->obj);
  182|  [0;35m99.3k[0m|    if (reloc->obj != old) {
  183|  23.8k|      switch (reloc->type) {
  184|  9.41k|      case RELOC_ABS: {
  185|  9.41k|        *(int64_t *)(reloc->offset - 8) = reloc->obj;
  186|  9.41k|        break;
  187|      0|      }
  188|  14.4k|      case RELOC_SYM_ABS: {
  189|  [0;35m14.4k[0m|        auto *sym = (symbol *)(reloc->obj - SYMBOL_TAG);
  190|  14.4k|        *(int64_t *)(reloc->offset - 8) = (int64_t) & (sym->val);
  191|  14.4k|        break;
  192|      0|      }
  193|      0|      [0;41mdefault: {[0m
  194|      0|[0;41m        printf("Unknown reloc: %i\n", reloc->type);[0m
  195|      0|[0;41m        assert(false);[0m
  196|      0|[0;41m      }[0m
  197|  23.8k|      }
  198|  23.8k|    }
  199|  99.3k|  }
  200|  7.20k|}
  201|       |//
  202|       |// Currently functions aren't GC'd.
  203|     82|static void trace_roots() {
  204|       |  // printf("Scan symbols from readbc...%li\n", symbols.size());
  205|  [0;35m3.34k[0m|  for (uint64_t i = 0; i < arrlen(symbols); i++) {
  206|  3.26k|    visit(&symbols[i]);
  207|  3.26k|  }
  208|       |
  209|       |  // printf("Scan GC pushed roots...%li\n", pushed_roots.size()) ;
  210|     [0;35m82[0m|  for (uint64_t i = 0; i < arrlen(pushed_roots); [0;41mi++[0m) [0;41m{[0m
  211|      0|[0;41m    visit(pushed_roots[i]);[0m
  212|      0|[0;41m  }[0m
  213|       |
  214|       |  // printf("Scan stack...%u\n", stacksz);
  215|  [0;35m8.20G[0m|  for (size_t i = 0; i < stacksz; i++) {
  216|  [0;35m8.20G[0m|    if (stack[i] != 0) {
  217|  98.6k|      visit(&stack[i]);
  218|  98.6k|    }
  219|  8.20G|  }
  220|       |  // printf("Scan constant table... %li\n", const_table_sz);
  221|  [0;35m61.8k[0m|  for (size_t i = 0; i < const_table_sz; i++) {
  222|  [0;35m61.7k[0m|    if (const_table[i] != 0) {
  223|  61.7k|      visit(&const_table[i]);
  224|  61.7k|    }
  225|  61.7k|  }
  226|       |  // printf("Scan symbol table...\n");
  227|   [0;35m196k[0m|  for (size_t i = 0; i < sym_table->sz; i++) {
  228|   196k|    auto cur = &sym_table->entries[i];
  229|   [0;35m196k[0m|    if (*cur != NULL && *cur != TOMBSTONE) {
  230|  75.6k|      auto *tmp = (long *)&sym_table->entries[i];
  231|  75.6k|      *tmp += SYMBOL_TAG;
  232|  75.6k|      visit(tmp);
  233|  75.6k|      *tmp -= SYMBOL_TAG;
  234|  75.6k|    }
  235|   196k|  }
  236|       |
  237|       |// Scan traces
  238|     82|#ifdef JIT
  239|  [0;35m7.28k[0m|  for (uint64_t i = 0; i < arrlen(traces); i++) {
  240|  7.20k|    auto *t = traces[i];
  241|       |    // printf("Visit trace %i\n", cnt++);
  242|  7.20k|    visit_trace(t);
  243|  7.20k|  }
  244|       |  // Scan currently in-progress trace
  245|     [0;35m82[0m|  if (trace != NULL) [0;41m{[0m
  246|       |[0;41m[0m    // printf("Visit in progress trace\n");[0;41m[0m
  247|      0|[0;41m    visit_trace(trace);[0m
  248|      0|[0;41m  }[0m
  249|     82|#endif
  250|     82|}
  251|       |
  252|       |// static constexpr size_t page_cnt = 6000; // Approx 25 mb.
  253|       |// static constexpr size_t page_cnt = '12000; // Approx 50 mb.
  254|       |// static constexpr size_t page_cnt = 30000; // Approx 125 mb.
  255|       |// static constexpr size_t page_cnt = 120000; // Approx 500 mb.
  256|       |// size_t page_cnt = 500000; // Approx 2GB
  257|       |extern size_t page_cnt;
  258|       |size_t alloc_sz;
  259|       |uint8_t *to_space = NULL;
  260|       |uint8_t *from_space = NULL;
  261|       |static bool embiggen = false;
  262|       |
  263|     56|EXPORT void GC_init() {
  264|     56|  alloc_sz = 4096 * page_cnt;
  265|     56|  from_space = (uint8_t *)mmap(NULL, alloc_sz * 2, PROT_READ | PROT_WRITE,
  266|     56|                               MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  267|     56|  assert(from_space);
  268|     56|  alloc_ptr = from_space;
  269|     56|  alloc_end = alloc_ptr + alloc_sz;
  270|     56|  to_space = alloc_ptr + alloc_sz;
  271|     56|#ifndef NDEBUG
  272|     56|  mprotect(to_space, alloc_sz, PROT_NONE);
  273|     56|#endif
  274|     56|}
  275|       |
  276|       |#ifdef PROFILER
  277|       |bool in_gc = false;
  278|       |#endif
  279|     82|__attribute__((noinline)) void *GC_malloc_slow(size_t sz) {
  280|     82|  void *res;
  281|     82|#ifdef PROFILER
  282|     82|  in_gc = true;
  283|     82|#endif
  284|       |
  285|       |  // Slowpath.
  286|     [0;35m82[0m|  if (sz >= alloc_sz) [0;41m{[0m
  287|      0|[0;41m    embiggen = true;[0m
  288|      0|[0;41m  }[0m
  289|       |  // printf("Collecting...\n");
  290|       |
  291|     82|  assert(gc_enable || alloc_end == NULL);
  292|     82|#ifndef NDEBUG
  293|     82|  mprotect(to_space, alloc_sz, PROT_READ | PROT_WRITE);
  294|     82|#endif
  295|       |  // flip
  296|       |  // alloc_ptr = (uint8_t*)malloc(alloc_sz);
  297|     82|  void* to_unmap = NULL;
  298|     [0;35m82[0m|  if (embiggen) [0;41m{[0m
  299|      [0;35m0[0m|[0;41m    to_unmap = [0m[0;41mfrom_space < to_space[0m[0;41m ? [0m[0;41mfrom_space[0m[0;41m : [0m[0;41mto_space[0m[0;41m;[0m
  300|      0|[0;41m    alloc_sz *= 2;[0m
  301|      [0;35m0[0m|[0;41m    if ([0m[0;41mverbose[0m[0;41m) [0m[0;41m{[0m
  302|      0|[0;41m      printf("Doubling space to %liMB\n", alloc_sz/1000000);[0m
  303|      0|[0;41m    }[0m[0;41m[0m
  304|      0|[0;41m    from_space = (uint8_t *)mmap(NULL, alloc_sz * 2, PROT_READ | PROT_WRITE,[0m
  305|      0|[0;41m				 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);[0m
  306|      0|[0;41m    assert(from_space);[0m
  307|      0|[0;41m    [0m[0;41malloc_ptr = from_space;[0m
  308|      0|[0;41m    to_space = alloc_ptr + alloc_sz;[0m
  309|     82|[0;41m  }[0m else {
  310|     82|    alloc_ptr = to_space;
  311|     82|    to_space = from_space;
  312|     82|    from_space = alloc_ptr;
  313|     82|  }
  314|       |
  315|     82|  alloc_end = alloc_ptr + alloc_sz;
  316|       |
  317|     82|  auto *scan = alloc_ptr;
  318|     82|  trace_roots();
  319|       |  // printf("Cheney scan... %p %p\n", scan, alloc_ptr);
  320|  [0;35m69.3M[0m|  while (scan < alloc_ptr) {
  321|  69.3M|    auto scan_sz = heap_object_size((long *)scan);
  322|  69.3M|    trace_heap_object((long *)scan);
  323|  69.3M|    scan += align(scan_sz);
  324|  69.3M|  }
  325|     [0;35m82[0m|  if (verbose) [0;41m{[0m
  326|      0|[0;41m    printf("...Done collect, in use %li, %.2f%% of %liMB\n",[0m
  327|      0|[0;41m           alloc_ptr - from_space,[0m
  328|      0|[0;41m           ((double)(alloc_ptr - from_space)) / (double)alloc_sz * 100.0,[0m
  329|      0|[0;41m           alloc_sz / 1000 / 1000);[0m
  330|      0|[0;41m  }[0m
  331|     [0;35m82[0m|  if (!to_unmap && (alloc_ptr - from_space) >= (alloc_sz / 2)) [0;41m{[0m
  332|       |[0;41m[0m    // Next round, mmap a new space.[0;41m[0m
  333|      0|[0;41m    embiggen = true;[0m
  334|      0|[0;41m  }[0m
  335|       |
  336|     [0;35m82[0m|  if (to_unmap) [0;41m{[0m
  337|      0|[0;41m    embiggen = false;[0m
  338|      0|[0;41m    [0m[0;41mauto[0m[0;41m r = munmap(to_unmap, alloc_sz / 2);[0m
  339|      [0;35m0[0m|[0;41m    if ([0m[0;41mr[0m[0;41m) [0m[0;41m{[0m
  340|      0|[0;41m      printf("Unmap error\n");[0m
  341|      0|[0;41m    }[0m[0;41m[0m
  342|      0|[0;41m  }[0m
  343|       |
  344|     82|  res = alloc_ptr;
  345|     82|  alloc_ptr += sz;
  346|     [0;35m82[0m|  if (alloc_ptr >= alloc_end) [0;41m{[0m
  347|      0|[0;41m    embiggen = true;[0m
  348|      0|[0;41m    return GC_malloc_slow(sz);[0m
  349|      0|[0;41m  }[0m
  350|     82|#ifndef NDEBUG
  351|     82|  mprotect(to_space, alloc_sz, PROT_NONE);
  352|     82|#endif
  353|       |
  354|     82|#ifdef PROFILER
  355|     82|  in_gc = false;
  356|     82|#endif
  357|       |
  358|     82|  return res;
  359|     82|}
  360|       |
  361|  79.4M|__attribute__((always_inline)) void *GC_malloc_no_collect(size_t sz) {
  362|  79.4M|  sz = (sz + 7) & (~TAG_MASK);
  363|  79.4M|  assert((sz & TAG_MASK) == 0);
  364|  [0;35m79.4M[0m|  auto *res = alloc_ptr;
  365|  79.4M|  alloc_ptr += sz;
  366|  [0;35m79.4M[0m|  if (alloc_ptr < alloc_end) {
  367|  79.4M|    return res;
  368|  79.4M|  }
  369|     26|  return NULL;
  370|  79.4M|}
  371|  4.56G|__attribute__((always_inline)) void *GC_malloc(size_t sz) {
  372|  4.56G|  sz = (sz + 7) & (~TAG_MASK);
  373|  4.56G|  assert((sz & TAG_MASK) == 0);
  374|  [0;35m4.56G[0m|  auto *res = alloc_ptr;
  375|  4.56G|  alloc_ptr += sz;
  376|  [0;35m4.56G[0m|  if (alloc_ptr < alloc_end) {
  377|  4.56G|    return res;
  378|  4.56G|  }
  379|     82|  return GC_malloc_slow(sz);
  380|  4.56G|}
  381|       |
  382|      0|void *GC_realloc(void *ptr, size_t sz) [0;41m{[0m
  383|       |[0;41m[0m  // TODO zero-mem[0;41m[0m
  384|      0|[0;41m  return realloc(ptr, sz);[0m
  385|      0|[0;41m}[0m
  386|       |
  387|      0|void GC_free(void *ptr) [0;41m{ free(ptr); }[0m

[0;36m/home/davejwatson/myprojects/boom/ir.c:
[0m    1|       |#include "ir.h"
    2|       |#include "asm_x64.h"
    3|       |#include "third-party/stb_ds.h"
    4|       |#include <stdint.h>
    5|       |
    6|       |// clang-format off
    7|       |const char* ir_names[] = {
    8|       |  "LT    ",
    9|       |  "GE    ",
   10|       |  "LE    ",
   11|       |  "GT    ",
   12|       |
   13|       |  "EQ    ",
   14|       |  "NE    ",
   15|       |  "NOP   ",
   16|       |  "KFIX  ",
   17|       |  "KFUNC ",
   18|       |  "GGET  ",
   19|       |  "GSET  ",
   20|       |  "RET   ",
   21|       |  "CALL  ",
   22|       |  "SLOAD ",
   23|       |  "ARG   ",
   24|       |
   25|       |  "ADD   ",
   26|       |  "SUB   ",
   27|       |  "MUL   ",
   28|       |  "DIV   ",
   29|       |  "REM   ",
   30|       |  "AND   ",
   31|       |
   32|       |  "SHR   ",
   33|       |
   34|       |  "LOOP  ",
   35|       |  "PHI   ",
   36|       |
   37|       |  "CAR   ",
   38|       |  "CDR   ",
   39|       |  "ALLOC ",
   40|       |  "REF   ",
   41|       |  "STRREF",
   42|       |  "VREF  ",
   43|       |  "STORE ",
   44|       |  "STRST ",
   45|       |  "LOAD  ",
   46|       |  "STRLD ",
   47|       |
   48|       |  "ABC   ",
   49|       |  "CALLXS",
   50|       |  "CARG  ",
   51|       |  "FLUSH ",
   52|       |  "CCRES ",
   53|       |
   54|       |  "CHGTYP",
   55|       |
   56|       |  "NONE  ",
   57|       |};
   58|       |// clang-format on
   59|       |
   60|       |uint32_t push_ir(trace_s *trace, ir_ins_op op, uint32_t op1, uint32_t op2,
   61|  1.18M|                 uint8_t type) {
   62|  1.18M|  ir_ins ir = {.op1 = op1,
   63|  1.18M|               .op2 = op2,
   64|  1.18M|               .type = type,
   65|  1.18M|               .op = op,
   66|  1.18M|               .reg = REG_NONE,
   67|  1.18M|               .slot = SLOT_NONE};
   68|  1.18M|  uint32_t res = arrlen(trace->ops);
   69|  1.18M|  arrput(trace->ops, ir);
   70|       |
   71|  1.18M|  return res;
   72|  1.18M|}

[0;36m/home/davejwatson/myprojects/boom/ir.h:
[0m    1|       |#pragma once
    2|       |
    3|       |#include <stdint.h>
    4|       |
    5|       |// clang-format off
    6|       |typedef enum {
    7|       |  IR_LT,
    8|       |  IR_GE,
    9|       |  IR_LE,
   10|       |  IR_GT,
   11|       |
   12|       |  IR_EQ,
   13|       |  IR_NE,
   14|       |  IR_NOP,
   15|       |  IR_KFIX,
   16|       |  IR_KFUNC,
   17|       |  IR_GGET,
   18|       |  IR_GSET,
   19|       |  IR_RET,
   20|       |  IR_CALL,
   21|       |  IR_SLOAD,
   22|       |  IR_ARG,
   23|       |
   24|       |  IR_ADD,
   25|       |  IR_SUB,
   26|       |  IR_MUL,
   27|       |  IR_DIV,
   28|       |  IR_REM,
   29|       |  IR_AND,
   30|       |
   31|       |  IR_SHR,
   32|       |
   33|       |  IR_LOOP,
   34|       |  IR_PHI,
   35|       |
   36|       |  IR_CAR,
   37|       |  IR_CDR,
   38|       |    
   39|       |  IR_ALLOC,
   40|       |  IR_REF,
   41|       |  IR_STRREF,
   42|       |  IR_VREF,
   43|       |  IR_STORE,
   44|       |  IR_STRST,
   45|       |  IR_LOAD,
   46|       |  IR_STRLD,
   47|       |
   48|       |  IR_ABC,
   49|       |
   50|       |  IR_CALLXS,
   51|       |  IR_CARG,
   52|       |  IR_FLUSH,
   53|       |  IR_CCRES,
   54|       |
   55|       |  IR_CHGTYPE,
   56|       |
   57|       |  IR_NONE,
   58|       |} ir_ins_op;
   59|       |
   60|       |extern const char *ir_names[];
   61|       |
   62|  5.11G|#define IR_CONST_BIAS 0x8000
   63|       |
   64|   945k|#define IR_INS_TYPE_GUARD 0x80
   65|       |// clang-format on
   66|       |
   67|       |typedef struct {
   68|       |  uint16_t op1;
   69|       |  uint16_t op2;
   70|       |  uint8_t type;
   71|       |  ir_ins_op op;
   72|       |  union {
   73|       |    uint16_t prev;
   74|       |    struct {
   75|       |      uint8_t reg;
   76|       |      uint8_t slot;
   77|       |    };
   78|       |  };
   79|       |} ir_ins;
   80|       |
   81|       |typedef struct snap_entry {
   82|       |  int16_t slot;
   83|       |  uint16_t val;
   84|       |} snap_entry_s;
   85|       |
   86|       |typedef struct {
   87|       |  uint32_t *pc;
   88|       |  uint16_t ir;
   89|       |  uint16_t offset;
   90|       |  uint8_t exits;
   91|       |  int link;
   92|       |  snap_entry_s *slots;
   93|       |  uint64_t patchpoint;
   94|       |  uint64_t depth;
   95|       |  long argcnt;
   96|       |} snap_s;
   97|       |
   98|       |typedef enum {
   99|       |  TRACE_RETURN,
  100|       |  TRACE_TAILREC,
  101|       |} trace_type_e;
  102|       |
  103|       |typedef enum {
  104|       |  RELOC_ABS,
  105|       |  RELOC_SYM_ABS,
  106|       |} reloc_type;
  107|       |
  108|       |typedef struct {
  109|       |  uint64_t offset;
  110|       |  long obj;
  111|       |  reloc_type type;
  112|       |} reloc;
  113|       |
  114|       |typedef long (*Func)(long **, unsigned int **);
  115|       |typedef struct {
  116|       |  ir_ins *ops;
  117|       |  long *consts;
  118|       |  reloc *relocs;
  119|       |  snap_s *snaps;
  120|       |  int link;
  121|       |  unsigned int startpc;
  122|       |  int num;
  123|       |  Func fn;
  124|       |} trace_s;
  125|       |
  126|  86.4k|#define UNROLL_LIMIT 1
  127|       |
  128|   [0;35m356k[0m|#define ir_is_const(op) (op & IR_CONST_BIAS)
  129|       |
  130|       |uint32_t push_ir(trace_s *trace, ir_ins_op op, uint32_t op1, uint32_t op2,
  131|       |                 uint8_t type);

[0;36m/home/davejwatson/myprojects/boom/jitdump.c:
[0m    1|       |#define _GNU_SOURCE
    2|       |
    3|       |#include "jitdump.h"
    4|       |#include "defs.h"
    5|       |#include <assert.h>   // for assert
    6|       |#include <elf.h>      // for (anonymous), Elf64_Shdr, Elf64...
    7|       |#include <fcntl.h>    // for open, O_CLOEXEC, O_CREAT, O_RDWR
    8|       |#include <stddef.h>   // for offsetof
    9|       |#include <stdint.h>   // for uint32_t, uint8_t, uint64_t
   10|       |#include <stdio.h>    // for sprintf, printf, fprintf, fclose
   11|       |#include <stdlib.h>   // for exit
   12|       |#include <string.h>   // for strlen, memcpy, memset
   13|       |#include <sys/mman.h> // for mmap, munmap, MAP_PRIVATE, PRO...
   14|       |#include <sys/stat.h> // for S_IRUSR, S_IWUSR
   15|       |#include <time.h>     // for clock_gettime, timespec, CLOCK...
   16|       |#include <unistd.h>   // for getpid, write, close, fsync
   17|       |
   18|       |static int jit_cnt = 0;
   19|       |
   20|       |/* Earlier perf_map tmp support - supplies names to jit regions */
   21|      0|void perf_map(uint64_t fn, uint64_t len, const char *name) [0;41m{[0m
   22|      0|[0;41m  char buf[256];[0m
   23|      0|[0;41m  sprintf(buf, "/tmp/perf-%i.map", getpid());[0m
   24|      0|[0;41m  __auto_type file = fopen(buf, "a");[0m
   25|      [0;35m0[0m|[0;41m  if ([0m[0;41mstrlen(name) != 0[0m[0;41m) [0m[0;41m{[0m
   26|      0|[0;41m    fprintf(file, "%lx %lx jit function %s %i\n", (uint64_t)fn, len, name, jit_cnt);[0m
   27|      0|[0;41m  }[0m[0;41m else [0m[0;41m{[0m
   28|      0|[0;41m    fprintf(file, "%lx %lx jit anon function %i\n", (uint64_t)fn, len, jit_cnt);[0m
   29|      0|[0;41m  }[0m[0;41m[0m
   30|      0|[0;41m  fclose(file);[0m
   31|      0|[0;41m}[0m
   32|       |
   33|       |void *mapaddr = NULL;
   34|       |int fd;
   35|       |/* Newer jit dump support.  Requires perf record -k 1, and then perf
   36|       |   inject, before perf report, but gives full asm listing */
   37|      0|void jit_dump(int len, uint64_t fn, const char *name) [0;41m{[0m
   38|      0|[0;41m  struct {[0m
   39|      0|[0;41m    uint32_t id;[0m
   40|      0|[0;41m    uint32_t total_size;[0m
   41|      0|[0;41m    uint64_t timestamp;[0m
   42|       |[0;41m[0m
   43|       |    // JIT_CODE_LOAD[0;41m[0m
   44|      0|[0;41m    uint32_t pid;[0m
   45|      0|[0;41m    uint32_t tid;[0m
   46|      0|[0;41m    uint64_t vma;[0m
   47|      0|[0;41m    uint64_t code_addr;[0m
   48|      0|[0;41m    uint64_t code_size;[0m
   49|      0|[0;41m    uint64_t code_index;[0m
   50|      0|[0;41m  } record;[0m
   51|      0|[0;41m  char funcname[256];[0m
   52|      0|[0;41m  sprintf(funcname, "Function_%s_%i", name, jit_cnt);[0m
   53|       |[0;41m[0m
   54|       |  // clock[0;41m[0m
   55|      0|[0;41m  struct timespec ts;[0m
   56|      0|[0;41m  int result = clock_gettime(CLOCK_MONOTONIC, &ts);[0m
   57|      [0;35m0[0m|[0;41m  if ([0m[0;41mresult[0m[0;41m) [0m[0;41m{[0m
   58|      0|[0;41m    printf("Error: clock_gettime: %i\n", result);[0m
   59|      0|[0;41m    exit(-1);[0m
   60|      0|[0;41m  }[0m[0;41m[0m
   61|      0|  [0;41mrecord.timestamp = ts.tv_sec * 1000000000ULL + ts.tv_nsec;[0m
   62|       |[0;41m[0m[0;41m[0m
   63|      0|[0;41m  record.id = 0; // JIT_CODE_LOAD[0m
   64|      0|[0;41m  record.total_size = sizeof(record) + len + strlen(funcname) + 1;[0m
   65|       |[0;41m[0m[0;41m[0m
   66|      0|[0;41m  record.pid = getpid();[0m
   67|      0|[0;41m  record.tid = gettid();[0m
   68|      0|[0;41m  record.vma = (uint64_t)fn;[0m
   69|      0|[0;41m  record.code_addr = (uint64_t)fn;[0m
   70|      0|[0;41m  record.code_size = len;[0m
   71|      0|[0;41m  record.code_index = jit_cnt;[0m
   72|       |[0;41m[0m[0;41m[0m
   73|      0|[0;41m  write(fd, &record, sizeof(record));[0m
   74|      0|[0;41m  write(fd, funcname, strlen(funcname) + 1);[0m
   75|      0|[0;41m  write(fd, (void *)fn, len);[0m
   76|      0|[0;41m}[0m
   77|       |
   78|       |struct {
   79|       |  uint32_t magic;
   80|       |  uint32_t version;
   81|       |  uint32_t total_size;
   82|       |  uint32_t elf_mach;
   83|       |  uint32_t pad1;
   84|       |  uint32_t pid;
   85|       |  uint64_t timestamp;
   86|       |  uint64_t flags;
   87|       |} header;
   88|       |
   89|      0|EXPORT void jit_dump_init() [0;41m{[0m
   90|      0|[0;41m  char buf[256];[0m
   91|       |[0;41m[0m[0;41m[0m
   92|      0|[0;41m  sprintf(buf, "jit-%i.dump", getpid());[0m
   93|      0|[0;41m  fd = open(buf, O_CREAT | O_TRUNC | O_RDWR | O_CLOEXEC, S_IRUSR | S_IWUSR);[0m
   94|      0|[0;41m  struct timespec ts;[0m
   95|      0|[0;41m  int result = clock_gettime(CLOCK_MONOTONIC, &ts);[0m
   96|      [0;35m0[0m|[0;41m  if ([0m[0;41mresult[0m[0;41m) [0m[0;41m{[0m
   97|      0|[0;41m    printf("Error: clock_gettime: %i\n", result);[0m
   98|      0|[0;41m    exit(-1);[0m
   99|      0|[0;41m  }[0m[0;41m[0m
  100|      0|  [0;41mheader.timestamp = ts.tv_sec * 1000000000ULL + ts.tv_nsec;[0m
  101|       |[0;41m[0m[0;41m[0m
  102|      0|[0;41m  header.magic = 0x4A695444;[0m
  103|      0|[0;41m  header.version = 1;[0m
  104|      0|[0;41m  header.total_size = sizeof(header);[0m
  105|      0|[0;41m  header.elf_mach = EM_X86_64;[0m
  106|      0|[0;41m  header.pad1 = 0;[0m
  107|      0|[0;41m  header.pid = getpid();[0m
  108|      0|[0;41m  header.flags = 0;[0m
  109|      0|[0;41m  write(fd, &header, sizeof(header));[0m
  110|      0|[0;41m  fsync(fd);[0m
  111|       |[0;41m[0m[0;41m[0m
  112|      0|[0;41m  mapaddr =[0m
  113|      0|[0;41m      mmap(NULL, sizeof(header), PROT_READ | PROT_EXEC, MAP_PRIVATE, fd, 0);[0m
  114|      [0;35m0[0m|[0;41m  if ([0m[0;41m!mapaddr[0m[0;41m) [0m[0;41m{[0m
  115|      0|[0;41m    printf("Failed to map file\n");[0m
  116|      0|[0;41m    exit(-1);[0m
  117|      0|[0;41m  }[0m[0;41m[0m
  118|      0|[0;41m}[0m
  119|       |
  120|      0|EXPORT void jit_dump_close() [0;41m{[0m
  121|      [0;35m0[0m|[0;41m  if ([0m[0;41mmapaddr[0m[0;41m) [0m[0;41m{[0m
  122|      0|[0;41m    munmap(mapaddr, sizeof(header));[0m
  123|      0|[0;41m    close(fd);[0m
  124|      0|[0;41m  }[0m[0;41m[0m
  125|      0|[0;41m}[0m
  126|       |
  127|       |/// GDB jit-reader interface
  128|       |
  129|       |#include "third-party/jit-protocol.h"
  130|       |
  131|       |struct jit_code_entry *last_entry = NULL;
  132|       |struct jit_code_entry *first_entry = NULL;
  133|       |
  134|       |typedef struct GDBElfImage {
  135|       |  Elf64_Ehdr hdr;
  136|       |  Elf64_Shdr hdrs[6];
  137|       |  Elf64_Sym syms[3];
  138|       |  uint8_t data[4096];
  139|       |} GDBElfImage;
  140|       |
  141|       |void build_elf(uint64_t code, int code_sz, GDBElfImage *image, int num);
  142|      0|void jit_reader_add(int len, uint64_t fn, int i, uint64_t p, const char *name) [0;41m{[0m
  143|      0|[0;41m  struct jit_code_entry *jitcode = malloc(sizeof(struct jit_code_entry));[0m
  144|      0|[0;41m  GDBElfImage *image = malloc(sizeof(GDBElfImage));[0m
  145|      0|[0;41m  build_elf(fn, len, image, jit_cnt);[0m
  146|       |[0;41m[0m
  147|       |  // __auto_type entry = new gdb_code_entry;
  148|       |  //  entry->fn = fn;
  149|       |  //  entry->len = len;
  150|       |  // sprintf(entry->funcname, "Function_%s_%i_%i_%lx", name.c_str(), jit_cnt, i, p);[0;41m[0m
  151|      0|[0;41m  jitcode->symfile_addr = image;[0m
  152|      0|[0;41m  jitcode->symfile_size = sizeof(GDBElfImage);[0m
  153|      0|[0;41m  jitcode->next_entry = NULL;[0m
  154|      [0;35m0[0m|[0;41m  if ([0m[0;41m!first_entry[0m[0;41m) [0m[0;41m{[0m
  155|      0|[0;41m    first_entry = jitcode;[0m
  156|      0|[0;41m    last_entry = jitcode;[0m
  157|      0|[0;41m    jitcode->prev_entry = NULL;[0m
  158|      0|[0;41m  }[0m[0;41m else [0m[0;41m{[0m
  159|      0|[0;41m    jitcode->prev_entry = last_entry;[0m
  160|      0|[0;41m    last_entry->next_entry = jitcode;[0m
  161|      0|[0;41m    last_entry = jitcode;[0m
  162|      0|[0;41m  }[0m[0;41m[0m
  163|       |[0;41m[0m[0;41m[0m
  164|      0|[0;41m  __jit_debug_descriptor.first_entry = first_entry;[0m
  165|      0|[0;41m  __jit_debug_descriptor.relevant_entry = jitcode;[0m
  166|      0|[0;41m  __jit_debug_descriptor.action_flag = JIT_REGISTER;[0m
  167|      0|[0;41m  __jit_debug_descriptor.version = 1;[0m
  168|      0|[0;41m  __jit_debug_register_code();[0m
  169|      0|[0;41m  jit_cnt++;[0m
  170|      0|[0;41m}[0m
  171|       |
  172|       |////////////// GDB elf entry ///////////////
  173|       |
  174|       |// Sections text, strtab, symtab, debug info, debug_abbrev, debug_line,
  175|       |// debug_str (only nash), shstrtab, eh_frame (only lj) symbols file, func
  176|       |
  177|      0|long write_buf(long *offset, uint8_t *data, void *obj, long len) [0;41m{[0m
  178|      0|[0;41m  __auto_type start_offset = *offset;[0m
  179|      0|[0;41m  assert(*offset + len < 4096)[0m[0;41m;[0m
  180|      0|  [0;41mmemcpy(&data[*offset], obj, len);[0m
  181|      0|[0;41m  *offset += len;[0m
  182|      0|[0;41m  return start_offset[0m[0;41m;[0m
  183|      0|[0;41m}[0m
  184|       |
  185|      0|long write_strz(long *offset, uint8_t *data, const char *obj) [0;41m{[0m
  186|      0|[0;41m  __auto_type len = strlen(obj) + 1; // null terminated[0m
  187|      0|[0;41m  return write_buf(offset, data, (void *)obj, (long)len);[0m
  188|      0|[0;41m}[0m
  189|       |
  190|       |#define DW_CIE_VERSION 1
  191|       |enum {
  192|       |  /* Yes, the order is strange, but correct. */
  193|       |  DW_REG_AX,
  194|       |  DW_REG_DX,
  195|       |  DW_REG_CX,
  196|       |  DW_REG_BX,
  197|       |  DW_REG_SI,
  198|       |  DW_REG_DI,
  199|       |  DW_REG_BP,
  200|       |  DW_REG_SP,
  201|       |  DW_REG_8,
  202|       |  DW_REG_9,
  203|       |  DW_REG_10,
  204|       |  DW_REG_11,
  205|       |  DW_REG_12,
  206|       |  DW_REG_13,
  207|       |  DW_REG_14,
  208|       |  DW_REG_15,
  209|       |  DW_REG_RA,
  210|       |};
  211|       |enum { DW_EH_PE_udata4 = 3, DW_EH_PE_textrel = 0x20 };
  212|       |enum {
  213|       |  DW_CFA_nop = 0x0,
  214|       |  DW_CFA_offset_extended = 0x5,
  215|       |  DW_CFA_def_cfa = 0xc,
  216|       |  DW_CFA_def_cfa_register = 0xd,
  217|       |  DW_CFA_def_cfa_offset = 0xe,
  218|       |  DW_CFA_offset_extended_sf = 0x11,
  219|       |  DW_CFA_advance_loc = 0x40,
  220|       |  DW_CFA_offset = 0x80
  221|       |};
  222|       |
  223|      0|void uleb128(long *offset, uint8_t *buffer, uint32_t v) [0;41m{[0m
  224|      [0;35m0[0m|[0;41m  for (; [0m[0;41mv >= 0x80[0m[0;41m; [0m[0;41mv >>= 7[0m[0;41m) [0m[0;41m{[0m
  225|      0|[0;41m    buffer[(*offset)++] = (uint8_t)((v & 0x7f) | 0x80);[0m
  226|      0|[0;41m  }[0m[0;41m[0m
  227|      0|[0;41m  buffer[(*offset)++] = (uint8_t)v;[0m
  228|      0|[0;41m}[0m
  229|       |
  230|      0|void sleb128(long *offset, uint8_t *buffer, uint32_t v) [0;41m{[0m
  231|      [0;35m0[0m|[0;41m  for (; [0m[0;41m(uint32_t)(v + 0x40) >= 0x80[0m[0;41m; [0m[0;41mv >>= 7[0m[0;41m) [0m[0;41m{[0m
  232|      0|[0;41m    buffer[(*offset)++] = (uint8_t)((v & 0x7f) | 0x80);[0m
  233|      0|[0;41m  }[0m[0;41m[0m
  234|      0|[0;41m  buffer[(*offset)++] = (uint8_t)(v & 0x7f);[0m
  235|      0|[0;41m}[0m
  236|       |
  237|      0|void build_elf(uint64_t code, int code_sz, GDBElfImage *image, int num) [0;41m{[0m
  238|      0|[0;41m  memset(image, 0, sizeof(GDBElfImage));[0m
  239|       |[0;41m[0m[0;41m[0m
  240|      0|[0;41m  long offset = 0;[0m
  241|       |[0;41m[0m[0;41m[0m
  242|      0|[0;41m  Elf64_Ehdr hdr = {[0m
  243|      0|[0;41m      .e_ident = {ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3, ELFCLASS64, ELFDATA2LSB,[0m
  244|      0|[0;41m                  1 /*version */, ELFOSABI_SYSV, 0 /* ABI VERSION */, 0, 0, 0,[0m
  245|      0|[0;41m                  0, 0, 0, 0},[0m
  246|      0|[0;41m      .e_type = ET_REL,[0m
  247|      0|[0;41m      .e_machine = EM_X86_64,[0m
  248|      0|[0;41m      .e_version = EV_CURRENT,[0m
  249|      0|[0;41m      .e_entry = 0,[0m
  250|      0|[0;41m      .e_phoff = 0,[0m
  251|      0|[0;41m      .e_shoff = sizeof(Elf64_Ehdr),[0m
  252|      0|[0;41m      .e_flags = 0,[0m
  253|      0|[0;41m      .e_ehsize = sizeof(Elf64_Ehdr),[0m
  254|      0|[0;41m      .e_phentsize = 0,[0m
  255|      0|[0;41m      .e_phnum = 0,[0m
  256|      0|[0;41m      .e_shentsize = sizeof(Elf64_Shdr),[0m
  257|      0|[0;41m      .e_shnum = 6,[0m
  258|      0|[0;41m      .e_shstrndx = 1,[0m
  259|      0|[0;41m  };[0m
  260|      0|[0;41m  image->hdr = hdr;[0m
  261|      0|[0;41m  offset += sizeof(image->hdr);[0m
  262|       |[0;41m[0m[0;41m[0m
  263|      0|[0;41m  __auto_type shstrtab_hdr = &image->hdrs[1];[0m
  264|      0|[0;41m  offset += sizeof(image->hdrs) + sizeof(image->syms);[0m
  265|       |[0;41m[0m[0;41m[0m
  266|      0|[0;41m  write_strz(&offset, image->data, "");[0m
  267|       |[0;41m[0m[0;41m[0m
  268|      0|[0;41m  shstrtab_hdr->sh_name = write_strz(&offset, image->data, ".shstrtab");[0m
  269|      0|[0;41m  shstrtab_hdr->sh_type = SHT_STRTAB;[0m
  270|      0|[0;41m  shstrtab_hdr->sh_addralign = 1;[0m
  271|      0|[0;41m  shstrtab_hdr->sh_offset = offsetof(GDBElfImage, data);[0m
  272|       |[0;41m[0m[0;41m[0m
  273|      0|[0;41m  __auto_type text_hdr = &image->hdrs[2];[0m
  274|      0|[0;41m  text_hdr->sh_name = write_strz(&offset, image->data, ".text");[0m
  275|      0|[0;41m  text_hdr->sh_flags = SHF_ALLOC | SHF_EXECINSTR;[0m
  276|      0|[0;41m  text_hdr->sh_addr = code;[0m
  277|      0|[0;41m  text_hdr->sh_size = code_sz;[0m
  278|      0|[0;41m  text_hdr->sh_offset = 0;[0m
  279|      0|[0;41m  text_hdr->sh_type = SHT_NOBITS;[0m
  280|      0|[0;41m  text_hdr->sh_addralign = 16;[0m
  281|       |[0;41m[0m[0;41m[0m
  282|      0|[0;41m  __auto_type str_hdr = &image->hdrs[3];[0m
  283|      0|[0;41m  str_hdr->sh_name = write_strz(&offset, image->data, ".strtab");[0m
  284|      0|[0;41m  str_hdr->sh_type = SHT_STRTAB;[0m
  285|      0|[0;41m  str_hdr->sh_addralign = 1;[0m
  286|       |[0;41m[0m[0;41m[0m
  287|      0|[0;41m  __auto_type sym_hdr = &image->hdrs[4];[0m
  288|      0|[0;41m  sym_hdr->sh_name = write_strz(&offset, image->data, ".symtab");[0m
  289|      0|[0;41m  sym_hdr->sh_type = SHT_SYMTAB;[0m
  290|      0|[0;41m  sym_hdr->sh_addralign = sizeof(void *);[0m
  291|      0|[0;41m  sym_hdr->sh_offset = offsetof(GDBElfImage, syms);[0m
  292|      0|[0;41m  sym_hdr->sh_size = sizeof(Elf64_Sym) * 3;[0m
  293|      0|[0;41m  sym_hdr->sh_link = 3; // link to strtab[0m
  294|      0|[0;41m  sym_hdr->sh_entsize = sizeof(Elf64_Sym);[0m
  295|      0|[0;41m  sym_hdr->sh_info = 2; // sym_func[0m
  296|       |[0;41m[0m[0;41m[0m
  297|      0|[0;41m  __auto_type ehframe_hdr = &image->hdrs[5];[0m
  298|      0|[0;41m  ehframe_hdr->sh_name = write_strz(&offset, image->data, ".eh_frame");[0m
  299|      0|[0;41m  ehframe_hdr->sh_type = SHT_PROGBITS;[0m
  300|      0|[0;41m  ehframe_hdr->sh_addralign = 1;[0m
  301|      0|[0;41m  ehframe_hdr->sh_flags = SHF_ALLOC;[0m
  302|       |[0;41m[0m[0;41m[0m
  303|      0|[0;41m  shstrtab_hdr->sh_size = offset;[0m
  304|       |[0;41m[0m
  305|       |  // Write symbols[0;41m[0m
  306|      0|[0;41m  __auto_type start_offset = offset;[0m
  307|      0|[0;41m  str_hdr->sh_offset = offsetof(GDBElfImage, data) + start_offset;[0m
  308|      0|[0;41m  __auto_type st = offset;[0m
  309|      0|[0;41m  write_strz(&offset, image->data, "");[0m
  310|       |[0;41m[0m  // Emit the symbols[0;41m[0m
  311|      0|[0;41m  __auto_type filesym = &image->syms[1];[0m
  312|      0|[0;41m  filesym->st_name = write_strz(&offset, image->data, "JIT") - st;[0m
  313|      0|[0;41m  filesym->st_shndx = SHN_ABS;[0m
  314|      0|[0;41m  filesym->st_info = STT_FILE;[0m
  315|      0|[0;41m  __auto_type funcsym = &image->syms[2];[0m
  316|      0|[0;41m  char tmp[244];[0m
  317|      0|[0;41m  sprintf(tmp, "TRACE_%i", num);[0m
  318|      0|[0;41m  funcsym->st_name = write_strz(&offset, image->data, tmp) - st;[0m
  319|      0|[0;41m  funcsym->st_shndx = 2; // text[0m
  320|      0|[0;41m  funcsym->st_info = ELF64_ST_INFO(STB_GLOBAL, STT_FUNC);[0m
  321|      0|[0;41m  funcsym->st_value = 0;[0m
  322|      0|[0;41m  funcsym->st_size = code_sz;[0m
  323|       |[0;41m[0m[0;41m[0m
  324|      0|[0;41m  str_hdr->sh_size = offset - start_offset;[0m
  325|       |[0;41m[0m
  326|       |  // write ehframe[0;41m[0m
  327|      0|[0;41m  start_offset = offset;[0m
  328|       |[0;41m[0m  // TODO align 8[0;41m[0m
  329|      0|[0;41m  __auto_type buffer = &image->data[0];[0m
  330|      0|[0;41m  ehframe_hdr->sh_offset = offsetof(GDBElfImage, data) + start_offset;[0m
  331|       |[0;41m[0m//   //////////////////////[0;41m[0m
  332|      0|[0;41m#define DB(x) (buffer[offset] = (x), offset++)[0m
  333|      0|[0;41m#define DU16(x) (*(uint16_t *)&buffer[offset] = (x), offset += 2)[0m
  334|      0|[0;41m#define DU32(x) (*(uint32_t *)&buffer[offset] = (x), offset += 4)[0m
  335|      0|[0;41m#define DUV(x) (uleb128(&offset, buffer, (x)))[0m
  336|      0|[0;41m#define DSV(x) (sleb128(&offset, buffer, (x)))[0m
  337|      0|[0;41m#define DSTR(str) (write_strz(&offset, (uint8_t *)buffer, (str)))[0m
  338|      0|[0;41m#define DALIGNNOP(s)                                                           \[0m
  339|      0|[0;41m  while ((uintptr_t)offset & ((s)-1))                                          \[0m
  340|      0|[0;41m  buffer[offset++] = DW_CFA_nop[0m
  341|      0|[0;41m#define DSECT(name, stmt)                                                      \[0m
  342|      0|[0;41m  [0m[0;41m{                                                                            \[0m
  343|      0|[0;41m    uint32_t *szp_##name = (uint32_t *)&buffer[offset];                        \[0m
  344|      0|[0;41m    offset += 4;                                                               \[0m
  345|      0|[0;41m    [0m[0;41mstmt[0m[0;41m *szp_##name =                                                         \[0m
  346|      0|[0;41m        (uint32_t)((&buffer[offset] - (uint8_t *)szp_##name) - 4);             \[0m
  347|      0|[0;41m  }[0m
  348|       |[0;41m[0m
  349|       |  //   /* Emit DWARF EH CIE. */[0;41m[0m
  350|      0|[0;41m  long cie_offset = offset;[0m
  351|      0|[0;41m  [0m[0;41mDSECT[0m[0;41m(CIE, DU32(0);                     /* Offset to CIE itself. */[0m
  352|      0|[0;41m        DB(DW_CIE_VERSION); DSTR("zR");   /* Augmentation. */[0m
  353|      0|[0;41m        DUV(1);                           /* Code alignment factor. */[0m
  354|      0|[0;41m        DSV(-(int32_t)sizeof(uintptr_t)); /* Data alignment factor. */[0m
  355|      0|[0;41m        DB(DW_REG_RA);                    /* Return address register. */[0m
  356|      0|[0;41m        DB(1); DB(DW_EH_PE_textrel | DW_EH_PE_udata4); /* Augmentation data. */[0m
  357|      0|[0;41m        DB(DW_CFA_def_cfa); DUV(DW_REG_SP); DUV(sizeof(uintptr_t));[0m
  358|      0|[0;41m        DB(DW_CFA_offset | DW_REG_RA); DUV(1); DALIGNNOP(sizeof(uintptr_t));)[0m
  359|       |[0;41m[0m
  360|       |  //   /* Emit DWARF EH FDE. */[0;41m[0m
  361|      0|[0;41m  [0m[0;41mDSECT[0m[0;41m(FDE, DU32((uint32_t)(offset - cie_offset)); /* Offset to CIE. */[0m
  362|      0|[0;41m        DU32(0);    /* Machine code offset relative to .text. */[0m
  363|      0|[0;41m        DU32(code); /* Machine code length. */[0m
  364|      0|[0;41m        DB(0);      /* Augmentation data. */[0m
  365|       |[0;41m[0m        /* Registers saved in CFRAME. */
  366|       |[0;41m[0m
  367|      0|[0;41m        DB(DW_CFA_def_cfa_offset); DUV(16); DB(DW_CFA_offset | DW_REG_BP);[0m
  368|      0|[0;41m        DUV(2); DB(DW_CFA_def_cfa_register); DUV(DW_REG_BP);[0m
  369|      0|[0;41m        DALIGNNOP(sizeof(uintptr_t));)[0m
  370|       |[0;41m[0m  ///////////[0;41m[0m
  371|      0|[0;41m  ehframe_hdr->sh_size = offset - start_offset;[0m
  372|       |[0;41m[0m
  373|       |  // Note this breaks perf record inject for some reason?
  374|       |  // fd = open("elfout", O_CREAT | O_TRUNC | O_RDWR | O_CLOEXEC, S_IRUSR |
  375|       |  // S_IWUSR); write(fd, image, sizeof(GDBElfImage)); close(fd);[0;41m[0m
  376|      0|[0;41m}[0m

[0;36m/home/davejwatson/myprojects/boom/lru.c:
[0m    1|       |#include <stdint.h>
    2|       |
    3|       |#include "lru.h"
    4|       |
    5|       |/// Dead-simple LRU cache, implemented as a doubly-linked list with a static
    6|       |/// backing array.
    7|       |///
    8|       |///              <-- prev next -->
    9|       |///      -------      -------      -------      --------
   10|       |///      |  a  | <--> |  b  | <--> |  c  | <--> | head | <--|
   11|       |///      -------      -------      -------      --------    |
   12|       |///         ^                       oldest       newest     |
   13|       |///         |-----------------------------------------------|
   14|       |
   15|  10.0k|void lru_init(lru *l) {
   16|  10.0k|  l->head = 0;
   17|  10.0k|  l->data[0].next = 1;
   18|  10.0k|  l->data[0].prev = LRU_SIZE - 1;
   19|   [0;35m160k[0m|  for (int16_t i = 1; i < LRU_SIZE; i++) {
   20|   150k|    l->data[i].next = (i + 1) % LRU_SIZE;
   21|   150k|    l->data[i].prev = i - 1;
   22|   150k|  }
   23|  10.0k|}
   24|       |
   25|   386k|void lru_remove(lru *l, uint8_t node) {
   26|       |  // Assumes size is always > 1
   27|   386k|  l->data[l->data[node].prev].next = l->data[node].next;
   28|   386k|  l->data[l->data[node].next].prev = l->data[node].prev;
   29|   386k|}
   30|       |
   31|   386k|void lru_insert_before(lru *l, uint8_t node, uint8_t next) {
   32|   386k|  uint8_t prev = l->data[next].prev;
   33|   386k|  l->data[prev].next = node;
   34|   386k|  l->data[next].prev = node;
   35|   386k|  l->data[node] = (lrunode){next, prev};
   36|   386k|}
   37|       |
   38|   526k|void lru_poke(lru *l, uint8_t node) {
   39|   526k|  uint8_t prev_newest = l->head;
   40|   [0;35m526k[0m|  if (node == prev_newest) {
   41|   135k|    return;
   42|   [0;35m391k[0m|  } else if (l->data[prev_newest].prev != node) {
   43|   386k|    lru_remove(l, node);
   44|   386k|    lru_insert_before(l, node, l->head);
   45|   386k|  }
   46|   391k|  l->head = node;
   47|   391k|}
   48|       |
   49|  3.66k|uint8_t lru_oldest(lru *l) {
   50|  3.66k|  uint8_t out = l->data[l->head].prev;
   51|  3.66k|  l->head = out;
   52|       |
   53|  3.66k|  return out;
   54|  3.66k|}
   55|       |
   56|       |#if 0
   57|       |#include <stdio.h>
   58|       |int main() {
   59|       |
   60|       |  lru l;
   61|       |  lru_init(&l);
   62|       |  printf("Oldest %i\n", lru_oldest(&l));
   63|       |  printf("Oldest %i\n", lru_oldest(&l));
   64|       |  lru_poke(&l, 3);
   65|       |  lru_poke(&l, 2);
   66|       |  lru_poke(&l, 3);
   67|       |  lru_poke(&l, 1);
   68|       |  lru_poke(&l, 1);
   69|       |  lru_poke(&l, 3);
   70|       |  lru_poke(&l, 0);
   71|       |  lru_poke(&l, 2);
   72|       |  printf("Oldest %i\n", lru_oldest(&l));
   73|       |  return 0;
   74|       |}
   75|       |#endif

[0;36m/home/davejwatson/myprojects/boom/lru.h:
[0m    1|       |#pragma once
    2|       |
    3|   320k|#define LRU_SIZE 16
    4|       |
    5|       |typedef struct {
    6|       |  uint8_t next;
    7|       |  uint8_t prev;
    8|       |} lrunode;
    9|       |
   10|       |typedef struct {
   11|       |  lrunode data[LRU_SIZE];
   12|       |  uint8_t head;
   13|       |} lru;
   14|       |
   15|       |
   16|       |void lru_init(lru *l);
   17|       |void lru_remove(lru *l, uint8_t node);
   18|       |void lru_insert_before(lru *l, uint8_t node, uint8_t next);
   19|       |void lru_poke(lru *l, uint8_t node);
   20|       |uint8_t lru_oldest(lru *l);

[0;36m/home/davejwatson/myprojects/boom/opcodes-table.h:
[0m    1|       |#ifdef PROFILER
    2|      0|void INS_PROFILE_ILOOP(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
    3|      0|[0;41mprofile_set_pc(pc);[0m
    4|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_ILOOP(ra, instr, pc, frame, op_table_arg, argcnt);[0m
    5|      0|[0;41m}[0m
    6|      0|void INS_PROFILE_LOOP(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
    7|      0|[0;41mprofile_set_pc(pc);[0m
    8|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_LOOP(ra, instr, pc, frame, op_table_arg, argcnt);[0m
    9|      0|[0;41m}[0m
   10|      0|void INS_PROFILE_IFUNC(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   11|      0|[0;41mprofile_set_pc(pc);[0m
   12|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_IFUNC(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   13|      0|[0;41m}[0m
   14|      0|void INS_PROFILE_FUNC(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   15|      0|[0;41mprofile_set_pc(pc);[0m
   16|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_FUNC(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   17|      0|[0;41m}[0m
   18|      0|void INS_PROFILE_IFUNCV(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   19|      0|[0;41mprofile_set_pc(pc);[0m
   20|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_IFUNCV(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   21|      0|[0;41m}[0m
   22|      0|void INS_PROFILE_FUNCV(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   23|      0|[0;41mprofile_set_pc(pc);[0m
   24|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_FUNCV(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   25|      0|[0;41m}[0m
   26|      0|void INS_PROFILE_ICLFUNC(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   27|      0|[0;41mprofile_set_pc(pc);[0m
   28|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_ICLFUNC(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   29|      0|[0;41m}[0m
   30|      0|void INS_PROFILE_CLFUNC(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   31|      0|[0;41mprofile_set_pc(pc);[0m
   32|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_CLFUNC(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   33|      0|[0;41m}[0m
   34|      0|void INS_PROFILE_ICLFUNCV(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   35|      0|[0;41mprofile_set_pc(pc);[0m
   36|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_ICLFUNCV(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   37|      0|[0;41m}[0m
   38|      0|void INS_PROFILE_CLFUNCV(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   39|      0|[0;41mprofile_set_pc(pc);[0m
   40|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_CLFUNCV(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   41|      0|[0;41m}[0m
   42|      0|void INS_PROFILE_KSHORT(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   43|      0|[0;41mprofile_set_pc(pc);[0m
   44|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_KSHORT(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   45|      0|[0;41m}[0m
   46|      0|void INS_PROFILE_JMP(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   47|      0|[0;41mprofile_set_pc(pc);[0m
   48|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_JMP(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   49|      0|[0;41m}[0m
   50|      0|void INS_PROFILE_IRET1(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   51|      0|[0;41mprofile_set_pc(pc);[0m
   52|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_IRET1(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   53|      0|[0;41m}[0m
   54|      0|void INS_PROFILE_RET1(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   55|      0|[0;41mprofile_set_pc(pc);[0m
   56|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_RET1(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   57|      0|[0;41m}[0m
   58|      0|void INS_PROFILE_HALT(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   59|      0|[0;41mprofile_set_pc(pc);[0m
   60|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_HALT(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   61|      0|[0;41m}[0m
   62|      0|void INS_PROFILE_SUBVN(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   63|      0|[0;41mprofile_set_pc(pc);[0m
   64|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_SUBVN(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   65|      0|[0;41m}[0m
   66|      0|void INS_PROFILE_ADDVN(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   67|      0|[0;41mprofile_set_pc(pc);[0m
   68|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_ADDVN(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   69|      0|[0;41m}[0m
   70|      0|void INS_PROFILE_ADDVV(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   71|      0|[0;41mprofile_set_pc(pc);[0m
   72|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_ADDVV(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   73|      0|[0;41m}[0m
   74|      0|void INS_PROFILE_SUBVV(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   75|      0|[0;41mprofile_set_pc(pc);[0m
   76|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_SUBVV(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   77|      0|[0;41m}[0m
   78|      0|void INS_PROFILE_MULVV(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   79|      0|[0;41mprofile_set_pc(pc);[0m
   80|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_MULVV(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   81|      0|[0;41m}[0m
   82|      0|void INS_PROFILE_DIV(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   83|      0|[0;41mprofile_set_pc(pc);[0m
   84|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_DIV(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   85|      0|[0;41m}[0m
   86|      0|void INS_PROFILE_REM(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   87|      0|[0;41mprofile_set_pc(pc);[0m
   88|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_REM(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   89|      0|[0;41m}[0m
   90|      0|void INS_PROFILE_EQ(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   91|      0|[0;41mprofile_set_pc(pc);[0m
   92|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_EQ(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   93|      0|[0;41m}[0m
   94|      0|void INS_PROFILE_JEQ(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   95|      0|[0;41mprofile_set_pc(pc);[0m
   96|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_JEQ(ra, instr, pc, frame, op_table_arg, argcnt);[0m
   97|      0|[0;41m}[0m
   98|      0|void INS_PROFILE_JNEQ(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
   99|      0|[0;41mprofile_set_pc(pc);[0m
  100|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_JNEQ(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  101|      0|[0;41m}[0m
  102|      0|void INS_PROFILE_JISLT(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  103|      0|[0;41mprofile_set_pc(pc);[0m
  104|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_JISLT(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  105|      0|[0;41m}[0m
  106|      0|void INS_PROFILE_JISEQ(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  107|      0|[0;41mprofile_set_pc(pc);[0m
  108|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_JISEQ(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  109|      0|[0;41m}[0m
  110|      0|void INS_PROFILE_JISNEQ(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  111|      0|[0;41mprofile_set_pc(pc);[0m
  112|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_JISNEQ(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  113|      0|[0;41m}[0m
  114|      0|void INS_PROFILE_JISLTE(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  115|      0|[0;41mprofile_set_pc(pc);[0m
  116|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_JISLTE(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  117|      0|[0;41m}[0m
  118|      0|void INS_PROFILE_JISGT(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  119|      0|[0;41mprofile_set_pc(pc);[0m
  120|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_JISGT(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  121|      0|[0;41m}[0m
  122|      0|void INS_PROFILE_JISGTE(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  123|      0|[0;41mprofile_set_pc(pc);[0m
  124|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_JISGTE(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  125|      0|[0;41m}[0m
  126|      0|void INS_PROFILE_ISLT(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  127|      0|[0;41mprofile_set_pc(pc);[0m
  128|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_ISLT(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  129|      0|[0;41m}[0m
  130|      0|void INS_PROFILE_ISGT(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  131|      0|[0;41mprofile_set_pc(pc);[0m
  132|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_ISGT(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  133|      0|[0;41m}[0m
  134|      0|void INS_PROFILE_ISLTE(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  135|      0|[0;41mprofile_set_pc(pc);[0m
  136|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_ISLTE(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  137|      0|[0;41m}[0m
  138|      0|void INS_PROFILE_ISGTE(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  139|      0|[0;41mprofile_set_pc(pc);[0m
  140|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_ISGTE(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  141|      0|[0;41m}[0m
  142|      0|void INS_PROFILE_ISEQ(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  143|      0|[0;41mprofile_set_pc(pc);[0m
  144|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_ISEQ(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  145|      0|[0;41m}[0m
  146|      0|void INS_PROFILE_JISF(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  147|      0|[0;41mprofile_set_pc(pc);[0m
  148|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_JISF(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  149|      0|[0;41m}[0m
  150|      0|void INS_PROFILE_JIST(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  151|      0|[0;41mprofile_set_pc(pc);[0m
  152|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_JIST(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  153|      0|[0;41m}[0m
  154|      0|void INS_PROFILE_GGET(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  155|      0|[0;41mprofile_set_pc(pc);[0m
  156|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_GGET(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  157|      0|[0;41m}[0m
  158|      0|void INS_PROFILE_GSET(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  159|      0|[0;41mprofile_set_pc(pc);[0m
  160|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_GSET(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  161|      0|[0;41m}[0m
  162|      0|void INS_PROFILE_KFUNC(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  163|      0|[0;41mprofile_set_pc(pc);[0m
  164|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_KFUNC(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  165|      0|[0;41m}[0m
  166|      0|void INS_PROFILE_KONST(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  167|      0|[0;41mprofile_set_pc(pc);[0m
  168|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_KONST(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  169|      0|[0;41m}[0m
  170|      0|void INS_PROFILE_MOV(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  171|      0|[0;41mprofile_set_pc(pc);[0m
  172|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_MOV(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  173|      0|[0;41m}[0m
  174|      0|void INS_PROFILE_BOX(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  175|      0|[0;41mprofile_set_pc(pc);[0m
  176|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_BOX(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  177|      0|[0;41m}[0m
  178|      0|void INS_PROFILE_UNBOX(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  179|      0|[0;41mprofile_set_pc(pc);[0m
  180|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_UNBOX(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  181|      0|[0;41m}[0m
  182|      0|void INS_PROFILE_SET_BOX(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  183|      0|[0;41mprofile_set_pc(pc);[0m
  184|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_SET_BOX(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  185|      0|[0;41m}[0m
  186|      0|void INS_PROFILE_GUARD(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  187|      0|[0;41mprofile_set_pc(pc);[0m
  188|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_GUARD(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  189|      0|[0;41m}[0m
  190|      0|void INS_PROFILE_JGUARD(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  191|      0|[0;41mprofile_set_pc(pc);[0m
  192|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_JGUARD(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  193|      0|[0;41m}[0m
  194|      0|void INS_PROFILE_JNGUARD(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  195|      0|[0;41mprofile_set_pc(pc);[0m
  196|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_JNGUARD(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  197|      0|[0;41m}[0m
  198|      0|void INS_PROFILE_VECTOR(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  199|      0|[0;41mprofile_set_pc(pc);[0m
  200|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_VECTOR(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  201|      0|[0;41m}[0m
  202|      0|void INS_PROFILE_CLOSURE(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  203|      0|[0;41mprofile_set_pc(pc);[0m
  204|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_CLOSURE(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  205|      0|[0;41m}[0m
  206|      0|void INS_PROFILE_CLOSURE_GET(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  207|      0|[0;41mprofile_set_pc(pc);[0m
  208|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_CLOSURE_GET(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  209|      0|[0;41m}[0m
  210|      0|void INS_PROFILE_CLOSURE_SET(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  211|      0|[0;41mprofile_set_pc(pc);[0m
  212|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_CLOSURE_SET(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  213|      0|[0;41m}[0m
  214|      0|void INS_PROFILE_CLOSURE_PTR(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  215|      0|[0;41mprofile_set_pc(pc);[0m
  216|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_CLOSURE_PTR(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  217|      0|[0;41m}[0m
  218|      0|void INS_PROFILE_APPLY(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  219|      0|[0;41mprofile_set_pc(pc);[0m
  220|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_APPLY(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  221|      0|[0;41m}[0m
  222|      0|void INS_PROFILE_JFUNC(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  223|      0|[0;41mprofile_set_pc(pc);[0m
  224|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_JFUNC(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  225|      0|[0;41m}[0m
  226|      0|void INS_PROFILE_JLOOP(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  227|      0|[0;41mprofile_set_pc(pc);[0m
  228|      [0;35m0[0m|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return [0m[0;41mINS_JLOOP[0m[0;41m(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  229|      0|[0;41m}[0m
  230|      0|void INS_PROFILE_CALL(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  231|      0|[0;41mprofile_set_pc(pc);[0m
  232|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_CALL(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  233|      0|[0;41m}[0m
  234|      0|void INS_PROFILE_CALLT(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  235|      0|[0;41mprofile_set_pc(pc);[0m
  236|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_CALLT(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  237|      0|[0;41m}[0m
  238|      0|void INS_PROFILE_EQV(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  239|      0|[0;41mprofile_set_pc(pc);[0m
  240|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_EQV(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  241|      0|[0;41m}[0m
  242|      0|void INS_PROFILE_JEQV(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  243|      0|[0;41mprofile_set_pc(pc);[0m
  244|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_JEQV(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  245|      0|[0;41m}[0m
  246|      0|void INS_PROFILE_JNEQV(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  247|      0|[0;41mprofile_set_pc(pc);[0m
  248|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_JNEQV(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  249|      0|[0;41m}[0m
  250|      0|void INS_PROFILE_CONS(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  251|      0|[0;41mprofile_set_pc(pc);[0m
  252|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_CONS(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  253|      0|[0;41m}[0m
  254|      0|void INS_PROFILE_CAR(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  255|      0|[0;41mprofile_set_pc(pc);[0m
  256|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_CAR(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  257|      0|[0;41m}[0m
  258|      0|void INS_PROFILE_CDR(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  259|      0|[0;41mprofile_set_pc(pc);[0m
  260|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_CDR(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  261|      0|[0;41m}[0m
  262|      0|void INS_PROFILE_MAKE_VECTOR(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  263|      0|[0;41mprofile_set_pc(pc);[0m
  264|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_MAKE_VECTOR(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  265|      0|[0;41m}[0m
  266|      0|void INS_PROFILE_MAKE_STRING(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  267|      0|[0;41mprofile_set_pc(pc);[0m
  268|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_MAKE_STRING(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  269|      0|[0;41m}[0m
  270|      0|void INS_PROFILE_VECTOR_REF(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  271|      0|[0;41mprofile_set_pc(pc);[0m
  272|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_VECTOR_REF(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  273|      0|[0;41m}[0m
  274|      0|void INS_PROFILE_STRING_REF(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  275|      0|[0;41mprofile_set_pc(pc);[0m
  276|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_STRING_REF(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  277|      0|[0;41m}[0m
  278|      0|void INS_PROFILE_VECTOR_LENGTH(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  279|      0|[0;41mprofile_set_pc(pc);[0m
  280|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_VECTOR_LENGTH(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  281|      0|[0;41m}[0m
  282|      0|void INS_PROFILE_STRING_LENGTH(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  283|      0|[0;41mprofile_set_pc(pc);[0m
  284|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_STRING_LENGTH(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  285|      0|[0;41m}[0m
  286|      0|void INS_PROFILE_VECTOR_SET(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  287|      0|[0;41mprofile_set_pc(pc);[0m
  288|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_VECTOR_SET(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  289|      0|[0;41m}[0m
  290|      0|void INS_PROFILE_STRING_SET(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  291|      0|[0;41mprofile_set_pc(pc);[0m
  292|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_STRING_SET(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  293|      0|[0;41m}[0m
  294|      0|void INS_PROFILE_SET_CAR(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  295|      0|[0;41mprofile_set_pc(pc);[0m
  296|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_SET_CAR(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  297|      0|[0;41m}[0m
  298|      0|void INS_PROFILE_SET_CDR(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  299|      0|[0;41mprofile_set_pc(pc);[0m
  300|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_SET_CDR(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  301|      0|[0;41m}[0m
  302|      0|void INS_PROFILE_WRITE(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  303|      0|[0;41mprofile_set_pc(pc);[0m
  304|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_WRITE(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  305|      0|[0;41m}[0m
  306|      0|void INS_PROFILE_WRITE_U8(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  307|      0|[0;41mprofile_set_pc(pc);[0m
  308|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_WRITE_U8(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  309|      0|[0;41m}[0m
  310|      0|void INS_PROFILE_WRITE_DOUBLE(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  311|      0|[0;41mprofile_set_pc(pc);[0m
  312|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_WRITE_DOUBLE(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  313|      0|[0;41m}[0m
  314|      0|void INS_PROFILE_SYMBOL_STRING(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  315|      0|[0;41mprofile_set_pc(pc);[0m
  316|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_SYMBOL_STRING(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  317|      0|[0;41m}[0m
  318|      0|void INS_PROFILE_STRING_SYMBOL(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  319|      0|[0;41mprofile_set_pc(pc);[0m
  320|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_STRING_SYMBOL(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  321|      0|[0;41m}[0m
  322|      0|void INS_PROFILE_CHAR_INTEGER(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  323|      0|[0;41mprofile_set_pc(pc);[0m
  324|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_CHAR_INTEGER(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  325|      0|[0;41m}[0m
  326|      0|void INS_PROFILE_INTEGER_CHAR(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  327|      0|[0;41mprofile_set_pc(pc);[0m
  328|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_INTEGER_CHAR(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  329|      0|[0;41m}[0m
  330|      0|void INS_PROFILE_OPEN(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  331|      0|[0;41mprofile_set_pc(pc);[0m
  332|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_OPEN(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  333|      0|[0;41m}[0m
  334|      0|void INS_PROFILE_CLOSE(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  335|      0|[0;41mprofile_set_pc(pc);[0m
  336|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_CLOSE(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  337|      0|[0;41m}[0m
  338|      0|void INS_PROFILE_PEEK(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  339|      0|[0;41mprofile_set_pc(pc);[0m
  340|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_PEEK(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  341|      0|[0;41m}[0m
  342|      0|void INS_PROFILE_READ(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  343|      0|[0;41mprofile_set_pc(pc);[0m
  344|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_READ(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  345|      0|[0;41m}[0m
  346|      0|void INS_PROFILE_READ_LINE(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  347|      0|[0;41mprofile_set_pc(pc);[0m
  348|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_READ_LINE(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  349|      0|[0;41m}[0m
  350|      0|void INS_PROFILE_INEXACT(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  351|      0|[0;41mprofile_set_pc(pc);[0m
  352|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_INEXACT(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  353|      0|[0;41m}[0m
  354|      0|void INS_PROFILE_EXACT(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  355|      0|[0;41mprofile_set_pc(pc);[0m
  356|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_EXACT(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  357|      0|[0;41m}[0m
  358|      0|void INS_PROFILE_ROUND(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  359|      0|[0;41mprofile_set_pc(pc);[0m
  360|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_ROUND(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  361|      0|[0;41m}[0m
  362|      0|void INS_PROFILE_SIN(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  363|      0|[0;41mprofile_set_pc(pc);[0m
  364|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_SIN(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  365|      0|[0;41m}[0m
  366|      0|void INS_PROFILE_SQRT(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  367|      0|[0;41mprofile_set_pc(pc);[0m
  368|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_SQRT(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  369|      0|[0;41m}[0m
  370|      0|void INS_PROFILE_ATAN(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  371|      0|[0;41mprofile_set_pc(pc);[0m
  372|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_ATAN(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  373|      0|[0;41m}[0m
  374|      0|void INS_PROFILE_COS(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  375|      0|[0;41mprofile_set_pc(pc);[0m
  376|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_COS(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  377|      0|[0;41m}[0m
  378|      0|void INS_PROFILE_TRUNCATE(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  379|      0|[0;41mprofile_set_pc(pc);[0m
  380|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_TRUNCATE(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  381|      0|[0;41m}[0m
  382|      0|void INS_PROFILE_FLOOR(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  383|      0|[0;41mprofile_set_pc(pc);[0m
  384|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_FLOOR(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  385|      0|[0;41m}[0m
  386|      0|void INS_PROFILE_CEILING(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  387|      0|[0;41mprofile_set_pc(pc);[0m
  388|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_CEILING(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  389|      0|[0;41m}[0m
  390|      0|void INS_PROFILE_EXP(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  391|      0|[0;41mprofile_set_pc(pc);[0m
  392|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_EXP(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  393|      0|[0;41m}[0m
  394|      0|void INS_PROFILE_LOG(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  395|      0|[0;41mprofile_set_pc(pc);[0m
  396|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_LOG(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  397|      0|[0;41m}[0m
  398|      0|void INS_PROFILE_TAN(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  399|      0|[0;41mprofile_set_pc(pc);[0m
  400|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_TAN(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  401|      0|[0;41m}[0m
  402|      0|void INS_PROFILE_ASIN(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  403|      0|[0;41mprofile_set_pc(pc);[0m
  404|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_ASIN(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  405|      0|[0;41m}[0m
  406|      0|void INS_PROFILE_ACOS(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  407|      0|[0;41mprofile_set_pc(pc);[0m
  408|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_ACOS(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  409|      0|[0;41m}[0m
  410|      0|void INS_PROFILE_CALLCC(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  411|      0|[0;41mprofile_set_pc(pc);[0m
  412|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_CALLCC(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  413|      0|[0;41m}[0m
  414|      0|void INS_PROFILE_CALLCC_RESUME(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  415|      0|[0;41mprofile_set_pc(pc);[0m
  416|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_CALLCC_RESUME(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  417|      0|[0;41m}[0m
  418|      0|void INS_PROFILE_FILE_EXISTS(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  419|      0|[0;41mprofile_set_pc(pc);[0m
  420|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_FILE_EXISTS(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  421|      0|[0;41m}[0m
  422|      0|void INS_PROFILE_DELETE_FILE(unsigned char ra, unsigned instr, unsigned *pc, long *frame, void **op_table_arg, long argcnt) [0;41m{[0m
  423|      0|[0;41mprofile_set_pc(pc);[0m
  424|      0|[0;41m[0m[0;41mMUSTTAIL[0m[0;41m return INS_DELETE_FILE(ra, instr, pc, frame, op_table_arg, argcnt);[0m
  425|      0|[0;41m}[0m
  426|       |#endif
  427|    167|static void opcode_table_init() {  l_op_table[ILOOP] = INS_ILOOP;
  428|    167|#ifdef PROFILER
  429|    167|  l_op_table_profile[ILOOP] = INS_PROFILE_ILOOP;
  430|    167|#endif
  431|    167|  l_op_table[LOOP] = INS_LOOP;
  432|    167|#ifdef PROFILER
  433|    167|  l_op_table_profile[LOOP] = INS_PROFILE_LOOP;
  434|    167|#endif
  435|    167|  l_op_table[IFUNC] = INS_IFUNC;
  436|    167|#ifdef PROFILER
  437|    167|  l_op_table_profile[IFUNC] = INS_PROFILE_IFUNC;
  438|    167|#endif
  439|    167|  l_op_table[FUNC] = INS_FUNC;
  440|    167|#ifdef PROFILER
  441|    167|  l_op_table_profile[FUNC] = INS_PROFILE_FUNC;
  442|    167|#endif
  443|    167|  l_op_table[IFUNCV] = INS_IFUNCV;
  444|    167|#ifdef PROFILER
  445|    167|  l_op_table_profile[IFUNCV] = INS_PROFILE_IFUNCV;
  446|    167|#endif
  447|    167|  l_op_table[FUNCV] = INS_FUNCV;
  448|    167|#ifdef PROFILER
  449|    167|  l_op_table_profile[FUNCV] = INS_PROFILE_FUNCV;
  450|    167|#endif
  451|    167|  l_op_table[ICLFUNC] = INS_ICLFUNC;
  452|    167|#ifdef PROFILER
  453|    167|  l_op_table_profile[ICLFUNC] = INS_PROFILE_ICLFUNC;
  454|    167|#endif
  455|    167|  l_op_table[CLFUNC] = INS_CLFUNC;
  456|    167|#ifdef PROFILER
  457|    167|  l_op_table_profile[CLFUNC] = INS_PROFILE_CLFUNC;
  458|    167|#endif
  459|    167|  l_op_table[ICLFUNCV] = INS_ICLFUNCV;
  460|    167|#ifdef PROFILER
  461|    167|  l_op_table_profile[ICLFUNCV] = INS_PROFILE_ICLFUNCV;
  462|    167|#endif
  463|    167|  l_op_table[CLFUNCV] = INS_CLFUNCV;
  464|    167|#ifdef PROFILER
  465|    167|  l_op_table_profile[CLFUNCV] = INS_PROFILE_CLFUNCV;
  466|    167|#endif
  467|    167|  l_op_table[KSHORT] = INS_KSHORT;
  468|    167|#ifdef PROFILER
  469|    167|  l_op_table_profile[KSHORT] = INS_PROFILE_KSHORT;
  470|    167|#endif
  471|    167|  l_op_table[JMP] = INS_JMP;
  472|    167|#ifdef PROFILER
  473|    167|  l_op_table_profile[JMP] = INS_PROFILE_JMP;
  474|    167|#endif
  475|    167|  l_op_table[IRET1] = INS_IRET1;
  476|    167|#ifdef PROFILER
  477|    167|  l_op_table_profile[IRET1] = INS_PROFILE_IRET1;
  478|    167|#endif
  479|    167|  l_op_table[RET1] = INS_RET1;
  480|    167|#ifdef PROFILER
  481|    167|  l_op_table_profile[RET1] = INS_PROFILE_RET1;
  482|    167|#endif
  483|    167|  l_op_table[HALT] = INS_HALT;
  484|    167|#ifdef PROFILER
  485|    167|  l_op_table_profile[HALT] = INS_PROFILE_HALT;
  486|    167|#endif
  487|    167|  l_op_table[SUBVN] = INS_SUBVN;
  488|    167|#ifdef PROFILER
  489|    167|  l_op_table_profile[SUBVN] = INS_PROFILE_SUBVN;
  490|    167|#endif
  491|    167|  l_op_table[ADDVN] = INS_ADDVN;
  492|    167|#ifdef PROFILER
  493|    167|  l_op_table_profile[ADDVN] = INS_PROFILE_ADDVN;
  494|    167|#endif
  495|    167|  l_op_table[ADDVV] = INS_ADDVV;
  496|    167|#ifdef PROFILER
  497|    167|  l_op_table_profile[ADDVV] = INS_PROFILE_ADDVV;
  498|    167|#endif
  499|    167|  l_op_table[SUBVV] = INS_SUBVV;
  500|    167|#ifdef PROFILER
  501|    167|  l_op_table_profile[SUBVV] = INS_PROFILE_SUBVV;
  502|    167|#endif
  503|    167|  l_op_table[MULVV] = INS_MULVV;
  504|    167|#ifdef PROFILER
  505|    167|  l_op_table_profile[MULVV] = INS_PROFILE_MULVV;
  506|    167|#endif
  507|    167|  l_op_table[DIV] = INS_DIV;
  508|    167|#ifdef PROFILER
  509|    167|  l_op_table_profile[DIV] = INS_PROFILE_DIV;
  510|    167|#endif
  511|    167|  l_op_table[REM] = INS_REM;
  512|    167|#ifdef PROFILER
  513|    167|  l_op_table_profile[REM] = INS_PROFILE_REM;
  514|    167|#endif
  515|    167|  l_op_table[EQ] = INS_EQ;
  516|    167|#ifdef PROFILER
  517|    167|  l_op_table_profile[EQ] = INS_PROFILE_EQ;
  518|    167|#endif
  519|    167|  l_op_table[JEQ] = INS_JEQ;
  520|    167|#ifdef PROFILER
  521|    167|  l_op_table_profile[JEQ] = INS_PROFILE_JEQ;
  522|    167|#endif
  523|    167|  l_op_table[JNEQ] = INS_JNEQ;
  524|    167|#ifdef PROFILER
  525|    167|  l_op_table_profile[JNEQ] = INS_PROFILE_JNEQ;
  526|    167|#endif
  527|    167|  l_op_table[JISLT] = INS_JISLT;
  528|    167|#ifdef PROFILER
  529|    167|  l_op_table_profile[JISLT] = INS_PROFILE_JISLT;
  530|    167|#endif
  531|    167|  l_op_table[JISEQ] = INS_JISEQ;
  532|    167|#ifdef PROFILER
  533|    167|  l_op_table_profile[JISEQ] = INS_PROFILE_JISEQ;
  534|    167|#endif
  535|    167|  l_op_table[JISNEQ] = INS_JISNEQ;
  536|    167|#ifdef PROFILER
  537|    167|  l_op_table_profile[JISNEQ] = INS_PROFILE_JISNEQ;
  538|    167|#endif
  539|    167|  l_op_table[JISLTE] = INS_JISLTE;
  540|    167|#ifdef PROFILER
  541|    167|  l_op_table_profile[JISLTE] = INS_PROFILE_JISLTE;
  542|    167|#endif
  543|    167|  l_op_table[JISGT] = INS_JISGT;
  544|    167|#ifdef PROFILER
  545|    167|  l_op_table_profile[JISGT] = INS_PROFILE_JISGT;
  546|    167|#endif
  547|    167|  l_op_table[JISGTE] = INS_JISGTE;
  548|    167|#ifdef PROFILER
  549|    167|  l_op_table_profile[JISGTE] = INS_PROFILE_JISGTE;
  550|    167|#endif
  551|    167|  l_op_table[ISLT] = INS_ISLT;
  552|    167|#ifdef PROFILER
  553|    167|  l_op_table_profile[ISLT] = INS_PROFILE_ISLT;
  554|    167|#endif
  555|    167|  l_op_table[ISGT] = INS_ISGT;
  556|    167|#ifdef PROFILER
  557|    167|  l_op_table_profile[ISGT] = INS_PROFILE_ISGT;
  558|    167|#endif
  559|    167|  l_op_table[ISLTE] = INS_ISLTE;
  560|    167|#ifdef PROFILER
  561|    167|  l_op_table_profile[ISLTE] = INS_PROFILE_ISLTE;
  562|    167|#endif
  563|    167|  l_op_table[ISGTE] = INS_ISGTE;
  564|    167|#ifdef PROFILER
  565|    167|  l_op_table_profile[ISGTE] = INS_PROFILE_ISGTE;
  566|    167|#endif
  567|    167|  l_op_table[ISEQ] = INS_ISEQ;
  568|    167|#ifdef PROFILER
  569|    167|  l_op_table_profile[ISEQ] = INS_PROFILE_ISEQ;
  570|    167|#endif
  571|    167|  l_op_table[JISF] = INS_JISF;
  572|    167|#ifdef PROFILER
  573|    167|  l_op_table_profile[JISF] = INS_PROFILE_JISF;
  574|    167|#endif
  575|    167|  l_op_table[JIST] = INS_JIST;
  576|    167|#ifdef PROFILER
  577|    167|  l_op_table_profile[JIST] = INS_PROFILE_JIST;
  578|    167|#endif
  579|    167|  l_op_table[GGET] = INS_GGET;
  580|    167|#ifdef PROFILER
  581|    167|  l_op_table_profile[GGET] = INS_PROFILE_GGET;
  582|    167|#endif
  583|    167|  l_op_table[GSET] = INS_GSET;
  584|    167|#ifdef PROFILER
  585|    167|  l_op_table_profile[GSET] = INS_PROFILE_GSET;
  586|    167|#endif
  587|    167|  l_op_table[KFUNC] = INS_KFUNC;
  588|    167|#ifdef PROFILER
  589|    167|  l_op_table_profile[KFUNC] = INS_PROFILE_KFUNC;
  590|    167|#endif
  591|    167|  l_op_table[KONST] = INS_KONST;
  592|    167|#ifdef PROFILER
  593|    167|  l_op_table_profile[KONST] = INS_PROFILE_KONST;
  594|    167|#endif
  595|    167|  l_op_table[MOV] = INS_MOV;
  596|    167|#ifdef PROFILER
  597|    167|  l_op_table_profile[MOV] = INS_PROFILE_MOV;
  598|    167|#endif
  599|    167|  l_op_table[BOX] = INS_BOX;
  600|    167|#ifdef PROFILER
  601|    167|  l_op_table_profile[BOX] = INS_PROFILE_BOX;
  602|    167|#endif
  603|    167|  l_op_table[UNBOX] = INS_UNBOX;
  604|    167|#ifdef PROFILER
  605|    167|  l_op_table_profile[UNBOX] = INS_PROFILE_UNBOX;
  606|    167|#endif
  607|    167|  l_op_table[SET_BOX] = INS_SET_BOX;
  608|    167|#ifdef PROFILER
  609|    167|  l_op_table_profile[SET_BOX] = INS_PROFILE_SET_BOX;
  610|    167|#endif
  611|    167|  l_op_table[GUARD] = INS_GUARD;
  612|    167|#ifdef PROFILER
  613|    167|  l_op_table_profile[GUARD] = INS_PROFILE_GUARD;
  614|    167|#endif
  615|    167|  l_op_table[JGUARD] = INS_JGUARD;
  616|    167|#ifdef PROFILER
  617|    167|  l_op_table_profile[JGUARD] = INS_PROFILE_JGUARD;
  618|    167|#endif
  619|    167|  l_op_table[JNGUARD] = INS_JNGUARD;
  620|    167|#ifdef PROFILER
  621|    167|  l_op_table_profile[JNGUARD] = INS_PROFILE_JNGUARD;
  622|    167|#endif
  623|    167|  l_op_table[VECTOR] = INS_VECTOR;
  624|    167|#ifdef PROFILER
  625|    167|  l_op_table_profile[VECTOR] = INS_PROFILE_VECTOR;
  626|    167|#endif
  627|    167|  l_op_table[CLOSURE] = INS_CLOSURE;
  628|    167|#ifdef PROFILER
  629|    167|  l_op_table_profile[CLOSURE] = INS_PROFILE_CLOSURE;
  630|    167|#endif
  631|    167|  l_op_table[CLOSURE_GET] = INS_CLOSURE_GET;
  632|    167|#ifdef PROFILER
  633|    167|  l_op_table_profile[CLOSURE_GET] = INS_PROFILE_CLOSURE_GET;
  634|    167|#endif
  635|    167|  l_op_table[CLOSURE_SET] = INS_CLOSURE_SET;
  636|    167|#ifdef PROFILER
  637|    167|  l_op_table_profile[CLOSURE_SET] = INS_PROFILE_CLOSURE_SET;
  638|    167|#endif
  639|    167|  l_op_table[CLOSURE_PTR] = INS_CLOSURE_PTR;
  640|    167|#ifdef PROFILER
  641|    167|  l_op_table_profile[CLOSURE_PTR] = INS_PROFILE_CLOSURE_PTR;
  642|    167|#endif
  643|    167|  l_op_table[APPLY] = INS_APPLY;
  644|    167|#ifdef PROFILER
  645|    167|  l_op_table_profile[APPLY] = INS_PROFILE_APPLY;
  646|    167|#endif
  647|    167|  l_op_table[JFUNC] = INS_JFUNC;
  648|    167|#ifdef PROFILER
  649|    167|  l_op_table_profile[JFUNC] = INS_PROFILE_JFUNC;
  650|    167|#endif
  651|    167|  l_op_table[JLOOP] = INS_JLOOP;
  652|    167|#ifdef PROFILER
  653|    167|  l_op_table_profile[JLOOP] = INS_PROFILE_JLOOP;
  654|    167|#endif
  655|    167|  l_op_table[CALL] = INS_CALL;
  656|    167|#ifdef PROFILER
  657|    167|  l_op_table_profile[CALL] = INS_PROFILE_CALL;
  658|    167|#endif
  659|    167|  l_op_table[CALLT] = INS_CALLT;
  660|    167|#ifdef PROFILER
  661|    167|  l_op_table_profile[CALLT] = INS_PROFILE_CALLT;
  662|    167|#endif
  663|    167|  l_op_table[EQV] = INS_EQV;
  664|    167|#ifdef PROFILER
  665|    167|  l_op_table_profile[EQV] = INS_PROFILE_EQV;
  666|    167|#endif
  667|    167|  l_op_table[JEQV] = INS_JEQV;
  668|    167|#ifdef PROFILER
  669|    167|  l_op_table_profile[JEQV] = INS_PROFILE_JEQV;
  670|    167|#endif
  671|    167|  l_op_table[JNEQV] = INS_JNEQV;
  672|    167|#ifdef PROFILER
  673|    167|  l_op_table_profile[JNEQV] = INS_PROFILE_JNEQV;
  674|    167|#endif
  675|    167|  l_op_table[CONS] = INS_CONS;
  676|    167|#ifdef PROFILER
  677|    167|  l_op_table_profile[CONS] = INS_PROFILE_CONS;
  678|    167|#endif
  679|    167|  l_op_table[CAR] = INS_CAR;
  680|    167|#ifdef PROFILER
  681|    167|  l_op_table_profile[CAR] = INS_PROFILE_CAR;
  682|    167|#endif
  683|    167|  l_op_table[CDR] = INS_CDR;
  684|    167|#ifdef PROFILER
  685|    167|  l_op_table_profile[CDR] = INS_PROFILE_CDR;
  686|    167|#endif
  687|    167|  l_op_table[MAKE_VECTOR] = INS_MAKE_VECTOR;
  688|    167|#ifdef PROFILER
  689|    167|  l_op_table_profile[MAKE_VECTOR] = INS_PROFILE_MAKE_VECTOR;
  690|    167|#endif
  691|    167|  l_op_table[MAKE_STRING] = INS_MAKE_STRING;
  692|    167|#ifdef PROFILER
  693|    167|  l_op_table_profile[MAKE_STRING] = INS_PROFILE_MAKE_STRING;
  694|    167|#endif
  695|    167|  l_op_table[VECTOR_REF] = INS_VECTOR_REF;
  696|    167|#ifdef PROFILER
  697|    167|  l_op_table_profile[VECTOR_REF] = INS_PROFILE_VECTOR_REF;
  698|    167|#endif
  699|    167|  l_op_table[STRING_REF] = INS_STRING_REF;
  700|    167|#ifdef PROFILER
  701|    167|  l_op_table_profile[STRING_REF] = INS_PROFILE_STRING_REF;
  702|    167|#endif
  703|    167|  l_op_table[VECTOR_LENGTH] = INS_VECTOR_LENGTH;
  704|    167|#ifdef PROFILER
  705|    167|  l_op_table_profile[VECTOR_LENGTH] = INS_PROFILE_VECTOR_LENGTH;
  706|    167|#endif
  707|    167|  l_op_table[STRING_LENGTH] = INS_STRING_LENGTH;
  708|    167|#ifdef PROFILER
  709|    167|  l_op_table_profile[STRING_LENGTH] = INS_PROFILE_STRING_LENGTH;
  710|    167|#endif
  711|    167|  l_op_table[VECTOR_SET] = INS_VECTOR_SET;
  712|    167|#ifdef PROFILER
  713|    167|  l_op_table_profile[VECTOR_SET] = INS_PROFILE_VECTOR_SET;
  714|    167|#endif
  715|    167|  l_op_table[STRING_SET] = INS_STRING_SET;
  716|    167|#ifdef PROFILER
  717|    167|  l_op_table_profile[STRING_SET] = INS_PROFILE_STRING_SET;
  718|    167|#endif
  719|    167|  l_op_table[SET_CAR] = INS_SET_CAR;
  720|    167|#ifdef PROFILER
  721|    167|  l_op_table_profile[SET_CAR] = INS_PROFILE_SET_CAR;
  722|    167|#endif
  723|    167|  l_op_table[SET_CDR] = INS_SET_CDR;
  724|    167|#ifdef PROFILER
  725|    167|  l_op_table_profile[SET_CDR] = INS_PROFILE_SET_CDR;
  726|    167|#endif
  727|    167|  l_op_table[WRITE] = INS_WRITE;
  728|    167|#ifdef PROFILER
  729|    167|  l_op_table_profile[WRITE] = INS_PROFILE_WRITE;
  730|    167|#endif
  731|    167|  l_op_table[WRITE_U8] = INS_WRITE_U8;
  732|    167|#ifdef PROFILER
  733|    167|  l_op_table_profile[WRITE_U8] = INS_PROFILE_WRITE_U8;
  734|    167|#endif
  735|    167|  l_op_table[WRITE_DOUBLE] = INS_WRITE_DOUBLE;
  736|    167|#ifdef PROFILER
  737|    167|  l_op_table_profile[WRITE_DOUBLE] = INS_PROFILE_WRITE_DOUBLE;
  738|    167|#endif
  739|    167|  l_op_table[SYMBOL_STRING] = INS_SYMBOL_STRING;
  740|    167|#ifdef PROFILER
  741|    167|  l_op_table_profile[SYMBOL_STRING] = INS_PROFILE_SYMBOL_STRING;
  742|    167|#endif
  743|    167|  l_op_table[STRING_SYMBOL] = INS_STRING_SYMBOL;
  744|    167|#ifdef PROFILER
  745|    167|  l_op_table_profile[STRING_SYMBOL] = INS_PROFILE_STRING_SYMBOL;
  746|    167|#endif
  747|    167|  l_op_table[CHAR_INTEGER] = INS_CHAR_INTEGER;
  748|    167|#ifdef PROFILER
  749|    167|  l_op_table_profile[CHAR_INTEGER] = INS_PROFILE_CHAR_INTEGER;
  750|    167|#endif
  751|    167|  l_op_table[INTEGER_CHAR] = INS_INTEGER_CHAR;
  752|    167|#ifdef PROFILER
  753|    167|  l_op_table_profile[INTEGER_CHAR] = INS_PROFILE_INTEGER_CHAR;
  754|    167|#endif
  755|    167|  l_op_table[OPEN] = INS_OPEN;
  756|    167|#ifdef PROFILER
  757|    167|  l_op_table_profile[OPEN] = INS_PROFILE_OPEN;
  758|    167|#endif
  759|    167|  l_op_table[CLOSE] = INS_CLOSE;
  760|    167|#ifdef PROFILER
  761|    167|  l_op_table_profile[CLOSE] = INS_PROFILE_CLOSE;
  762|    167|#endif
  763|    167|  l_op_table[PEEK] = INS_PEEK;
  764|    167|#ifdef PROFILER
  765|    167|  l_op_table_profile[PEEK] = INS_PROFILE_PEEK;
  766|    167|#endif
  767|    167|  l_op_table[READ] = INS_READ;
  768|    167|#ifdef PROFILER
  769|    167|  l_op_table_profile[READ] = INS_PROFILE_READ;
  770|    167|#endif
  771|    167|  l_op_table[READ_LINE] = INS_READ_LINE;
  772|    167|#ifdef PROFILER
  773|    167|  l_op_table_profile[READ_LINE] = INS_PROFILE_READ_LINE;
  774|    167|#endif
  775|    167|  l_op_table[INEXACT] = INS_INEXACT;
  776|    167|#ifdef PROFILER
  777|    167|  l_op_table_profile[INEXACT] = INS_PROFILE_INEXACT;
  778|    167|#endif
  779|    167|  l_op_table[EXACT] = INS_EXACT;
  780|    167|#ifdef PROFILER
  781|    167|  l_op_table_profile[EXACT] = INS_PROFILE_EXACT;
  782|    167|#endif
  783|    167|  l_op_table[ROUND] = INS_ROUND;
  784|    167|#ifdef PROFILER
  785|    167|  l_op_table_profile[ROUND] = INS_PROFILE_ROUND;
  786|    167|#endif
  787|    167|  l_op_table[SIN] = INS_SIN;
  788|    167|#ifdef PROFILER
  789|    167|  l_op_table_profile[SIN] = INS_PROFILE_SIN;
  790|    167|#endif
  791|    167|  l_op_table[SQRT] = INS_SQRT;
  792|    167|#ifdef PROFILER
  793|    167|  l_op_table_profile[SQRT] = INS_PROFILE_SQRT;
  794|    167|#endif
  795|    167|  l_op_table[ATAN] = INS_ATAN;
  796|    167|#ifdef PROFILER
  797|    167|  l_op_table_profile[ATAN] = INS_PROFILE_ATAN;
  798|    167|#endif
  799|    167|  l_op_table[COS] = INS_COS;
  800|    167|#ifdef PROFILER
  801|    167|  l_op_table_profile[COS] = INS_PROFILE_COS;
  802|    167|#endif
  803|    167|  l_op_table[TRUNCATE] = INS_TRUNCATE;
  804|    167|#ifdef PROFILER
  805|    167|  l_op_table_profile[TRUNCATE] = INS_PROFILE_TRUNCATE;
  806|    167|#endif
  807|    167|  l_op_table[FLOOR] = INS_FLOOR;
  808|    167|#ifdef PROFILER
  809|    167|  l_op_table_profile[FLOOR] = INS_PROFILE_FLOOR;
  810|    167|#endif
  811|    167|  l_op_table[CEILING] = INS_CEILING;
  812|    167|#ifdef PROFILER
  813|    167|  l_op_table_profile[CEILING] = INS_PROFILE_CEILING;
  814|    167|#endif
  815|    167|  l_op_table[EXP] = INS_EXP;
  816|    167|#ifdef PROFILER
  817|    167|  l_op_table_profile[EXP] = INS_PROFILE_EXP;
  818|    167|#endif
  819|    167|  l_op_table[LOG] = INS_LOG;
  820|    167|#ifdef PROFILER
  821|    167|  l_op_table_profile[LOG] = INS_PROFILE_LOG;
  822|    167|#endif
  823|    167|  l_op_table[TAN] = INS_TAN;
  824|    167|#ifdef PROFILER
  825|    167|  l_op_table_profile[TAN] = INS_PROFILE_TAN;
  826|    167|#endif
  827|    167|  l_op_table[ASIN] = INS_ASIN;
  828|    167|#ifdef PROFILER
  829|    167|  l_op_table_profile[ASIN] = INS_PROFILE_ASIN;
  830|    167|#endif
  831|    167|  l_op_table[ACOS] = INS_ACOS;
  832|    167|#ifdef PROFILER
  833|    167|  l_op_table_profile[ACOS] = INS_PROFILE_ACOS;
  834|    167|#endif
  835|    167|  l_op_table[CALLCC] = INS_CALLCC;
  836|    167|#ifdef PROFILER
  837|    167|  l_op_table_profile[CALLCC] = INS_PROFILE_CALLCC;
  838|    167|#endif
  839|    167|  l_op_table[CALLCC_RESUME] = INS_CALLCC_RESUME;
  840|    167|#ifdef PROFILER
  841|    167|  l_op_table_profile[CALLCC_RESUME] = INS_PROFILE_CALLCC_RESUME;
  842|    167|#endif
  843|    167|  l_op_table[FILE_EXISTS] = INS_FILE_EXISTS;
  844|    167|#ifdef PROFILER
  845|    167|  l_op_table_profile[FILE_EXISTS] = INS_PROFILE_FILE_EXISTS;
  846|    167|#endif
  847|    167|  l_op_table[DELETE_FILE] = INS_DELETE_FILE;
  848|    167|#ifdef PROFILER
  849|    167|  l_op_table_profile[DELETE_FILE] = INS_PROFILE_DELETE_FILE;
  850|    167|#endif
  851|    167|}

[0;36m/home/davejwatson/myprojects/boom/opt_loop.c:
[0m    1|       |#include "asm_x64.h" // for REG_NONE
    2|       |#include "ir.h"      // for ir_ins, snap_s, snap_entry_s, trace_s, ir_ins_op
    3|       |#include "third-party/stb_ds.h"
    4|       |#include <assert.h> // for assert
    5|       |#include <stdbool.h>
    6|       |#include <stdint.h> // for uint16_t
    7|       |#include <stdio.h>  // for size_t, printf
    8|       |
    9|      0|#define auto [0;41m__auto_type[0m
   10|       |#define nullptr NULL
   11|       |
   12|      0|void opt_loop(trace_s *trace, int *regs) [0;41m{[0m
   13|      [0;35m0[0m|[0;41m  [0m[0;41mauto[0m[0;41m cut = [0m[0;41marrlen[0m[0;41m(trace->ops);[0m
   14|      [0;35m0[0m|[0;41m  [0m[0;41mauto[0m[0;41m snap_cut = [0m[0;41marrlen[0m[0;41m(trace->snaps);[0m
   15|      0|[0;41m  uint16_t replace[cut * 2 + 1];[0m
   16|      [0;35m0[0m|[0;41m  for (unsigned i = 0; [0m[0;41mi < cut * 2 + 1[0m[0;41m; [0m[0;41mi++[0m[0;41m) [0m[0;41m{[0m
   17|      0|[0;41m    replace[i] = i;[0m
   18|      0|[0;41m  }[0m[0;41m[0m
   19|       |[0;41m[0m[0;41m[0m
   20|      0|[0;41m  {[0m
   21|      0|[0;41m    ir_ins ins;[0m
   22|      0|[0;41m    ins.reg = [0m[0;41mREG_NONE[0m[0;41m;[0m
   23|      0|[0;41m    ins.op = IR_LOOP;[0m
   24|      0|[0;41m    [0m[0;41marrput[0m[0;41m(trace->ops, ins);[0m
   25|      0|[0;41m  }[0m
   26|       |[0;41m[0m[0;41m[0m
   27|      0|[0;41m  size_t *phis = NULL;[0m
   28|      0|[0;41m  unsigned long cur_snap = 0;[0m
   29|      [0;35m0[0m|[0;41m  for (size_t i = 0; [0m[0;41mi < cut + 1[0m[0;41m; [0m[0;41mi++[0m[0;41m) [0m[0;41m{[0m
   30|       |[0;41m[0m    // Emit phis last.[0;41m[0m
   31|      [0;35m0[0m|[0;41m    if ([0m[0;41mi == cut[0m[0;41m) [0m[0;41m{[0m
   32|      [0;35m0[0m|[0;41m      for (uint64_t j = 0; [0m[0;41mj < [0m[0;41marrlen[0m[0;41m(phis); [0m[0;41mj++[0m[0;41m) [0m[0;41m{[0m
   33|      0|[0;41m        unsigned long phi = phis[j];[0m
   34|      0|[0;41m        ir_ins ins;[0m
   35|      0|[0;41m        ins.reg = [0m[0;41mREG_NONE[0m[0;41m;[0m
   36|      0|[0;41m        ins.op = IR_PHI;[0m
   37|      0|[0;41m        ins.op1 = replace[phi];[0m
   38|      0|[0;41m        ins.op2 = replace[regs[trace->ops[phi].op1]];[0m
   39|      0|[0;41m        regs[trace->ops[phi].op1] = [0m[0;41marrlen[0m[0;41m(trace->ops);[0m
   40|      0|[0;41m        replace[ins.op2] = [0m[0;41marrlen[0m[0;41m(trace->ops);[0m
   41|      0|[0;41m        replace[ins.op1] = [0m[0;41marrlen[0m[0;41m(trace->ops);[0m
   42|      0|[0;41m        [0m[0;41marrput[0m[0;41m(trace->ops, ins);[0m
   43|      0|[0;41m      }[0m
   44|      0|[0;41m    }[0m
   45|       |[0;41m[0m    // Emit snaps, including any final snaps.[0;41m[0m
   46|      [0;35m0[0m|[0;41m    while ([0m[0;41m(cur_snap < [0m[0;41marrlen[0m[0;41m(trace->snaps)) &&[0m
   47|      [0;35m0[0m|[0;41m           [0m[0;41m(trace->snaps[cur_snap].ir == i)[0m[0;41m) [0m[0;41m{[0m
   48|      0|[0;41m      [0m[0;41mauto[0m[0;41m snap = &trace->snaps[cur_snap];[0m
   49|       |[0;41m[0m[0;41m[0m
   50|      [0;35m0[0m|[0;41m      if ([0m[0;41mcur_snap != 0[0m[0;41m) [0m[0;41m{[0m
   51|      0|[0;41m        snap_s nsnap;[0m
   52|      0|[0;41m        nsnap.ir = [0m[0;41marrlen[0m[0;41m(trace->ops);[0m
   53|      0|[0;41m        nsnap.pc = snap->pc;[0m
   54|      0|[0;41m        nsnap.offset = snap->offset;[0m
   55|      0|[0;41m        nsnap.exits = 0;[0m
   56|      0|[0;41m        nsnap.link = -1;[0m
   57|       |[0;41m[0m        // Emit loopsnap - all final loop snapshots are carried through loop[0;41m[0m
   58|      0|[0;41m        [0m[0;41mauto[0m[0;41m loopsnap = &trace->snaps[snap_cut - 1];[0m
   59|      [0;35m0[0m|[0;41m        for (uint64_t j = 0; [0m[0;41mj < [0m[0;41marrlen[0m[0;41m(loopsnap->slots); [0m[0;41mj++[0m[0;41m) [0m[0;41m{[0m
   60|      0|[0;41m          [0m[0;41mauto[0m[0;41m entry = &loopsnap->slots[j];[0m
   61|      [0;35m0[0m|[0;41m          if ([0m[0;41mentry->val < [0m[0;41mIR_CONST_BIAS[0m[0;41m) [0m[0;41m{[0m
   62|      0|[0;41m            snap_entry_s new_entry =[0m
   63|      0|[0;41m                (snap_entry_s){entry->slot, replace[entry->val]};[0m
   64|      0|[0;41m            [0m[0;41marrput[0m[0;41m(nsnap.slots, new_entry);[0m
   65|      0|[0;41m          } else [0m[0;41m{[0m
   66|      0|[0;41m            [0m[0;41marrput[0m[0;41m(nsnap.slots, *entry);[0m
   67|      0|[0;41m          }[0m
   68|      0|[0;41m        }[0m
   69|       |[0;41m[0m        // Emit in-loop snaps.  Merge with[0;41m[0m
   70|      [0;35m0[0m|[0;41m        for (uint64_t j = 0; [0m[0;41mj < [0m[0;41marrlen[0m[0;41m(snap->slots); [0m[0;41mj++[0m[0;41m) [0m[0;41m{[0m
   71|      0|[0;41m          [0m[0;41mauto[0m[0;41m entry = &snap->slots[j];[0m
   72|      0|[0;41m          snap_entry_s new_entry;[0m
   73|      [0;35m0[0m|[0;41m          if ([0m[0;41mentry->val < [0m[0;41mIR_CONST_BIAS[0m[0;41m) [0m[0;41m{[0m
   74|      0|[0;41m            new_entry = (snap_entry_s){entry->slot, replace[entry->val]};[0m
   75|      0|[0;41m          }[0m[0;41m else [0m[0;41m{[0m
   76|      0|[0;41m            new_entry = *entry;[0m
   77|      0|[0;41m          }[0m[0;41m[0m
   78|      0|[0;41m          bool done = false;[0m
   79|      [0;35m0[0m|[0;41m          for (uint64_t k = 0; [0m[0;41mj < [0m[0;41marrlen[0m[0;41m(nsnap.slots); [0m[0;41mk++[0m[0;41m) [0m[0;41m{[0m
   80|      0|[0;41m            [0m[0;41mauto[0m[0;41m nentry = &nsnap.slots[k];[0m
   81|      [0;35m0[0m|[0;41m            if ([0m[0;41mnentry->slot == new_entry.slot[0m[0;41m) [0m[0;41m{[0m
   82|      0|[0;41m              nentry->val = new_entry.val;[0m
   83|      0|[0;41m              done = true;[0m
   84|      0|[0;41m              break;[0m
   85|      0|[0;41m            }[0m[0;41m[0m
   86|      0|[0;41m          }[0m
   87|      [0;35m0[0m|[0;41m          if ([0m[0;41m!done[0m[0;41m) [0m[0;41m{[0m
   88|      0|[0;41m            [0m[0;41marrput[0m[0;41m(nsnap.slots, (new_entry));[0m
   89|      0|[0;41m          }[0m
   90|      0|[0;41m        }[0m
   91|      0|[0;41m        [0m[0;41marrput[0m[0;41m(trace->snaps, nsnap);[0m
   92|      0|[0;41m      }[0m
   93|       |[0;41m[0m[0;41m[0m
   94|      0|[0;41m      cur_snap++;[0m
   95|      0|[0;41m    }[0m
   96|      [0;35m0[0m|[0;41m    if ([0m[0;41mi == cut[0m[0;41m) [0m[0;41m{[0m
   97|      0|[0;41m      break;[0m
   98|      0|[0;41m    }[0m[0;41m[0m
   99|      [0;35m0[0m|    [0;41mauto[0m[0;41m ins = &trace->ops[i];[0m
  100|      0|[0;41m    switch (ins->op) [0m[0;41m{[0m
  101|      0|    [0;41mcase IR_ARG:[0m
  102|      0|[0;41m    [0m[0;41mcase IR_SLOAD: {[0m
  103|      0|[0;41m      assert(regs[ins->op1] >= 0)[0m[0;41m;[0m
  104|      0|      [0;41mreplace[i] = regs[ins->op1];[0m
  105|      0|[0;41m      printf("Potential phi: %zu %zu\n", i, [0m[0;41marrlen[0m[0;41m(trace->ops));[0m
  106|      0|[0;41m      [0m[0;41marrput[0m[0;41m(phis, i);[0m
  107|      0|[0;41m      break;[0m
  108|      0|[0;41m    }[0m
  109|      0|[0;41m    [0m[0;41mcase IR_GE:[0m
  110|      0|[0;41m    [0m[0;41mcase IR_ADD:[0m
  111|      0|[0;41m    [0m[0;41mcase IR_EQ:[0m
  112|      0|[0;41m    [0m[0;41mcase IR_NE:[0m
  113|      0|[0;41m    [0m[0;41mcase IR_SUB: {[0m
  114|      0|[0;41m      ir_ins copy = *ins;[0m
  115|      [0;35m0[0m|[0;41m      if ([0m[0;41mcopy.op1 < [0m[0;41mIR_CONST_BIAS[0m[0;41m) [0m[0;41m{[0m
  116|      0|[0;41m        copy.op1 = replace[copy.op1];[0m
  117|      0|[0;41m      }[0m[0;41m[0m
  118|      [0;35m0[0m|[0;41m      if ([0m[0;41mcopy.op2 < [0m[0;41mIR_CONST_BIAS[0m[0;41m) [0m[0;41m{[0m
  119|      0|[0;41m        copy.op2 = replace[copy.op2];[0m
  120|      0|[0;41m      }[0m[0;41m[0m
  121|      0|[0;41m      replace[i] = [0m[0;41marrlen[0m[0;41m(trace->ops);[0m
  122|      0|[0;41m      [0m[0;41marrput[0m[0;41m(trace->ops, copy);[0m
  123|      0|[0;41m      break;[0m
  124|      0|[0;41m    }[0m
  125|      0|[0;41m    [0m[0;41mcase IR_GGET: {[0m
  126|      0|[0;41m      ir_ins copy = *ins;[0m
  127|      [0;35m0[0m|[0;41m      if ([0m[0;41mcopy.op1 < [0m[0;41mIR_CONST_BIAS[0m[0;41m) [0m[0;41m{[0m
  128|      0|[0;41m        copy.op1 = replace[copy.op1];[0m
  129|      0|[0;41m      }[0m[0;41m[0m
  130|      0|[0;41m      replace[i] = [0m[0;41marrlen[0m[0;41m(trace->ops);[0m
  131|      0|[0;41m      [0m[0;41marrput[0m[0;41m(trace->ops, copy);[0m
  132|      0|[0;41m      break;[0m
  133|      0|[0;41m    }[0m
  134|      0|[0;41m    [0m[0;41mdefault: {[0m
  135|      0|[0;41m      printf("Can't loop ir type: %s\n", ir_names[(int)ins->op]);[0m
  136|      0|[0;41m      [0m[0;41marrsetlen[0m[0;41m(trace->ops, cut);[0m
  137|      0|[0;41m      [0m[0;41marrsetlen[0m[0;41m(trace->snaps, snap_cut);[0m
  138|      0|[0;41m      return;[0m
  139|      0|[0;41m    }[0m
  140|      0|[0;41m    }[0m
  141|      0|[0;41m  }[0m
  142|      0|[0;41m}[0m

[0;36m/home/davejwatson/myprojects/boom/parallel_copy.c:
[0m    1|       |// Copyright 2023 Dave Watson
    2|       |
    3|       |#include "parallel_copy.h"
    4|       |
    5|       |#include <assert.h>
    6|       |#include <stddef.h>
    7|       |#include <stdio.h>
    8|       |#include <stdlib.h>
    9|       |
   10|       |#define REG_MAX (256 + 32)
   11|       |
   12|       |/* serialize parallel copy implementation, based on
   13|       | * https://github.com/pfalcon/parcopy
   14|       | * Allows fan out, does not allow fan in / dst smashing.
   15|       | */
   16|       |
   17|  56.2k|static void map_init(map *m) { m->mp_sz = 0; }
   18|       |
   19|   223k|static par_copy *map_find(map *m, uint64_t needle) {
   20|   [0;35m948k[0m|  for (uint64_t i = 0; i < m->mp_sz; i++) {
   21|   [0;35m865k[0m|    if (m->mp[i].from == needle) {
   22|   140k|      return &m->mp[i];
   23|   140k|    }
   24|   865k|  }
   25|       |
   26|  83.2k|  return NULL;
   27|   223k|}
   28|       |
   29|  44.4k|static void map_erase(map *m, uint64_t needle) {
   30|   [0;35m114k[0m|  for (uint64_t i = 0; i < m->mp_sz; i++) {
   31|   [0;35m114k[0m|    if (m->mp[i].from == needle) {
   32|   [0;35m121k[0m|      for (uint64_t j = i + 1; j < m->mp_sz; j++) {
   33|  76.7k|        m->mp[j - 1] = m->mp[j];
   34|  76.7k|      }
   35|  44.4k|      m->mp_sz--;
   36|  44.4k|      break;
   37|  44.4k|    }
   38|   114k|  }
   39|  44.4k|}
   40|       |
   41|   162k|void map_insert(map *m, uint64_t key, uint64_t value) {
   42|   [0;35m162k[0m|  if (m->mp_sz == MAX_MAP_SIZE) [0;41m{[0m
   43|      0|[0;41m    printf("Hit max map size in parcopy\n");[0m
   44|      0|[0;41m    exit(-1);[0m
   45|      0|[0;41m  }[0m
   46|   162k|  m->mp[m->mp_sz].from = key;
   47|   162k|  m->mp[m->mp_sz].to = value;
   48|   162k|  m->mp_sz++;
   49|   162k|}
   50|       |
   51|  29.5k|static void map_set(map *m, uint64_t key, uint64_t value) {
   52|  29.5k|  __auto_type v = map_find(m, key);
   53|  [0;35m29.5k[0m|  if (v) {
   54|  28.8k|    v->to = value;
   55|  28.8k|  } else {
   56|    703|    map_insert(m, key, value);
   57|    703|  }
   58|  29.5k|}
   59|       |
   60|  18.7k|void serialize_parallel_copy(map *moves, map *moves_out, uint64_t tmp_reg) {
   61|  18.7k|  map_init(moves_out);
   62|       |
   63|  [0;35m62.8k[0m|  for (uint64_t i = 0; i < moves->mp_sz; i++) {
   64|  44.1k|    assert(moves->mp[i].from != tmp_reg);
   65|  44.1k|    assert(moves->mp[i].to != tmp_reg);
   66|  44.1k|  }
   67|       |
   68|  18.7k|  uint64_t ready[REG_MAX];
   69|  18.7k|  uint64_t ready_pos = 0;
   70|       |
   71|  18.7k|  map rmoves;
   72|  18.7k|  map loc;
   73|  18.7k|  map_init(&rmoves);
   74|  18.7k|  map_init(&loc);
   75|       |
   76|  [0;35m62.8k[0m|  for (uint64_t i = 0; i < moves->mp_sz; i++) {
   77|       |    // Check for dest-smashing.
   78|  44.1k|    assert(map_find(&rmoves, moves->mp[i].to) == NULL);
   79|  44.1k|    map_insert(&rmoves, moves->mp[i].to, moves->mp[i].from);
   80|  44.1k|    map_insert(&loc, moves->mp[i].from, moves->mp[i].from);
   81|  [0;35m44.1k[0m|    if (map_find(moves, moves->mp[i].to) == NULL) {
   82|  19.0k|      ready[ready_pos++] = moves->mp[i].to;
   83|  19.0k|    }
   84|  44.1k|  }
   85|       |
   86|  [0;35m34.4k[0m|  while (rmoves.mp_sz != 0) {
   87|  [0;35m68.7k[0m|    while (ready_pos != 0) {
   88|  48.2k|      uint64_t r = ready[ready_pos - 1];
   89|  48.2k|      ready_pos--;
   90|  [0;35m48.2k[0m|      if (map_find(&rmoves, r) == NULL) {
   91|  19.4k|        continue;
   92|  19.4k|      }
   93|  28.8k|      __auto_type work = map_find(&rmoves, r);
   94|  28.8k|      __auto_type rmove = map_find(&loc, work->to)->to;
   95|  28.8k|      map_insert(moves_out, rmove, r);
   96|  28.8k|      map_set(&loc, work->to, r);
   97|       |
   98|  28.8k|      map_erase(&rmoves, r);
   99|       |
  100|  28.8k|      ready[ready_pos++] = rmove;
  101|  28.8k|    }
  102|  [0;35m20.4k[0m|    if (rmoves.mp_sz == 0) {
  103|  4.83k|      break;
  104|  4.83k|    }
  105|       |
  106|  15.6k|    __auto_type from = rmoves.mp[0].to;
  107|  15.6k|    __auto_type to = rmoves.mp[0].from;
  108|  15.6k|    map_erase(&rmoves, to);
  109|  [0;35m15.6k[0m|    if (from != to) {
  110|       |      // There is a cycle, set one to tmp.
  111|    361|      map_insert(moves_out, from, tmp_reg);
  112|       |
  113|    361|      map_set(&loc, tmp_reg, tmp_reg);
  114|    361|      ready[ready_pos++] = from;
  115|       |
  116|    361|      map_set(&rmoves, to, tmp_reg);
  117|    361|    }
  118|  15.6k|  }
  119|  18.7k|}
  120|       |
  121|       |#if 0
  122|       |uint64_t tmp = 101;
  123|       |map moves;
  124|       |map expected;
  125|       |void run_test() {
  126|       |  map res;
  127|       |  serialize_parallel_copy(&moves, &res, tmp);
  128|       |  if (res.mp_sz != expected.mp_sz ||
  129|       |      memcmp(res.mp, expected.mp, sizeof(par_copy)*expected.mp_sz) !=0) {
  130|       |    printf("Got:\n");
  131|       |    for (uint64_t i = 0; i < res.mp_sz; i++) {
  132|       |      printf("Mov %li to %li\n", res.mp[i].from, res.mp[i].to);
  133|       |    }
  134|       |    printf("Expected:\n");
  135|       |    for (uint64_t i = 0; i < expected.mp_sz; i++) {
  136|       |      printf("Mov %li to %li\n", expected.mp[i].from, expected.mp[i].to);
  137|       |    }
  138|       |    assert(0);
  139|       |  }
  140|       |
  141|       |  map_init(&moves);
  142|       |  map_init(&expected);
  143|       |}
  144|       |
  145|       |int main() {
  146|       |  map_init(&moves);
  147|       |  map_init(&expected);
  148|       |
  149|       |  // Trivial case
  150|       |  tmp = 101;
  151|       |  map_insert(&moves, 1, 0);
  152|       |  map_insert(&moves, 2, 1);
  153|       |  map_insert(&moves, 3, 2);
  154|       |  map_insert(&expected, 1, 0);
  155|       |  map_insert(&expected, 2, 1);
  156|       |  map_insert(&expected, 3, 2);
  157|       |  run_test();
  158|       |
  159|       |  // Self loop optimized away
  160|       |  tmp = 1;
  161|       |  map_insert(&moves, 0, 0);
  162|       |  run_test();
  163|       |
  164|       |  // Loop with 2
  165|       |  tmp = 2;
  166|       |  map_insert(&moves, 0, 1);
  167|       |  map_insert(&moves, 1, 0);
  168|       |  map_insert(&expected, 0, tmp);
  169|       |  map_insert(&expected, 1, 0);
  170|       |  map_insert(&expected, tmp, 1);
  171|       |  run_test();
  172|       |
  173|       |  // Loop with 3
  174|       |  tmp = 0;
  175|       |  map_insert(&moves, 2, 1);
  176|       |  map_insert(&moves, 3, 2);
  177|       |  map_insert(&moves, 1, 3);
  178|       |  map_insert(&expected, 2, tmp);
  179|       |  map_insert(&expected, 3, 2);
  180|       |  map_insert(&expected, 1, 3);
  181|       |  map_insert(&expected, tmp, 1);
  182|       |  run_test();
  183|       |
  184|       |
  185|       |  // Two loops of 2
  186|       |  tmp = 4;
  187|       |  map_insert(&moves, 1, 0);
  188|       |  map_insert(&moves, 0, 1);
  189|       |  map_insert(&moves, 2, 3);
  190|       |  map_insert(&moves, 3, 2);
  191|       |  map_insert(&expected, 1, tmp);
  192|       |  map_insert(&expected, 0, 1);
  193|       |  map_insert(&expected, tmp, 0);
  194|       |  map_insert(&expected, 2, tmp);
  195|       |  map_insert(&expected, 3, 2);
  196|       |  map_insert(&expected, tmp, 3);
  197|       |
  198|       |  run_test();
  199|       |
  200|       |  // Simple fan out
  201|       |  tmp = 4;
  202|       |  map_insert(&moves, 1, 2);
  203|       |  map_insert(&moves, 1, 3);
  204|       |  map_insert(&expected, 1, 3);
  205|       |  map_insert(&expected, 3, 2);
  206|       |
  207|       |  run_test();
  208|       |
  209|       |  // More complex fan out
  210|       |  tmp = 5;
  211|       |  map_insert(&moves, 4, 1);
  212|       |  map_insert(&moves, 1, 2);
  213|       |  map_insert(&moves, 1, 3);
  214|       |  map_insert(&moves, 3, 4);
  215|       |  map_insert(&expected, 1, 2);
  216|       |  map_insert(&expected, 4, 1);
  217|       |  map_insert(&expected, 3, 4);
  218|       |  map_insert(&expected, 2, 3);
  219|       |
  220|       |  run_test();
  221|       |
  222|       |  // More complex fan out
  223|       |  tmp = 0;
  224|       |  map_insert(&moves, 1, 2);
  225|       |  map_insert(&moves, 2, 3);
  226|       |  map_insert(&moves, 3, 1);
  227|       |  map_insert(&moves, 3, 4);
  228|       |  map_insert(&expected, 3, 4);
  229|       |  map_insert(&expected, 2, 3);
  230|       |  map_insert(&expected, 1, 2);
  231|       |  map_insert(&expected, 4, 1);
  232|       |  run_test();
  233|       |
  234|       |  // Overlapping tmp
  235|       |  tmp = 5;
  236|       |  map_insert(&moves, 3, 1);
  237|       |  map_insert(&moves, 1, 3);
  238|       |  map_insert(&moves, 2, 4);
  239|       |  map_insert(&expected, 2, 4);
  240|       |  map_insert(&expected, 3, tmp);
  241|       |  map_insert(&expected, 1, 3);
  242|       |  map_insert(&expected, tmp, 1);
  243|       |
  244|       |  run_test();
  245|       |
  246|       |  // Multiple from
  247|       |  tmp = 15;
  248|       |  map_insert(&moves, 8, 11);
  249|       |  map_insert(&moves, 5, 9);
  250|       |  map_insert(&moves, 2, 8);
  251|       |  map_insert(&moves, 5, 2);
  252|       |  map_insert(&moves, 2, 1);
  253|       |  map_insert(&expected, 2, 1);
  254|       |  map_insert(&expected, 5, 2);
  255|       |  map_insert(&expected, 2, 9);
  256|       |  map_insert(&expected, 8, 11);
  257|       |  map_insert(&expected, 1, 8);
  258|       |
  259|       |  run_test();
  260|       |
  261|       |  return 0;
  262|       |}
  263|       |
  264|       |#endif

[0;36m/home/davejwatson/myprojects/boom/parallel_copy.h:
[0m    1|       |// Copyright 2023 Dave Watson
    2|       |#pragma once
    3|       |
    4|       |#include <stdint.h>
    5|       |
    6|   162k|#define MAX_MAP_SIZE (256 + 32)
    7|       |
    8|       |typedef struct par_copy {
    9|       |  uint64_t from;
   10|       |  uint64_t to;
   11|       |} par_copy;
   12|       |
   13|       |typedef struct map {
   14|       |  par_copy mp[MAX_MAP_SIZE];
   15|       |  uint64_t mp_sz;
   16|       |} map;
   17|       |
   18|       |void map_insert(map *m, uint64_t key, uint64_t value);
   19|       |void serialize_parallel_copy(map *moves, map *moves_out, uint64_t tmp_reg);

[0;36m/home/davejwatson/myprojects/boom/profiler.c:
[0m    1|       |#include "bytecode.h"    // for bcfunc, INS_OP, ins_names
    2|       |#include "vm.h"          // for find_func_for_frame
    3|       |#include "defs.h"
    4|       |
    5|       |#include <assert.h>       // for assert
    6|       |#include <signal.h>       // for sigaction, sigevent, SIGRTMIN
    7|       |#include <stdint.h>       // for uint32_t
    8|       |#include <stdio.h>        // for printf
    9|       |#include <stdlib.h>       // for exit, free, malloc
   10|       |#include <string.h>       // for memcpy
   11|       |#include <time.h>         // for timer_settime, timespec
   12|       |#include <sys/mman.h>    // for mmap, MAP_ANONYMOUS, MAP_P...
   13|       |#include <stdbool.h>
   14|       |
   15|      0|#define auto [0;41m__auto_type[0m
   16|      0|#define nullptr [0;41mNULL[0m
   17|       |
   18|       |static timer_t timerid;
   19|       |static struct itimerspec its;
   20|       |static long cnt = 0;
   21|       |
   22|       |static unsigned long heap_ptr = 0;
   23|       |static unsigned long heap_end = 0;
   24|       |
   25|       |static size_t alloc_sz = 4096 * 16;
   26|       |
   27|      0|void *signal_safe_malloc(size_t sz) [0;41m{[0m
   28|      [0;35m0[0m|[0;41m  if ([0m[0;41m(heap_ptr + sz) < heap_end[0m[0;41m) [0m[0;41m{[0m
   29|      0|[0;41m    [0m[0;41mauto[0m[0;41m res = heap_ptr;[0m
   30|      0|[0;41m    heap_ptr += sz;[0m
   31|      0|[0;41m    return (void *)res;[0m
   32|      0|[0;41m  }[0m
   33|      0|[0;41m  assert[0m[0;41m(sz < alloc_sz)[0m[0;41m;[0m
   34|      [0;35m0[0m|  [0;41mheap_ptr = (unsigned long)mmap([0m[0;41mnullptr[0m[0;41m, alloc_sz, PROT_READ | PROT_WRITE,[0m
   35|      0|[0;41m                                 MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);[0m
   36|      0|[0;41m  assert(heap_ptr);[0m
   37|      0|[0;41m  [0m[0;41mheap_end = heap_ptr + alloc_sz;[0m
   38|      0|[0;41m  [0m[0;41mauto[0m[0;41m res = heap_ptr;[0m
   39|      0|[0;41m  heap_ptr += sz;[0m
   40|      0|[0;41m  return (void *)res;[0m
   41|      0|[0;41m}[0m
   42|       |
   43|       |typedef struct sample_s {
   44|       |  long stack_sz;
   45|       |  long stack[10];
   46|       |  struct sample_s *next;
   47|       |  bool in_jit;
   48|       |  bool in_gc;
   49|       |} sample;
   50|       |
   51|       |static sample *samples = nullptr;
   52|       |
   53|       |static unsigned long profile_stack_sz = 0;
   54|       |static long *profile_stack = nullptr;
   55|       |static unsigned long profile_stack_max = 0;
   56|       |static uint32_t *pc;
   57|       |
   58|      0|void profile_set_pc(uint32_t *p) [0;41m{ pc = p; }[0m
   59|       |
   60|      0|void profile_add_frame(void *ptr) [0;41m{[0m
   61|      [0;35m0[0m|[0;41m  if ([0m[0;41mprofile_stack_sz >= profile_stack_max[0m[0;41m) [0m[0;41m{[0m
   62|      [0;35m0[0m|[0;41m    if ([0m[0;41mprofile_stack_max == 0[0m[0;41m) [0m[0;41m{[0m
   63|      0|[0;41m      profile_stack_max = 1000;[0m
   64|      0|[0;41m    }[0m[0;41m else [0m[0;41m{[0m
   65|      0|[0;41m      profile_stack_max *= 2;[0m
   66|      0|[0;41m    }[0m[0;41m[0m
   67|      0|[0;41m    [0m[0;41mauto[0m[0;41m *n = (long *)malloc(sizeof(long) * profile_stack_max);[0m
   68|      0|[0;41m    memcpy(n, profile_stack, profile_stack_sz * sizeof(long));[0m
   69|      0|[0;41m    [0m[0;41mauto[0m[0;41m *old = profile_stack;[0m
   70|      0|[0;41m    profile_stack = n; // release[0m
   71|      0|[0;41m    free(old);[0m
   72|      0|[0;41m    printf("Expanded profile stack to %li\n", profile_stack_max);[0m
   73|      0|[0;41m  }[0m
   74|      0|[0;41m  profile_stack[profile_stack_sz] = (long)ptr;[0m
   75|      0|[0;41m  profile_stack_sz++; // release[0m
   76|      0|[0;41m}[0m
   77|       |
   78|      0|void profile_pop_frame() [0;41m{[0m
   79|       |[0;41m[0m  // TODO make callcc resume work[0;41m[0m
   80|      [0;35m0[0m|[0;41m  if ([0m[0;41mprofile_stack_sz > 0[0m[0;41m) [0m[0;41m{[0m
   81|      0|[0;41m    profile_stack_sz--;[0m
   82|      0|[0;41m  }[0m[0;41m[0m
   83|      0|[0;41m}[0m
   84|       |
   85|      0|void profile_pop_all_frames() [0;41m{ profile_stack_sz = 0; }[0m
   86|       |
   87|       |extern bool in_jit;
   88|       |extern bool in_gc;
   89|      0|static void handler(int sig, siginfo_t *si, void *uc) [0;41m{[0m
   90|      0|[0;41m  cnt++;[0m
   91|      0|[0;41m  [0m[0;41mauto[0m[0;41m *s = (sample *)signal_safe_malloc(sizeof(sample));[0m
   92|      0|[0;41m  s->next = samples;[0m
   93|      [0;35m0[0m|[0;41m  s->stack_sz = [0m[0;41m9 < profile_stack_sz[0m[0;41m ? [0m[0;41m9[0m[0;41m : [0m[0;41mprofile_stack_sz[0m[0;41m;[0m
   94|      0|[0;41m  memcpy(&s->stack[0], &profile_stack[profile_stack_sz - s->stack_sz],[0m
   95|      0|[0;41m         s->stack_sz * sizeof(long));[0m
   96|      0|[0;41m  s->stack[s->stack_sz] = (long)pc;[0m
   97|      0|[0;41m  s->stack_sz++;[0m
   98|      0|[0;41m  s->in_jit = in_jit;[0m
   99|      0|[0;41m  s->in_gc = in_gc;[0m
  100|      0|[0;41m  samples = s;[0m
  101|      [0;35m0[0m|[0;41m  if ([0m[0;41mtimer_settime(timerid, 0, &its, [0m[0;41mnullptr[0m[0;41m) == -1) [0m[0;41m{[0m
  102|      0|[0;41m    exit(-2);[0m
  103|      0|[0;41m  }[0m[0;41m[0m
  104|      0|[0;41m}[0m
  105|       |
  106|      0|EXPORT void profiler_start() [0;41m{[0m
  107|      0|[0;41m  struct sigevent sev;[0m
  108|       |[0;41m[0m[0;41m[0m
  109|      0|[0;41m  struct sigaction sa;[0m
  110|      0|[0;41m  sa.sa_flags = SA_SIGINFO;[0m
  111|      0|[0;41m  sa.sa_sigaction = handler;[0m
  112|      [0;35m0[0m|[0;41m  if ([0m[0;41msigaction(SIGRTMIN, &sa, [0m[0;41mnullptr[0m[0;41m) == -1) [0m[0;41m{[0m
  113|      0|[0;41m    printf("Could not install signal handler profiler\n");[0m
  114|      0|[0;41m    exit(-1);[0m
  115|      0|[0;41m  }[0m[0;41m[0m
  116|       |
  117|      0|  [0;41msev.sigev_notify = SIGEV_SIGNAL;[0m
  118|      0|[0;41m  sev.sigev_signo = SIGRTMIN;[0m
  119|      0|[0;41m  sev.sigev_value.sival_ptr = &timerid;[0m
  120|      0|[0;41m  [0m[0;41mauto[0m[0;41m res = timer_create(CLOCK_MONOTONIC, &sev, &timerid);[0m
  121|      [0;35m0[0m|[0;41m  if ([0m[0;41mres == -1[0m[0;41m) [0m[0;41m{[0m
  122|      0|[0;41m    printf("Could not create profile timer\n");[0m
  123|      0|[0;41m    exit(-1);[0m
  124|      0|[0;41m  }[0m[0;41m[0m
  125|       |  //printf("Timer id is %li\n", (long)timerid);
  126|       |
  127|      0|  [0;41mits.it_value.tv_sec = 0;[0m
  128|      0|[0;41m  its.it_value.tv_nsec = 250000;[0m
  129|      0|[0;41m  its.it_interval.tv_sec = 0;[0m
  130|      0|[0;41m  its.it_interval.tv_nsec = 0;[0m
  131|      [0;35m0[0m|[0;41m  if ([0m[0;41mtimer_settime(timerid, 0, &its, [0m[0;41mnullptr[0m[0;41m) == -1) [0m[0;41m{[0m
  132|      0|[0;41m    printf("Could not timer_settime \n");[0m
  133|      0|[0;41m    exit(-1);[0m
  134|      0|[0;41m  }[0m[0;41m[0m
  135|      0|[0;41m}[0m
  136|       |
  137|       |/* struct tree { */
  138|       |/*   long cnt; */
  139|       |/*   std::unordered_map<long, tree> next; */
  140|       |/* }; */
  141|       |
  142|       |/* static void profiler_display_tree_node(const tree *node, int indent) { */
  143|       |/*   std::vector<std::pair<long, const tree *>> nodes; */
  144|       |/*   for (const auto &leaf : node->next) { */
  145|       |/*     if (leaf.second.cnt > cnt / 100) { */
  146|       |/*       nodes.emplace_back(leaf.first, &leaf.second); */
  147|       |/*     } */
  148|       |/*   } */
  149|       |
  150|       |/*   if (nodes.empty()) { */
  151|       |/*     return; */
  152|       |/*   } */
  153|       |
  154|       |/*   auto sorter = [](std::pair<long, const tree *> const &s1, */
  155|       |/*                    std::pair<long, const tree *> const &s2) { */
  156|       |/*     return s1.second->cnt > s2.second->cnt; */
  157|       |/*   }; */
  158|       |/*   std::sort(nodes.begin(), nodes.end(), sorter); */
  159|       |/*   for (auto &item : nodes) { */
  160|       |/*     auto *func = find_func_for_frame((uint32_t *)item.first); */
  161|       |/*     if (func != nullptr) { */
  162|       |/*       printf("%*c %.2f%% %s %s %li\n", indent, ' ', */
  163|       |/*              (double)item.second->cnt / cnt * 100.0, func->name.c_str(), */
  164|       |/*              ins_names[INS_OP(*(uint32_t *)item.first)], */
  165|       |/*              (uint32_t *)item.first - (func->code).data()); */
  166|       |/*     } else { */
  167|       |/*       printf("%*cCan't find func for frame %li\n", indent, ' ', item.first); */
  168|       |/*     } */
  169|       |/*     profiler_display_tree_node(item.second, indent + 5); */
  170|       |/*   } */
  171|       |/* } */
  172|       |
  173|      0|EXPORT void profiler_stop() [0;41m{[0m
  174|       |[0;41m[0m/*   tree tree_root; */[0;41m[0m
  175|      0|[0;41m  timer_delete(timerid);[0m
  176|      0|[0;41m  uint64_t tot = 0;[0m
  177|      0|[0;41m  uint64_t on_trace = 0;[0m
  178|      0|[0;41m  uint64_t on_gc = 0;[0m
  179|       |[0;41m[0m[0;41m[0m
  180|      0|[0;41m  printf("Timer called %li times\n", cnt);[0m
  181|      0|[0;41m  [0m[0;41mauto[0m[0;41m *s = samples;[0m
  182|      [0;35m0[0m|[0;41m  while ([0m[0;41ms != [0m[0;41mnullptr[0m[0;41m) [0m[0;41m{[0m
  183|       |[0;41m[0m/*     tree *cur_tree = &tree_root; */
  184|       |/*     for (int i = s->stack_sz - 1; i >= 0; i--) { */
  185|       |/*       auto frame = s->stack[i]; */
  186|       |/*       cur_tree = &cur_tree->next[frame]; */
  187|       |/*       cur_tree->cnt++; */
  188|       |/*     } */[0;41m[0m
  189|      0|[0;41m    tot++;[0m
  190|      [0;35m0[0m|[0;41m    if ([0m[0;41ms->in_jit[0m[0;41m) [0m[0;41m{[0m
  191|      0|[0;41m      on_trace++;[0m
  192|      0|[0;41m    }[0m[0;41m[0m
  193|      [0;35m0[0m|[0;41m    if ([0m[0;41ms->in_gc[0m[0;41m) [0m[0;41m{[0m
  194|      0|[0;41m      on_gc++;[0m
  195|      0|[0;41m    }[0m[0;41m[0m
  196|      0|[0;41m    s = s->next;[0m
  197|      0|[0;41m  }[0m
  198|       |[0;41m[0m[0;41m[0m
  199|      0|[0;41m  printf("On-trace: %.02f%%\n", (double)on_trace / (double)tot * 100.0);[0m
  200|      0|[0;41m  printf("In-gc: %.02f%%\n", (double)on_gc / (double)tot * 100.0);[0m
  201|      0|[0;41m  printf("VM: %.02f%%\n", 100.0-((double)(on_gc + on_trace) / (double)tot * 100.0));[0m
  202|       |[0;41m[0m
  203|       |/*   profiler_display_tree_node(&tree_root, 0); */[0;41m[0m
  204|      0|[0;41m}[0m
  205|       |

[0;36m/home/davejwatson/myprojects/boom/readbc.c:
[0m    1|       |// Copyright 2023 Dave Watson
    2|       |
    3|       |#include "readbc.h"
    4|       |
    5|       |#include <assert.h> // for assert
    6|       |#include <stdint.h> // for uint64_t
    7|       |#include <stdio.h>  // for fread, printf, FILE, fclose, fmemopen, fopen
    8|       |#include <stdlib.h> // for exit, realloc
    9|       |#include <string.h> // for memset
   10|       |
   11|       |#include "bytecode.h"     // for bcfunc, CODE_D, INS_A, INS_D, INS_OP
   12|       |#include "gc.h"           // for GC_malloc, GC_pop_root, GC_push_root
   13|       |#include "opcodes.h"      // for GGET, GSET, KFUNC, KONST
   14|       |#include "symbol_table.h" // for symbol_table_find, symbol_table_insert
   15|       |#include "third-party/stb_ds.h"
   16|       |#include "types.h" // for string_s, PTR_TAG, SYMBOL_TAG, cons_s, symbol
   17|       |#include "vm.h"    // for funcs
   18|       |#include "defs.h"
   19|       |
   20|  1.93M|#define auto __auto_type
   21|  78.9k|#define nullptr NULL
   22|       |
   23|       |long *const_table = nullptr;
   24|       |unsigned long const_table_sz = 0;
   25|       |long *symbols = NULL; // TODO not a global, or use a string instead
   26|       |
   27|       |// TODO GC safety
   28|   285k|long read_const(FILE *fptr) {
   29|   285k|  long val;
   30|   [0;35m285k[0m|  if (fread(&val, 8, 1, fptr) != 1) [0;41m{[0m
   31|      0|[0;41m    printf("Error: Could not read consts\n");[0m
   32|      0|[0;41m    exit(-1);[0m
   33|      0|[0;41m  }[0m
   34|   [0;35m285k[0m|  auto type = val & TAG_MASK;
   35|   [0;35m285k[0m|  if (type == SYMBOL_TAG) {
   36|  94.7k|    unsigned long num = val >> 3;
   37|  [0;35m94.7k[0m|    if (num < arrlen(symbols)) {
   38|  54.6k|      val = symbols[num];
   39|  54.6k|    } else {
   40|       |      // It's a new symbol in this bc file
   41|  40.0k|      long len;
   42|  40.0k|      fread(&len, 8, 1, fptr);
   43|       |      // TODO GC symbol table
   44|  40.0k|      auto *str = (string_s *)GC_malloc(16 + 1 + len);
   45|  40.0k|      str->type = STRING_TAG;
   46|  40.0k|      str->len = len << 3;
   47|  40.0k|      str->str[len] = '\0';
   48|  40.0k|      fread(str->str, 1, len, fptr);
   49|       |
   50|       |      // Try to see if it already exists
   51|  40.0k|      auto *res = symbol_table_find(str);
   52|  [0;35m40.0k[0m|      if (res == nullptr) {
   53|  35.1k|        long str_save = (long)str + PTR_TAG;
   54|  35.1k|        GC_push_root(&str_save);
   55|       |        // TODO GC symbol table
   56|  35.1k|        auto *sym = (symbol *)GC_malloc(sizeof(symbol));
   57|       |
   58|  35.1k|        GC_pop_root(&str_save);
   59|  35.1k|        str = (string_s *)(str_save - PTR_TAG);
   60|       |
   61|  35.1k|        sym->type = SYMBOL_TAG;
   62|  35.1k|        sym->name = (long)str + PTR_TAG;
   63|  35.1k|        sym->val = UNDEFINED_TAG;
   64|  35.1k|        symbol_table_insert(sym);
   65|  35.1k|        val = (long)sym | SYMBOL_TAG;
   66|  35.1k|        arrput(symbols, val);
   67|  35.1k|      } else {
   68|  4.97k|        val = (long)res + SYMBOL_TAG;
   69|  4.97k|        arrput(symbols, val);
   70|  4.97k|        return val;
   71|  4.97k|      }
   72|  40.0k|    }
   73|   [0;35m190k[0m|  } else if (type == LITERAL_TAG || type == FIXNUM_TAG) {
   74|   [0;35m134k[0m|  } else if (type == FLONUM_TAG) {
   75|  7.01k|    auto *f = (flonum_s *)GC_malloc(sizeof(flonum_s));
   76|  7.01k|    assert(!((long)f & TAG_MASK));
   77|  7.01k|    fread(&f->x, 8, 1, fptr);
   78|  7.01k|    f->type = FLONUM_TAG;
   79|  7.01k|    val = (long)f | FLONUM_TAG;
   80|   [0;35m127k[0m|  } else if (type == CONS_TAG) {
   81|   115k|    auto ca = read_const(fptr);
   82|   115k|    GC_push_root(&ca);
   83|   115k|    auto cb = read_const(fptr);
   84|   115k|    GC_push_root(&cb);
   85|       |
   86|   115k|    auto *c = (cons_s *)GC_malloc(sizeof(cons_s));
   87|   115k|    c->type = CONS_TAG;
   88|   115k|    c->a = ca;
   89|   115k|    c->b = cb;
   90|   115k|    GC_pop_root(&cb);
   91|   115k|    GC_pop_root(&ca);
   92|       |
   93|   115k|    val = (long)c | CONS_TAG;
   94|   [0;35m115k[0m|  } else if (type == PTR_TAG) {
   95|  12.0k|    long ptrtype;
   96|  12.0k|    fread(&ptrtype, 8, 1, fptr);
   97|  [0;35m12.0k[0m|    if (ptrtype == STRING_TAG) {
   98|  9.93k|      long len;
   99|  9.93k|      fread(&len, 8, 1, fptr);
  100|  9.93k|      auto *str = (string_s *)GC_malloc(16 + len + 1);
  101|  9.93k|      str->type = ptrtype;
  102|  9.93k|      str->len = len << 3;
  103|  9.93k|      fread(&str->str, 1, len, fptr);
  104|  9.93k|      str->str[len] = '\0';
  105|  9.93k|      val = (long)str | PTR_TAG;
  106|  [0;35m9.93k[0m|    } else if (ptrtype == VECTOR_TAG) {
  107|  2.11k|      long len;
  108|  2.11k|      fread(&len, 8, 1, fptr);
  109|       |
  110|  2.11k|      long vals[len]; // VLA
  111|  [0;35m11.3k[0m|      for (long i = 0; i < len; i++) {
  112|  9.27k|        vals[i] = read_const(fptr);
  113|  9.27k|        GC_push_root(&vals[i]);
  114|  9.27k|      }
  115|       |
  116|  2.11k|      auto *v = (vector_s *)GC_malloc(16 + len * sizeof(long));
  117|  2.11k|      v->type = ptrtype;
  118|  2.11k|      v->len = len << 3;
  119|  [0;35m11.3k[0m|      for (long i = len - 1; i >= 0; i--) {
  120|  9.27k|        v->v[i] = vals[i];
  121|  9.27k|        GC_pop_root(&vals[i]);
  122|  9.27k|      }
  123|  2.11k|      val = (long)v | PTR_TAG;
  124|  2.11k|    } else [0;41m{[0m
  125|      0|[0;41m      printf("Unknown boxed type:%lx\\n", ptrtype);[0m
  126|      0|[0;41m      exit(-1);[0m
  127|      0|[0;41m    }[0m
  128|  12.0k|  } else [0;41m{[0m
  129|      0|[0;41m    printf("Unknown deserialize tag %lx\n", val);[0m
  130|      0|[0;41m    exit(-1);[0m
  131|      0|[0;41m  }[0m
  132|   280k|  return val;
  133|   285k|}
  134|       |
  135|    112|bcfunc *readbc(FILE *fptr) {
  136|    112|  unsigned long const_offset = const_table_sz;
  137|    112|  arrfree(symbols);
  138|       |
  139|    [0;35m112[0m|  if (fptr == nullptr) {
  140|      1|    printf("Could not open bc\n");
  141|      1|    exit(-1);
  142|      1|  }
  143|       |  // Read header
  144|    111|  unsigned int num;
  145|    111|  fread(&num, 4, 1, fptr);
  146|       |  // printf("%.4s\n", (char *)&num);
  147|    [0;35m111[0m|  if (num != 0x4d4f4f42) [0;41m{ // MAGIC[0m
  148|      0|[0;41m    printf("Error: not a boom bitcode\n");[0m
  149|      0|[0;41m    exit(-1);[0m
  150|      0|[0;41m  }[0m
  151|    111|  unsigned int version;
  152|    111|  fread(&version, 4, 1, fptr);
  153|    [0;35m111[0m|  if (version != 0) [0;41m{[0m
  154|      0|[0;41m    printf("Invalid bitcode version: %i\n", version);[0m
  155|      0|[0;41m    exit(-1);[0m
  156|      0|[0;41m  }[0m
  157|       |  // printf("%i\n", version);
  158|       |
  159|       |  // Read constant table
  160|    111|  unsigned int const_count;
  161|    111|  fread(&const_count, 4, 1, fptr);
  162|       |  // printf("constsize %i \n", const_count);
  163|    111|  const_table =
  164|    111|      (long *)realloc(const_table, (const_count + const_offset) * sizeof(long));
  165|       |  // Memset new entries in case we get GC during file read.
  166|    111|  memset(&const_table[const_table_sz], 0, sizeof(long) * const_count);
  167|    111|  const_table_sz += const_count;
  168|    [0;35m111[0m|  if (const_table_sz >= 65536) [0;41m{[0m
  169|      0|[0;41m    printf("ERROR const table too big! %li\n", const_table_sz);[0m
  170|      0|[0;41m    exit(-1);[0m
  171|      0|[0;41m  }[0m
  172|  [0;35m45.9k[0m|  for (unsigned j = 0; j < const_count; j++) {
  173|  45.8k|    const_table[j + const_offset] = read_const(fptr);
  174|       |    // printf("%i: ", j);
  175|       |    // print_obj(const_table[j]);
  176|       |    // printf("\n");
  177|  45.8k|  }
  178|       |
  179|       |  // Read functions
  180|    111|  unsigned int bccount;
  181|    111|  fread(&bccount, 4, 1, fptr);
  182|    111|  bcfunc *start_func = nullptr;
  183|    111|  unsigned func_offset = arrlen(funcs);
  184|  [0;35m38.7k[0m|  for (unsigned i = 0; i < bccount; i++) {
  185|  38.5k|    unsigned int name_count;
  186|  38.5k|    fread(&name_count, 4, 1, fptr);
  187|       |    // printf("Name size %i\n", name_count);
  188|  38.5k|    char *name = (char *)malloc(name_count + 1);
  189|  38.5k|    assert(name);
  190|  38.5k|    name[name_count] = '\0';
  191|  38.5k|    fread(name, 1, name_count, fptr);
  192|       |
  193|  38.5k|    unsigned int code_count;
  194|  38.5k|    fread(&code_count, 4, 1, fptr);
  195|       |
  196|  38.5k|    auto *f =
  197|  38.5k|        (bcfunc *)malloc(sizeof(bcfunc) + sizeof(unsigned int) * code_count);
  198|  [0;35m38.5k[0m|    if (start_func == nullptr) {
  199|    111|      start_func = f;
  200|    111|    }
  201|  [0;35m38.5k[0m|    if ((((long)f) & 0x7) != 0) [0;41m{[0m
  202|      0|[0;41m      printf("Alloc fail\n");[0m
  203|      0|[0;41m      exit(-1);[0m
  204|      0|[0;41m    }[0m
  205|  38.5k|    f->name = name;
  206|  38.5k|    f->codelen = code_count;
  207|  38.5k|    f->poly_cnt = 0;
  208|       |
  209|       |    // printf("%i: code %i\n", i, code_count);
  210|  [0;35m1.13M[0m|    for (unsigned j = 0; j < code_count; j++) {
  211|  1.09M|      fread(&f->code[j], 4, 1, fptr);
  212|       |      // Need to update anything pointing to global const_table
  213|  [0;35m1.09M[0m|      auto op = INS_OP(f->code[j]);
  214|  [0;35m1.09M[0m|      if (op == GGET || op == GSET || op == KONST) {
  215|   215k|        f->code[j] =
  216|   215k|            CODE_D(op, INS_A(f->code[j]), INS_D(f->code[j]) + const_offset);
  217|   [0;35m876k[0m|      } else if (op == KFUNC) {
  218|  38.4k|        f->code[j] =
  219|  38.4k|            CODE_D(op, INS_A(f->code[j]), INS_D(f->code[j]) + func_offset);
  220|  38.4k|      }
  221|       |      // unsigned int code = f->code[j];
  222|       |      //  printf("%i code: %s %i %i %i BC: %i\n", j, ins_names[INS_OP(code)],
  223|       |      //         INS_A(code), INS_B(code), INS_C(code), INS_BC(code));
  224|  1.09M|    }
  225|  38.5k|    arrput(funcs, f);
  226|  38.5k|  }
  227|       |
  228|    111|  fclose(fptr);
  229|    111|  return start_func;
  230|    111|}
  231|       |
  232|     56|EXPORT bcfunc *readbc_image(unsigned char *mem, unsigned int len) {
  233|     56|  FILE *fptr = fmemopen(mem, len, "rb");
  234|     56|  return readbc(fptr);
  235|     56|}
  236|       |
  237|     56|EXPORT bcfunc *readbc_file(const char *filename) {
  238|     56|  FILE *fptr;
  239|     56|  fptr = fopen(filename, "rb");
  240|     56|  return readbc(fptr);
  241|     56|}
  242|       |
  243|     55|EXPORT void free_script() {
  244|  [0;35m38.0k[0m|  for (uint64_t i = 0; i < arrlen(funcs); i++) {
  245|  37.9k|    auto func = funcs[i];
  246|  37.9k|    free(func->name);
  247|  37.9k|    func->name = NULL;
  248|  37.9k|    free(func);
  249|  37.9k|  }
  250|     55|  arrfree(funcs);
  251|       |  // TODO symbol_table
  252|     55|  free(const_table);
  253|     55|  const_table = NULL;
  254|     55|  symbol_table_clear();
  255|     55|}
  256|       |
  257|       |extern unsigned char bootstrap_scm_bc[];
  258|       |extern unsigned int bootstrap_scm_bc_len;
  259|       |
  260|     56|EXPORT void load_bootstrap() {
  261|     [0;35m56[0m|  if (bootstrap_scm_bc_len > 0) {
  262|     56|    auto *start_func = readbc_image(bootstrap_scm_bc, bootstrap_scm_bc_len);
  263|       |    //printf("Running boot image...\n");
  264|     56|    run(start_func, 0, nullptr);
  265|     56|  }
  266|     56|}

[0;36m/home/davejwatson/myprojects/boom/record.c:
[0m    1|       |#include "record.h"
    2|       |#include "asm_x64.h"  // for REG_NONE, asm_jit, reg_names
    3|       |#include "bytecode.h" // for INS_A, INS_B, INS_OP, INS_C, INS_D, bcfunc
    4|       |#include "ir.h"       // for ir_ins, trace_s, ir_ins_op, ir_ins::(anonymous...
    5|       |#include "opcodes.h"
    6|       |#include "snap.h" // for add_snap, snap_replay
    7|       |#include "third-party/stb_ds.h"
    8|       |#include "types.h"  // for CONS_TAG, FALSE_REP, SYMBOL_TAG, symbol, CLOSU...
    9|       |#include "vm.h"     // for find_func_for_frame, hotmap_mask, hotmap_sz
   10|       |#include "defs.h"
   11|       |#include <assert.h> // for assert
   12|       |#include <stdbool.h>
   13|       |#include <stdint.h> // for uint32_t
   14|       |#include <stdio.h>  // for printf
   15|       |#include <stdlib.h> // for exit
   16|       |#include <string.h> // for NULL, memmove, size_t
   17|       |
   18|  3.06M|#define auto __auto_type
   19|  1.25M|#define nullptr NULL
   20|       |
   21|       |extern bool verbose;
   22|       |
   23|       |typedef struct {
   24|       |  uint32_t *pc;
   25|       |  uint32_t cnt;
   26|       |} blacklist_entry;
   27|       |
   28|  12.6k|#define BLACKLIST_MAX 64
   29|    621|#define BLACKLIST_SZ 512
   30|       |
   31|       |blacklist_entry blacklist[BLACKLIST_SZ];
   32|       |uint32_t blacklist_slot = 0;
   33|       |
   34|       |void opt_loop(trace_s *trace, int *regs);
   35|       |
   36|       |unsigned int *pc_start;
   37|       |unsigned int instr_count;
   38|       |int depth = 0;
   39|       |
   40|       |long func;
   41|       |int regs_list[257];
   42|       |int *regs = &regs_list[1];
   43|       |snap_s *side_exit = nullptr;
   44|       |static trace_s *parent = nullptr;
   45|       |static uint8_t unroll = 0;
   46|       |
   47|       |unsigned int **downrec = NULL;
   48|       |
   49|       |typedef enum trace_state_e {
   50|       |  OFF = 0,
   51|       |  START,
   52|       |  TRACING,
   53|       |} trace_state_e;
   54|       |
   55|       |trace_state_e trace_state = OFF;
   56|       |trace_s *trace = nullptr;
   57|       |trace_s **traces = nullptr;
   58|       |
   59|       |unsigned int *patchpc = nullptr;
   60|       |unsigned int patchold;
   61|       |
   62|  13.2k|void penalty_pc(uint32_t *pc) {
   63|  13.2k|  uint32_t i = 0;
   64|   [0;35m105k[0m|  for (; i < blacklist_slot; i++) {
   65|   [0;35m104k[0m|    if (blacklist[i].pc == pc) {
   66|  [0;35m12.6k[0m|      if (blacklist[i].cnt >= BLACKLIST_MAX) {
   67|    [0;35m161[0m|        if (verbose) [0;41m{[0m
   68|      0|[0;41m          printf("Blacklist pc %p\n", pc);[0m
   69|      0|[0;41m        }[0m
   70|    [0;35m161[0m|        if (INS_OP(*pc) == FUNC) {
   71|    106|          *pc = ((*pc) & ~0xff) + IFUNC;
   72|    [0;35m106[0m|        } else if (INS_OP(*pc) == FUNCV) [0;41m{[0m
   73|      0|[0;41m          *pc = ((*pc) & ~0xff) + IFUNCV;[0m
   74|     [0;35m55[0m|[0;41m        }[0m else if (INS_OP(*pc) == CLFUNC) {
   75|     14|          *pc = ((*pc) & ~0xff) + ICLFUNC;
   76|     [0;35m41[0m|        } else if (INS_OP(*pc) == CLFUNCV) {
   77|      3|          *pc = ((*pc) & ~0xff) + ICLFUNCV;
   78|     [0;35m38[0m|        } else if (INS_OP(*pc) == LOOP) {
   79|     37|          *pc = ((*pc) & ~0xff) + ILOOP;
   80|     [0;35m37[0m|        } else if (INS_OP(*pc) == RET1) {
   81|      1|          *pc = ((*pc) & ~0xff) + IRET1;
   82|      1|        } else [0;41m{[0m
   83|      0|[0;41m          printf("Could not blacklist %s\n", ins_names[[0m[0;41mINS_OP[0m[0;41m(*pc)]);[0m
   84|      0|[0;41m          exit(-1);[0m
   85|      0|[0;41m        }[0m
   86|    161|        int64_t next = i + 1;
   87|  [0;35m6.39k[0m|        while (next < blacklist_slot) {
   88|  6.22k|          blacklist_entry tmp = blacklist[next];
   89|  6.22k|          blacklist[next - 1] = blacklist[next];
   90|  6.22k|          blacklist[next] = tmp;
   91|  6.22k|          next++;
   92|  6.22k|        }
   93|    161|        blacklist_slot--;
   94|  12.4k|      } else {
   95|  12.4k|        blacklist[i].cnt++;
   96|       |        // printf("Blacklist cnt now %i slot %i sz %i\n", blacklist[i].cnt, i,
   97|       |        // blacklist_slot);
   98|  12.4k|        int64_t prev = (int64_t)i - 1;
   99|  [0;35m33.2k[0m|        while (prev >= 0 && blacklist[prev].cnt <= blacklist[prev + 1].cnt) {
  100|  20.8k|          blacklist_entry tmp = blacklist[prev];
  101|  20.8k|          blacklist[prev] = blacklist[prev + 1];
  102|  20.8k|          blacklist[prev + 1] = tmp;
  103|  20.8k|          prev--;
  104|  20.8k|        }
  105|  12.4k|      }
  106|  12.6k|      return;
  107|  12.6k|    }
  108|   104k|  }
  109|       |
  110|       |  // Didn't find it, add it to the list.
  111|    [0;35m621[0m|  if (i < BLACKLIST_SZ) {
  112|    621|    blacklist[i].pc = pc;
  113|    621|    blacklist[i].cnt = 1;
  114|    621|    blacklist_slot++;
  115|    621|  } else [0;41m{[0m
  116|      0|[0;41m    printf("BLACKLIST EVICT\n");[0m
  117|      0|[0;41m    blacklist[[0m[0;41mBLACKLIST_SZ[0m[0;41m - 1].pc = pc;[0m
  118|      0|[0;41m    blacklist[[0m[0;41mBLACKLIST_SZ[0m[0;41m - 1].cnt = 1;[0m
  119|      0|[0;41m  }[0m
  120|    621|}
  121|       |
  122|  1.04M|void pendpatch() {
  123|  [0;35m1.04M[0m|  if (patchpc != nullptr) {
  124|       |    // printf("PENDPACTCH\n");
  125|  62.4k|    *patchpc = patchold;
  126|  62.4k|    patchpc = nullptr;
  127|  62.4k|  }
  128|  1.04M|}
  129|       |
  130|      0|void print_const_or_val(int i, trace_s *ctrace) [0;41m{[0m
  131|      [0;35m0[0m|[0;41m  if ([0m[0;41m(i & [0m[0;41mIR_CONST_BIAS[0m[0;41m) != 0) [0m[0;41m{[0m
  132|      0|[0;41m    long c = ctrace->consts[i - [0m[0;41mIR_CONST_BIAS[0m[0;41m];[0m
  133|      0|[0;41m    int type = (int)(c & 0x7);[0m
  134|      [0;35m0[0m|[0;41m    if ([0m[0;41mtype == 0[0m[0;41m) [0m[0;41m{[0m
  135|      0|[0;41m      printf("\e[1;35m%li\e[m", c >> 3);[0m
  136|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mtype == [0m[0;41mCLOSURE_TAG[0m[0;41m) [0m[0;41m{[0m
  137|      0|[0;41m      printf("\e[1;31m<closure>\e[m");[0m
  138|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mc == [0m[0;41mFALSE_REP[0m[0;41m) [0m[0;41m{[0m
  139|      0|[0;41m      printf("\e[1;35m#f\e[m");[0m
  140|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mc == [0m[0;41mTRUE_REP[0m[0;41m) [0m[0;41m{[0m
  141|      0|[0;41m      printf("\e[1;35m#t\e[m");[0m
  142|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mc == [0m[0;41mNIL_TAG[0m[0;41m) [0m[0;41m{[0m
  143|      0|[0;41m      printf("\e[1;35mnil\e[m");[0m
  144|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mtype == [0m[0;41mCONS_TAG[0m[0;41m) [0m[0;41m{[0m
  145|      0|[0;41m      printf("\e[1;35mcons\e[m");[0m
  146|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mtype == [0m[0;41mFLONUM_TAG[0m[0;41m) [0m[0;41m{[0m
  147|      0|[0;41m      printf("\e[1;35m%f\e[m", ((flonum_s *)c - [0m[0;41mFLONUM_TAG[0m[0;41m)->x);[0m
  148|      [0;35m0[0m|[0;41m    } else [0m[0;41mif ([0m[0;41m(c & [0m[0;41mIMMEDIATE_MASK[0m[0;41m) == [0m[0;41mCHAR_TAG[0m[0;41m) [0m[0;41m{[0m
  149|      0|[0;41m      printf("'%c'", (char)(c >> 8));[0m
  150|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41m(c & [0m[0;41mIMMEDIATE_MASK[0m[0;41m) == [0m[0;41mEOF_TAG[0m[0;41m) [0m[0;41m{[0m
  151|      0|[0;41m      printf("eof");[0m
  152|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41m(c & [0m[0;41mIMMEDIATE_MASK[0m[0;41m) == [0m[0;41mNIL_TAG[0m[0;41m) [0m[0;41m{[0m
  153|      0|[0;41m      printf("nil");[0m
  154|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mtype == [0m[0;41mSYMBOL_TAG[0m[0;41m) [0m[0;41m{[0m
  155|      [0;35m0[0m|[0;41m      string_s* sym_name = (string_s*)(((symbol *)(c-[0m[0;41mSYMBOL_TAG[0m[0;41m))->name - [0m[0;41mPTR_TAG[0m[0;41m);[0m
  156|      0|[0;41m      printf("\e[1;35m%s\e[m", sym_name->str);[0m
  157|      [0;35m0[0m|[0;41m    } else [0m[0;41mif ([0m[0;41mtype == [0m[0;41mPTR_TAG[0m[0;41m) [0m[0;41m{[0m
  158|      [0;35m0[0m|[0;41m      [0m[0;41mauto[0m[0;41m type2 = ((long*)(c - [0m[0;41mPTR_TAG[0m[0;41m))[0] & 0xff;[0m
  159|      [0;35m0[0m|[0;41m      if ([0m[0;41mtype2 == [0m[0;41mVECTOR_TAG[0m[0;41m) [0m[0;41m{[0m
  160|      0|[0;41m	printf("vector");[0m
  161|      [0;35m0[0m|[0;41m      }[0m[0;41m else  [0m[0;41mif ([0m[0;41mtype2 == [0m[0;41mSTRING_TAG[0m[0;41m) [0m[0;41m{[0m
  162|      0|[0;41m	printf("str");[0m
  163|      [0;35m0[0m|[0;41m      }[0m[0;41m else  [0m[0;41mif ([0m[0;41mtype2 == [0m[0;41mPORT_TAG[0m[0;41m) [0m[0;41m{[0m
  164|      0|[0;41m	printf("port");[0m
  165|      0|[0;41m      }[0m[0;41m else [0m[0;41m{[0m
  166|      0|[0;41m	printf("ptr");[0m
  167|      0|[0;41m      }[0m[0;41m[0m
  168|      [0;35m0[0m|[0;41m    } else [0m[0;41mif ([0m[0;41mtype == [0m[0;41mLITERAL_TAG[0m[0;41m) [0m[0;41m{[0m
  169|      0|[0;41m      printf("frame");[0m
  170|      0|[0;41m    }[0m[0;41m else [0m[0;41m{[0m
  171|      0|[0;41m      assert(false);[0m
  172|      0|[0;41m    }[0m[0;41m[0m
  173|      0|[0;41m  } else [0m[0;41m{[0m
  174|      0|[0;41m    printf("%04d", i);[0m
  175|      0|[0;41m  }[0m[0;41m[0m
  176|      0|[0;41m}[0m
  177|       |
  178|      0|void dump_trace(trace_s *ctrace) [0;41m{[0m
  179|      0|[0;41m  unsigned long cur_snap = 0;[0m
  180|      [0;35m0[0m|[0;41m  for (size_t i = 0; [0m[0;41mi < [0m[0;41marrlen[0m[0;41m(ctrace->ops) + 1 /* extra snap */; [0m[0;41mi++[0m[0;41m) [0m[0;41m{[0m
  181|       |[0;41m[0m    // Print any snap[0;41m[0m
  182|      [0;35m0[0m|[0;41m    while ([0m[0;41m(cur_snap < [0m[0;41marrlen[0m[0;41m(ctrace->snaps)) &&[0m
  183|      [0;35m0[0m|[0;41m           [0m[0;41mctrace->snaps[cur_snap].ir == i[0m[0;41m) [0m[0;41m{[0m
  184|       |[0;41m[0m[0;41m[0m
  185|      0|[0;41m      [0m[0;41mauto[0m[0;41m snap = &ctrace->snaps[cur_snap];[0m
  186|      0|[0;41m      printf("SNAP[ir=%i pc=%lx off=%i", snap->ir, (long)snap->pc,[0m
  187|      0|[0;41m             snap->offset);[0m
  188|      [0;35m0[0m|[0;41m      for (uint64_t j = 0; [0m[0;41mj < [0m[0;41marrlen[0m[0;41m(snap->slots); [0m[0;41mj++[0m[0;41m) [0m[0;41m{[0m
  189|      0|[0;41m        [0m[0;41mauto[0m[0;41m entry = &snap->slots[j];[0m
  190|      0|[0;41m        printf(" %i=", entry->slot);[0m
  191|      0|[0;41m        print_const_or_val(entry->val, ctrace);[0m
  192|      0|[0;41m      }[0m
  193|      0|[0;41m      printf("]\n");[0m
  194|      0|[0;41m      cur_snap++;[0m
  195|      0|[0;41m    }[0m
  196|      [0;35m0[0m|[0;41m    if ([0m[0;41mi == [0m[0;41marrlen[0m[0;41m(ctrace->ops)) [0m[0;41m{[0m
  197|      0|[0;41m      break;[0m
  198|      0|[0;41m    }[0m[0;41m[0m
  199|       |
  200|      [0;35m0[0m|    [0;41mauto[0m[0;41m op = ctrace->ops[i];[0m
  201|      0|[0;41m    printf("%04zu %s ", i, reg_names[op.reg]);[0m
  202|       |[0;41m[0m[0;41m[0m
  203|      [0;35m0[0m|[0;41m    if ([0m[0;41mop.slot != [0m[0;41mSLOT_NONE[0m[0;41m) [0m[0;41m{[0m
  204|      0|[0;41m      printf("\e[1;31m[%i]\e[m ", op.slot);[0m
  205|      0|[0;41m    }[0m[0;41m else [0m[0;41m{[0m
  206|      0|[0;41m      printf("    ");[0m
  207|      0|[0;41m    }[0m[0;41m[0m
  208|      [0;35m0[0m|[0;41m    printf("%c\t", [0m[0;41m(op.type & [0m[0;41mIR_INS_TYPE_GUARD[0m[0;41m) != 0 ? [0m[0;41m'>'[0m[0;41m : [0m[0;41m' '[0m[0;41m);[0m
  209|      [0;35m0[0m|[0;41m    [0m[0;41mauto[0m[0;41m t = op.type & ~[0m[0;41mIR_INS_TYPE_GUARD[0m[0;41m;[0m
  210|      [0;35m0[0m|[0;41m    if ([0m[0;41mt == [0m[0;41mFIXNUM_TAG[0m[0;41m) [0m[0;41m{[0m
  211|      0|[0;41m      printf("\e[1;35mfix \e[m ");[0m
  212|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mt == [0m[0;41mCLOSURE_TAG[0m[0;41m) [0m[0;41m{[0m
  213|      0|[0;41m      printf("\e[1;31mclo \e[m ");[0m
  214|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mt == [0m[0;41mCONS_TAG[0m[0;41m) [0m[0;41m{[0m
  215|      0|[0;41m      printf("\e[1;34mcons\e[m ");[0m
  216|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mt == [0m[0;41mFLONUM_TAG[0m[0;41m) [0m[0;41m{[0m
  217|      0|[0;41m      printf("\e[1;34mflo \e[m ");[0m
  218|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mt == [0m[0;41mSYMBOL_TAG[0m[0;41m) [0m[0;41m{[0m
  219|      0|[0;41m      printf("\e[1;34msym \e[m ");[0m
  220|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41m(op.type & ~[0m[0;41mIR_INS_TYPE_GUARD[0m[0;41m) == [0m[0;41mUNDEFINED_TAG[0m[0;41m) [0m[0;41m{[0m
  221|      0|[0;41m      printf("     ");[0m
  222|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mt == [0m[0;41mBOOL_TAG[0m[0;41m) [0m[0;41m{[0m
  223|      0|[0;41m      printf("\e[1;34mbool\e[m ");[0m
  224|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mt == [0m[0;41mNIL_TAG[0m[0;41m) [0m[0;41m{[0m
  225|      0|[0;41m      printf("\e[1;34mnil \e[m ");[0m
  226|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mt == [0m[0;41mEOF_TAG[0m[0;41m) [0m[0;41m{[0m
  227|      0|[0;41m      printf("\e[1;34meof \e[m ");[0m
  228|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mt == [0m[0;41mLITERAL_TAG[0m[0;41m) [0m[0;41m{[0m
  229|      0|[0;41m      printf("\e[1;34mlit \e[m ");[0m
  230|      0|[0;41m      assert(false);[0m
  231|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mt == [0m[0;41mSTRING_TAG[0m[0;41m) [0m[0;41m{[0m
  232|      0|[0;41m      printf("\e[1;34mstr \e[m ");[0m
  233|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mt == [0m[0;41mVECTOR_TAG[0m[0;41m) [0m[0;41m{[0m
  234|      0|[0;41m      printf("\e[1;34mvec \e[m ");[0m
  235|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mt == [0m[0;41mPORT_TAG[0m[0;41m) [0m[0;41m{[0m
  236|      0|[0;41m      printf("\e[1;34mport\e[m ");[0m
  237|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mt == [0m[0;41mBOX_TAG[0m[0;41m) [0m[0;41m{[0m
  238|      0|[0;41m      printf("\e[1;34mbox \e[m ");[0m
  239|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mt == [0m[0;41mCONT_TAG[0m[0;41m) [0m[0;41m{[0m
  240|      0|[0;41m      printf("\e[1;34mcont\e[m ");[0m
  241|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mt == [0m[0;41mPTR_TAG[0m[0;41m) [0m[0;41m{[0m
  242|      0|[0;41m      printf("\e[1;34mptr \e[m ");[0m
  243|       |[0;41m[0m[0;41m[0m
  244|      [0;35m0[0m|[0;41m    } else [0m[0;41mif ([0m[0;41mt == [0m[0;41mCHAR_TAG[0m[0;41m) [0m[0;41m{[0m
  245|      0|[0;41m      printf("\e[1;34mchar\e[m ");[0m
  246|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mt == [0m[0;41mUNDEFINED_TAG[0m[0;41m) [0m[0;41m{[0m
  247|      0|[0;41m    }[0m[0;41m else [0m[0;41m{[0m
  248|       |[0;41m[0m      /* printf("UNKNOWN TAG %i\n", t); */
  249|       |      /* fflush(stdout); */[0;41m[0m
  250|      0|[0;41m      printf("\e[1;34mUNK \e[m ");[0m
  251|       |[0;41m[0m      /* assert(false); */[0;41m[0m
  252|      0|[0;41m    }[0m
  253|      0|[0;41m    [0m[0;41mprintf("%s ", ir_names[(int)op.op]);[0m
  254|      0|[0;41m    switch (op.op) [0m[0;41m{[0m
  255|      0|    [0;41mcase IR_FLUSH:[0m
  256|      0|[0;41m      break[0m[0;41m;[0m
  257|      0|    [0;41mcase IR_KFIX:[0m
  258|      0|[0;41m    [0m[0;41mcase IR_ARG:[0m
  259|      0|[0;41m    [0m[0;41mcase IR_LOAD:[0m
  260|      0|[0;41m    [0m[0;41mcase IR_CHGTYPE:[0m
  261|      0|[0;41m    [0m[0;41mcase IR_SLOAD: {[0m
  262|      0|[0;41m      print_const_or_val(op.op1, ctrace);[0m
  263|      0|[0;41m      break[0m[0;41m;[0m
  264|      0|[0;41m    }[0m
  265|      0|[0;41m    [0m[0;41mcase IR_GGET: {[0m
  266|      [0;35m0[0m|[0;41m      [0m[0;41mauto[0m[0;41m *s = (symbol *)(ctrace->consts[op.op1 - [0m[0;41mIR_CONST_BIAS[0m[0;41m] - [0m[0;41mSYMBOL_TAG[0m[0;41m);[0m
  267|      0|[0;41m      string_s* sym_name = (string_s*)(s->name - [0m[0;41mPTR_TAG[0m[0;41m);[0m
  268|      0|[0;41m      printf("%s", sym_name->str);[0m
  269|      0|[0;41m      break;[0m
  270|      0|[0;41m    }[0m
  271|      0|[0;41m    [0m[0;41mcase IR_GSET: {[0m
  272|      [0;35m0[0m|[0;41m      [0m[0;41mauto[0m[0;41m *s = (symbol *)(ctrace->consts[op.op1 - [0m[0;41mIR_CONST_BIAS[0m[0;41m] - [0m[0;41mSYMBOL_TAG[0m[0;41m);[0m
  273|      0|[0;41m      string_s* sym_name = (string_s*)(s->name - [0m[0;41mPTR_TAG[0m[0;41m);[0m
  274|      0|[0;41m      printf("%s ", sym_name->str);[0m
  275|      0|[0;41m      print_const_or_val(op.op2, ctrace);[0m
  276|      0|[0;41m      break;[0m
  277|      0|[0;41m    }[0m
  278|      0|[0;41m    [0m[0;41mcase IR_ALLOC: {[0m
  279|      0|[0;41m      print_const_or_val(op.op1, ctrace);[0m
  280|      0|[0;41m      printf(" type %i", op.op2);[0m
  281|      0|[0;41m      break[0m[0;41m;[0m
  282|      0|[0;41m    }[0m
  283|      0|[0;41m    [0m[0;41mcase IR_RET:[0m
  284|      0|[0;41m    [0m[0;41mcase IR_PHI:[0m
  285|      0|[0;41m    [0m[0;41mcase IR_SUB:[0m
  286|      0|[0;41m    [0m[0;41mcase IR_ADD:[0m
  287|      0|[0;41m    [0m[0;41mcase IR_DIV:[0m
  288|      0|[0;41m    [0m[0;41mcase IR_MUL:[0m
  289|      0|[0;41m    [0m[0;41mcase IR_REM:[0m
  290|      0|[0;41m    [0m[0;41mcase IR_EQ:[0m
  291|      0|[0;41m    [0m[0;41mcase IR_NE:[0m
  292|      0|[0;41m    [0m[0;41mcase IR_GE:[0m
  293|      0|[0;41m    [0m[0;41mcase IR_LT:[0m
  294|      0|[0;41m    [0m[0;41mcase IR_GT:[0m
  295|      0|[0;41m    [0m[0;41mcase IR_LE:[0m
  296|      0|[0;41m    [0m[0;41mcase IR_STORE:[0m
  297|      0|[0;41m    [0m[0;41mcase IR_ABC:[0m
  298|      0|[0;41m    [0m[0;41mcase IR_VREF:[0m
  299|      0|[0;41m    [0m[0;41mcase IR_CALLXS:[0m
  300|      0|[0;41m    [0m[0;41mcase IR_CCRES:[0m
  301|      0|[0;41m    [0m[0;41mcase IR_CARG:[0m
  302|      0|[0;41m    [0m[0;41mcase IR_STRST:[0m
  303|      0|[0;41m    [0m[0;41mcase IR_STRLD:[0m
  304|      0|[0;41m    [0m[0;41mcase IR_AND:[0m
  305|      0|[0;41m    [0m[0;41mcase IR_STRREF: {[0m
  306|      0|[0;41m      print_const_or_val(op.op1, ctrace);[0m
  307|      0|[0;41m      printf(" ");[0m
  308|      0|[0;41m      print_const_or_val(op.op2, ctrace);[0m
  309|      0|[0;41m      break[0m[0;41m;[0m
  310|      0|[0;41m    }[0m
  311|      0|[0;41m    [0m[0;41mcase IR_SHR:[0m
  312|      0|[0;41m    [0m[0;41mcase IR_REF: {[0m
  313|      0|[0;41m      print_const_or_val(op.op1, ctrace);[0m
  314|      0|[0;41m      printf(" offset %i", op.op2);[0m
  315|      0|[0;41m      break[0m[0;41m;[0m
  316|      0|[0;41m    }[0m
  317|      0|[0;41m    [0m[0;41mcase IR_LOOP: {[0m
  318|      0|[0;41m      printf("----------------");[0m
  319|      0|[0;41m      break[0m[0;41m;[0m
  320|      0|[0;41m    }[0m
  321|      0|[0;41m    [0m[0;41mdefault:[0m
  322|      0|[0;41m      printf("Can't dump_trace ir type: %s\n", ir_names[(int)op.op]);[0m
  323|      0|[0;41m      exit(-1)[0m[0;41m;[0m
  324|      0|[0;41m    }[0m
  325|      0|[0;41m    [0m[0;41mprintf("\n");[0m
  326|      0|[0;41m  }[0m[0;41m[0m
  327|      0|[0;41m}[0m
  328|       |
  329|  12.2k|void record_side(trace_s *p, snap_s *side) {
  330|  12.2k|  parent = p;
  331|  12.2k|  side_exit = side;
  332|  12.2k|}
  333|       |
  334|       |void record_abort();
  335|  27.3k|void record_start(unsigned int *pc, long *frame) {
  336|  27.3k|  trace = malloc(sizeof(trace_s));
  337|  27.3k|  trace->ops = NULL;
  338|  27.3k|  trace->consts = NULL;
  339|  27.3k|  trace->relocs = NULL;
  340|  27.3k|  trace->snaps = NULL;
  341|  27.3k|  trace->link = -1;
  342|  27.3k|  trace->startpc = *pc;
  343|  27.3k|  trace->num = arrlen(traces);
  344|  27.3k|  trace->fn = NULL;
  345|  27.3k|  trace_state = START;
  346|  27.3k|  unroll = 0;
  347|  27.3k|  func = (long)find_func_for_frame(pc);
  348|  27.3k|  assert(func);
  349|  [0;35m27.3k[0m|  if (verbose) [0;41m{[0m
  350|      0|[0;41m    printf("Record start %i at %s func %s\n", trace->num,[0m
  351|      0|[0;41m           ins_names[[0m[0;41mINS_OP[0m[0;41m(*pc)], ((bcfunc *)func)->name);[0m
  352|      [0;35m0[0m|[0;41m    if ([0m[0;41mparent != [0m[0;41mnullptr[0m[0;41m) [0m[0;41m{[0m
  353|      0|[0;41m      printf("Parent %i\n", parent->num);[0m
  354|      0|[0;41m    }[0m[0;41m[0m
  355|      0|[0;41m  }[0m
  356|  27.3k|  pc_start = pc;
  357|  27.3k|  instr_count = 0;
  358|  27.3k|  depth = 0;
  359|  27.3k|  regs = &regs_list[1];
  360|  [0;35m7.05M[0m|  for (int i = 0; i < sizeof(regs_list) / sizeof(regs_list[0]); i++) {
  361|  7.03M|    regs_list[i] = -1;
  362|  7.03M|  }
  363|       |
  364|  [0;35m27.3k[0m|  if (side_exit != nullptr) {
  365|  12.2k|    snap_replay(&regs, side_exit, parent, trace, frame, &depth);
  366|  12.2k|  }
  367|  27.3k|  auto next_pc = pc;
  368|  [0;35m27.3k[0m|  if (INS_OP(*pc) == FUNC || INS_OP(*pc) == LOOP) {
  369|  13.3k|    next_pc = pc + 1;
  370|  13.3k|  }
  371|  [0;35m27.3k[0m|  if (INS_OP(*pc) == CLFUNC) {
  372|  1.03k|    next_pc = pc + 2;
  373|  1.03k|  }
  374|  27.3k|  add_snap(regs_list, (int)(regs - regs_list - 1), trace, next_pc, depth);
  375|  27.3k|}
  376|       |
  377|       |extern int joff;
  378|       |extern unsigned TRACE_MAX;
  379|       |
  380|  10.0k|void record_stop(unsigned int *pc, long *frame, int link) {
  381|  10.0k|  auto offset = regs - regs_list - 1;
  382|  10.0k|  add_snap(regs_list, (int)offset, trace, pc, depth);
  383|  [0;35m10.0k[0m|  if (link == (int)arrlen(traces) && offset == 0) {
  384|       |    // Attempt to loop-fiy it.
  385|       |    // opt_loop(trace, regs);
  386|    382|  }
  387|       |
  388|       |  // if (arrlen(trace->ops) <= 3) {
  389|       |  //   printf("Record abort: trace too small\n");
  390|       |  //   record_abort();
  391|       |  //   return;
  392|       |  // }
  393|       |
  394|  10.0k|  pendpatch();
  395|       |
  396|  [0;35m10.0k[0m|  if (side_exit != nullptr) {
  397|  8.11k|    side_exit->link = arrlen(traces);
  398|  8.11k|    if (verbose)
  399|      0|      [0;41mprintf("Hooking to parent trace\n")[0m;
  400|  8.11k|  } else {
  401|  [0;35m1.89k[0m|    auto op = INS_OP(*pc_start);
  402|  [0;35m1.89k[0m|      if (op != RET1 && op != LOOP) {
  403|  1.52k|	*pc_start = CODE_D(JFUNC, INS_A(*pc_start), arrlen(traces));
  404|  1.52k|	if (verbose)
  405|      0|	  [0;41mprintf("Installing JFUNC\n")[0m;
  406|  1.52k|      } else {
  407|    370|	*pc_start = CODE_D(JLOOP, 0, arrlen(traces));
  408|    370|	if (verbose)
  409|      0|	  [0;41mprintf("Installing JLOOP\n")[0m;
  410|    370|      }
  411|  1.89k|  }
  412|  10.0k|  if (verbose)
  413|      [0;35m0[0m|    [0;41mprintf("Installing trace %li\n", [0m[0;41marrlen[0m[0;41m(traces))[0m;
  414|       |
  415|  10.0k|  trace->link = link;
  416|  10.0k|  arrput(traces, trace);
  417|       |
  418|       |  //    dump_trace(trace);
  419|  10.0k|  asm_jit(trace, side_exit, parent);
  420|  [0;35m10.0k[0m|  if (verbose) [0;41m{[0m
  421|      0|[0;41m    dump_trace(trace);[0m
  422|      0|[0;41m  }[0m
  423|       |
  424|  10.0k|  trace_state = OFF;
  425|  10.0k|  side_exit = nullptr;
  426|  10.0k|  arrfree(downrec);
  427|  10.0k|  trace = nullptr;
  428|  10.0k|  parent = nullptr;
  429|       |  // joff = 1;
  430|  10.0k|}
  431|       |
  432|  17.3k|void record_abort() {
  433|  [0;35m17.3k[0m|  if (!parent) {
  434|  13.2k|    penalty_pc(pc_start);
  435|  13.2k|  }
  436|       |  // TODO separate func
  437|   [0;35m151k[0m|  for(uint64_t i = 0; i < arrlen(trace->snaps); i++) {
  438|   134k|    free_snap(&trace->snaps[i]);
  439|   134k|  }
  440|  17.3k|  arrfree(trace->consts);
  441|  17.3k|  arrfree(trace->relocs);
  442|  17.3k|  arrfree(trace->ops);
  443|  17.3k|  arrfree(trace->snaps);
  444|       |  
  445|  17.3k|  pendpatch();
  446|  17.3k|  free(trace);
  447|  17.3k|  trace = nullptr;
  448|  17.3k|  trace_state = OFF;
  449|  17.3k|  side_exit = nullptr;
  450|  17.3k|  arrfree(downrec);
  451|  17.3k|  parent = nullptr;
  452|  17.3k|}
  453|       |
  454|  1.04M|int record(unsigned int *pc, long *frame, long argcnt) {
  455|  [0;35m1.04M[0m|  if (arrlen(traces) >= TRACE_MAX) [0;41m{[0m
  456|      0|[0;41m    return 1;[0m
  457|      0|[0;41m  }[0m
  458|  1.04M|  switch (trace_state) {
  459|  26.8k|  case OFF: {
  460|       |    // TODO fix?
  461|  [0;35m26.8k[0m|    if (INS_OP(*pc) == JFUNC && [0;41mside_exit == [0m[0;41mnullptr[0m) [0;41m{[0m
  462|       |[0;41m[0m      // printf("CAN'T RECORD TO JFUNC\n");[0;41m[0m
  463|      0|[0;41m      return 1;[0m
  464|      0|[0;41m    }[0m
  465|  26.8k|    record_start(pc, frame);
  466|  26.8k|    auto res = record_instr(pc, frame, argcnt);
  467|  [0;35m26.8k[0m|    if (trace_state == START) {
  468|  26.8k|      trace_state = TRACING;
  469|  26.8k|    }
  470|  26.8k|    return res;
  471|      0|    [0;41mbreak[0m;
  472|  26.8k|  }
  473|  1.01M|  case TRACING: {
  474|  1.01M|    pendpatch();
  475|  1.01M|    auto res = record_instr(pc, frame, argcnt);
  476|  1.01M|    return res;
  477|      0|    [0;41mbreak[0m;
  478|  26.8k|  }
  479|      0|  [0;41mdefault: {[0m
  480|      0|[0;41m    printf("BAD TRACE STATE %i\n", trace_state);[0m
  481|      0|[0;41m    exit(-1)[0m;
  482|      0|    [0;41mreturn 1[0m;
  483|  26.8k|  }
  484|  1.04M|  }
  485|  1.04M|}
  486|       |
  487|       |// Convert a runtime object type to an IR type.
  488|       |// Use tag bits.  If it's a literal, use IMMEDIATE_MASK.
  489|       |// If it's a PTR_TAG, follow ptr and use tag bits there.
  490|       |//
  491|       |// Currently depends on tag being less than 7 bits total.
  492|       |// TODO top bit is IR_INS_TYPE_GUARD, this should be part
  493|       |//      of the load instruction instead.
  494|       |// TODO: for records we may need a different strategy.
  495|   388k|uint8_t get_object_ir_type(int64_t obj) {
  496|   388k|  uint8_t t;
  497|   [0;35m388k[0m|  if ((obj & TAG_MASK) == PTR_TAG) {
  498|  36.1k|    int64_t *objp = (int64_t *)(obj - PTR_TAG);
  499|  36.1k|    t = (*objp) & IMMEDIATE_MASK;
  500|   [0;35m352k[0m|  } else if ((obj & TAG_MASK) == LITERAL_TAG) {
  501|  28.0k|    t = obj & IMMEDIATE_MASK;
  502|   324k|  } else {
  503|   324k|    t = obj & TAG_MASK;
  504|   324k|  }
  505|   [0;35m388k[0m|  if (t == PTR_TAG) [0;41m{[0m
  506|      0|[0;41m    assert(false);[0m
  507|      0|[0;41m  }[0m
  508|   388k|  return t;
  509|   388k|}
  510|       |
  511|  1.03M|int record_stack_load(int slot, const long *frame) {
  512|  [0;35m1.03M[0m|  if (regs[slot] == -1) {
  513|       |    // Guard on type
  514|  34.0k|    auto type = get_object_ir_type(frame[slot]);
  515|       |
  516|  34.0k|    regs[slot] =
  517|  34.0k|        push_ir(trace, IR_SLOAD, slot, IR_NONE, IR_INS_TYPE_GUARD | type);
  518|  34.0k|  }
  519|  1.03M|  return regs[slot];
  520|  1.03M|}
  521|       |
  522|       |// Note: Does not add snap after!  Add if not at end of trace.
  523|    287|void record_funcv(uint32_t i, uint32_t *pc, long* frame, long argcnt) {
  524|       |  // Otherwise we're on-trace, and the last IR was a call.
  525|    [0;35m287[0m|  auto ra = INS_A(i);
  526|    287|  auto cnt = argcnt - ra;
  527|       |  // Build a list from ra of cnt length.
  528|       |    
  529|       |  // Load everything first, so that we don't get a guard failure
  530|       |  // before alloc.
  531|       |  // TODO: when typechecks are lazy, this can be done inline, since it's just
  532|       |  // stored in a list and doesn't need a typecheck.
  533|    287|  uint16_t* locs = NULL;
  534|  [0;35m1.27k[0m|  for(uint32_t j = ra + cnt - 1; j >= ra; j--) {
  535|    986|    arrput(locs, record_stack_load(j, frame));
  536|    986|  }
  537|    287|  add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc, depth);
  538|    287|  trace->snaps[arrlen(trace->snaps) - 1].argcnt = argcnt;
  539|       |  //  TODO this forces a side exit without recording.
  540|       |  //   Put GC inline in generated code?  Would have to flush
  541|       |  //   all registers to stack.
  542|    287|  trace->snaps[arrlen(trace->snaps) - 1].exits = 255;
  543|       |
  544|       |  // Build the list.
  545|    [0;35m287[0m|  auto knum = arrlen(trace->consts);
  546|    287|  arrput(trace->consts, NIL_TAG);
  547|    287|  uint16_t prev = knum | IR_CONST_BIAS;
  548|  [0;35m1.27k[0m|  for(uint32_t j = 0; j < cnt; j++) {
  549|    986|    knum = arrlen(trace->consts);
  550|    986|    arrput(trace->consts, sizeof(cons_s) << 3);
  551|    [0;35m986[0m|    auto cell = push_ir(trace, IR_ALLOC, knum | IR_CONST_BIAS, CONS_TAG,
  552|    986|                        CONS_TAG);
  553|    [0;35m986[0m|    auto ref = push_ir(trace, IR_REF, cell, 8 - CONS_TAG, UNDEFINED_TAG);
  554|    986|    push_ir(trace, IR_STORE, ref, locs[j], UNDEFINED_TAG);
  555|    [0;35m986[0m|    ref = push_ir(trace, IR_REF, cell, 8 + 8 - CONS_TAG, UNDEFINED_TAG);
  556|    986|    push_ir(trace, IR_STORE, ref, prev, UNDEFINED_TAG);
  557|    986|    prev = cell;
  558|    986|  }
  559|    287|  regs[INS_A(i)] = prev;
  560|    287|  arrfree(locs);
  561|    287|}
  562|       |
  563|  65.1k|void check_emit_funcv(uint32_t startpc, uint32_t* pc, long* frame, long argcnt) {
  564|  [0;35m65.1k[0m|  if (INS_OP(startpc) == FUNCV || INS_OP(startpc) == CLFUNCV) {
  565|     [0;35m40[0m|    auto ra = INS_A(startpc);
  566|       |    //printf("NEEDS FUNCV-ifying %i %li\n", ra, argcnt-ra);
  567|     40|    record_funcv(startpc, pc, frame, argcnt);
  568|     40|  }
  569|  65.1k|}
  570|       |
  571|       |extern unsigned char hotmap[hotmap_sz];
  572|  1.04M|int record_instr(unsigned int *pc, long *frame, long argcnt) {
  573|  1.04M|  unsigned int i = *pc;
  574|       |
  575|  [0;35m1.04M[0m|  if (INS_OP(i) == LOOP) {
  576|  [0;35m1.45M[0m|    for (int *pos = &regs[INS_A(i) + INS_B(i)]; pos < &regs_list[257]; pos++) {
  577|  1.45M|      *pos = -1;
  578|  1.45M|    }
  579|  5.91k|  }
  580|  [0;35m1.04M[0m|  if ((pc == pc_start) && (depth == 0) && (trace_state == TRACING) &&
  581|  [0;35m1.04M[0m|      INS_OP(trace->startpc) != RET1 && parent == nullptr) {
  582|    [0;35m309[0m|    if (INS_OP(*pc) == CLFUNC && argcnt != INS_A(*pc)) {
  583|    [0;35m304[0m|    } else if (INS_OP(*pc) == CLFUNCV && [0;41margcnt < [0m[0;41mINS_A[0m(*pc)) [0;41m{[0m
  584|    304|[0;41m    }[0m else {
  585|    304|      if (verbose)
  586|      0|        [0;41mprintf("Record stop loop\n")[0m;
  587|    304|      check_emit_funcv(trace->startpc, pc, frame, argcnt);
  588|    304|      record_stop(pc, frame, arrlen(traces));
  589|    304|      return 1;
  590|    304|    }
  591|    309|  }
  592|       |
  593|  1.04M|  instr_count++;
  594|  [0;35m1.04M[0m|  if (verbose) [0;41m{[0m
  595|      [0;35m0[0m|[0;41m    for (int j = 0; [0m[0;41mj < depth[0m[0;41m; [0m[0;41mj++[0m[0;41m) [0m[0;41m{[0m
  596|      0|[0;41m      printf(" . ");[0m
  597|      0|[0;41m    }[0m[0;41m[0m
  598|      [0;35m0[0m|[0;41m    printf("%lx %s %i %i %i\n", (long)pc, ins_names[[0m[0;41mINS_OP[0m[0;41m(i)], [0m[0;41mINS_A[0m[0;41m(i),[0m
  599|      [0;35m0[0m|[0;41m           [0m[0;41mINS_B[0m[0;41m(i), [0m[0;41mINS_C[0m[0;41m(i));[0m
  600|      0|[0;41m  }[0m
  601|  1.04M|  switch (INS_OP(i)) {
  602|    895|  case ILOOP: {
  603|    895|    break;
  604|      0|  }
  605|  5.66k|  case LOOP: {
  606|  [0;35m5.66k[0m|    if (arrlen(trace->ops) == 0) {
  607|       |      /* for(unsigned arg = INS_A(*pc); arg < INS_A(*pc) + INS_B(*pc); arg++) { */
  608|       |      /* 	regs[arg] = push_ir(trace, IR_ARG, arg, 0, get_object_ir_type(frame[arg]) | IR_INS_TYPE_GUARD); */
  609|       |      /* } */
  610|  [0;35m3.24k[0m|    } else if (arrlen(trace->ops) != 0 && !parent || (unroll++ >= 3)) {
  611|       |    // TODO check the way luajit does it
  612|    [0;35m672[0m|      if (!parent) {
  613|    471|        if (verbose)
  614|      0|          [0;41mprintf("Record abort: Root trace hit untraced loop\n")[0m;
  615|    471|      } else {
  616|    201|        if (verbose)
  617|      0|          [0;41mprintf("Record abort: Unroll limit reached in loop for side trace\n")[0m;
  618|    201|      }
  619|    672|      hotmap[(((long)pc) >> 2) & hotmap_mask] = 1;
  620|    672|      record_abort();
  621|    672|      return 1;
  622|    672|    }
  623|  4.99k|    break;
  624|  5.66k|  }
  625|  4.99k|  case CLFUNCV:
  626|    525|  case FUNCV: {
  627|       |    // TODO: We could do build_list before at start of trace
  628|    [0;35m525[0m|    if (arrlen(trace->ops) == 0) {
  629|       |      /* printf("Record abort: Can't start at FUNCV\n"); */
  630|       |      /* record_abort(); */
  631|       |      /* return 1; */
  632|    278|      break;
  633|    278|    }
  634|    247|    record_funcv(i, pc, frame, argcnt);
  635|    [0;35m247[0m|    if (INS_OP(i) == CLFUNCV) {
  636|    102|      add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 2, depth);
  637|    145|    } else {
  638|    145|      add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 1, depth);
  639|    145|    }
  640|    247|    break;
  641|    525|  }
  642|    642|  case ICLFUNC:
  643|  8.08k|  case CLFUNC:
  644|  11.8k|  case IFUNC:
  645|  58.8k|  case FUNC: {
  646|  [0;35m58.8k[0m|    if (arrlen(trace->ops) == 0) {
  647|  [0;35m40.6k[0m|      for(unsigned arg = 0; arg < INS_A(*pc); arg++) {
  648|  [0;35m29.7k[0m|	if (arg >= 6) {
  649|       |	  // TODO clean this up in the register allocator.
  650|    159|	  break;
  651|    159|	}
  652|  [0;35m29.5k[0m|	regs[arg] = push_ir(trace, IR_ARG, arg, 0, get_object_ir_type(frame[arg]) | IR_INS_TYPE_GUARD);
  653|  29.5k|      }
  654|  11.1k|    }
  655|  58.8k|    break;
  656|  11.8k|  }
  657|     19|  case CALLCC: {
  658|       |    // TODO: this snap and flush only need things below the current frame.
  659|     19|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc, depth);
  660|     19|    trace->snaps[arrlen(trace->snaps) - 1].exits = 255;
  661|     [0;35m19[0m|    auto op1 = push_ir(trace, IR_FLUSH, 0, 0, UNDEFINED_TAG);
  662|     [0;35m19[0m|    auto knum = arrlen(trace->consts);
  663|     19|    arrput(trace->consts, (long)vm_callcc);
  664|     [0;35m19[0m|    auto cont = push_ir(trace, IR_CALLXS, op1, knum | IR_CONST_BIAS, CONT_TAG);
  665|       |    // TODO check GC result
  666|     19|    regs[INS_A(i)] = cont;
  667|     19|    knum = arrlen(trace->consts);
  668|     19|    arrput(trace->consts, FALSE_REP);
  669|     [0;35m19[0m|    push_ir(trace, IR_NE, cont, knum | IR_CONST_BIAS, UNDEFINED_TAG | IR_INS_TYPE_GUARD);
  670|     19|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc+1, depth);
  671|     19|    break;
  672|  11.8k|  }
  673|     82|  case CALLCC_RESUME: {
  674|     [0;35m82[0m|    auto c = record_stack_load(INS_B(i), frame);
  675|     [0;35m82[0m|    auto result = record_stack_load(INS_C(i), frame);
  676|       |	
  677|     [0;35m82[0m|    auto knum = arrlen(trace->consts);
  678|     82|    arrput(trace->consts, (long)vm_cc_resume);
  679|     [0;35m82[0m|    push_ir(trace, IR_CCRES, c, knum | IR_CONST_BIAS, UNDEFINED_TAG);
  680|       |
  681|       |    // TODO: If the callcc exists in the same trace,
  682|       |    //       we could optimize here and just pop depth/regs
  683|       |    //       to the right place also.  I.e. callcc is just
  684|       |    //       being used as a non-local return, and it's still
  685|       |    //       on the stack.
  686|       |      
  687|       |    // Guard we are going to the right place, almost the same as RET.
  688|     [0;35m82[0m|    closure_s* cont = (closure_s*)(frame[INS_B(i)] - PTR_TAG);
  689|     82|    auto *old_pc = (unsigned int *)cont->v[(cont->len >> 3) - 1];
  690|     [0;35m82[0m|    auto frame_off = INS_A(*(old_pc - 1));
  691|       |    
  692|       |    // TODO maybe also check for downrec?  Same as RET
  693|     82|    depth = 0;
  694|     82|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc, depth);
  695|     82|    regs = &regs_list[1];
  696|  [0;35m21.1k[0m|    for (int j = 0; j < sizeof(regs_list) / sizeof(regs_list[0]); j++) {
  697|  21.0k|      regs_list[j] = -1;
  698|  21.0k|    }
  699|     82|    regs[frame_off] = result;
  700|     82|    knum = arrlen(trace->consts);
  701|     82|    arrput(trace->consts, (long)old_pc);
  702|     [0;35m82[0m|    auto knum2 = arrlen(trace->consts);
  703|     82|    arrput(trace->consts, (frame_off + 1) << 3);
  704|     [0;35m82[0m|    push_ir(trace, IR_RET, knum | IR_CONST_BIAS, knum2 | IR_CONST_BIAS,
  705|     82|	    IR_INS_TYPE_GUARD | 0x5);
  706|       |
  707|     82|    add_snap(regs_list, (int)(regs - regs_list - 1), trace,
  708|     82|	     (uint32_t *)old_pc, depth);
  709|     82|    break;
  710|  11.8k|  }
  711|     22|  case IRET1:
  712|  72.8k|  case RET1: {
  713|  [0;35m72.8k[0m|    if (depth == 0) {
  714|  10.8k|      auto *old_pc = (unsigned int *)frame[-1];
  715|  [0;35m10.8k[0m|      if (INS_OP(*pc_start) == RET1 || side_exit != nullptr) {
  716|  8.99k|        int cnt = 0;
  717|  [0;35m13.0k[0m|        for (uint64_t p = 0; p < arrlen(downrec); p++) {
  718|  [0;35m4.01k[0m|          if (downrec[p] == pc) {
  719|    590|            cnt++;
  720|    590|          }
  721|  4.01k|        }
  722|  [0;35m8.99k[0m|        if (cnt != 0) {
  723|    [0;35m590[0m|          if (side_exit != nullptr && INS_OP(i) != IRET1) {
  724|    499|            if (verbose)
  725|      0|              [0;41mprintf("Record abort: Potential down-recursion, restarting\n")[0m;
  726|    499|            record_abort();
  727|    499|            record_start(pc, frame);
  728|    499|            record_instr(pc, frame, 0);
  729|    499|            trace_state = TRACING;
  730|    499|            break;
  731|    499|          }
  732|     [0;35m91[0m|          if (pc == pc_start && !side_exit) {
  733|     78|            if (verbose)
  734|      0|              [0;41mprintf("Record stop downrec\n")[0m;
  735|     78|            record_stop(pc, frame, arrlen(traces));
  736|     78|          } else {
  737|     13|            if (verbose)
  738|      0|              [0;41mprintf("Record abort downrec\n")[0m;
  739|     13|            record_abort();
  740|     13|          }
  741|     91|          return 1;
  742|    590|        }
  743|  [0;35m8.40k[0m|        arrput(downrec, pc);
  744|       |
  745|  [0;35m8.40k[0m|        auto result = record_stack_load(INS_A(i), frame);
  746|       |        // Guard down func type
  747|  8.40k|        add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc, depth);
  748|       |
  749|  [0;35m8.40k[0m|        auto frame_off = INS_A(*(old_pc - 1));
  750|       |        // printf("Continue down recursion, frame offset %i\n", frame_off);
  751|       |
  752|       |	// TODO can we remove this?
  753|  8.40k|        memmove(&regs[frame_off + 1], &regs[0],
  754|  8.40k|                sizeof(int) * (256 - (frame_off + 1)));
  755|  8.40k|        regs[frame_off] = result;
  756|  [0;35m55.4k[0m|        for (unsigned j = 0; j < frame_off; j++) {
  757|  47.0k|          regs[j] = -1;
  758|  47.0k|        }
  759|       |
  760|  [0;35m8.40k[0m|        auto knum = arrlen(trace->consts);
  761|  8.40k|        arrput(trace->consts, (long)old_pc);
  762|  [0;35m8.40k[0m|        auto knum2 = arrlen(trace->consts);
  763|  8.40k|        arrput(trace->consts, (frame_off + 1) << 3);
  764|  [0;35m8.40k[0m|        push_ir(trace, IR_RET, knum | IR_CONST_BIAS, knum2 | IR_CONST_BIAS,
  765|  8.40k|                IR_INS_TYPE_GUARD | 0x5);
  766|       |
  767|  8.40k|        add_snap(regs_list, (int)(regs - regs_list - 1), trace,
  768|  8.40k|                 (uint32_t *)frame[-1], depth);
  769|       |        // TODO retdepth
  770|  8.40k|      } else {
  771|  [0;35m1.80k[0m|        if (INS_OP(trace->startpc) == LOOP && parent == nullptr) {
  772|    515|          if (verbose)
  773|      0|            [0;41mprintf("Record abort: Loop root trace exited loop\n")[0m;
  774|    515|          record_abort();
  775|  1.29k|        } else {
  776|  1.29k|          if (verbose)
  777|      0|            [0;41mprintf("Record stop return\n")[0m;
  778|       |          // record_stack_load(INS_A(i), frame);
  779|  1.29k|          record_stop(pc, frame, -1);
  780|  1.29k|        }
  781|  1.80k|        return 1;
  782|  1.80k|      }
  783|  [0;35m62.0k[0m|    } else if (depth > 0) {
  784|  62.0k|      depth--;
  785|  62.0k|      regs[-1] = regs[INS_A(i)];
  786|  [0;35m14.8M[0m|      for (int j = (int)(regs - regs_list); j < 257; j++) {
  787|  14.7M|        regs_list[j] = -1;
  788|  14.7M|      }
  789|  62.0k|      auto *old_pc = (unsigned int *)frame[-1];
  790|  62.0k|      assert(regs >= regs_list);
  791|  [0;35m62.0k[0m|      regs -= (INS_A(*(old_pc - 1)) + 1);
  792|  62.0k|      assert(regs >= regs_list);
  793|  62.0k|    } else [0;41m{[0m
  794|      0|[0;41m      depth--;[0m
  795|      0|[0;41m      printf("TODO return below trace\n");[0m
  796|      0|[0;41m      exit(-1);[0m
  797|      0|[0;41m    }[0m
  798|  70.4k|    break;
  799|  72.8k|  }
  800|  86.4k|  case CALL: {
  801|   [0;35m287k[0m|    for (int j = INS_A(i) + 1; j < INS_A(i) + INS_B(i); j++) {
  802|   201k|      regs[j] = record_stack_load(j, frame);
  803|   201k|    }
  804|  86.4k|    {
  805|  [0;35m86.4k[0m|      auto clo = record_stack_load(INS_A(i) + 1, frame);
  806|  [0;35m86.4k[0m|      auto ref = push_ir(trace, IR_REF, clo, 16 - CLOSURE_TAG, UNDEFINED_TAG);
  807|  86.4k|      auto fun = push_ir(trace, IR_LOAD, ref, 0, 0);
  808|  86.4k|      regs[INS_A(i)] = fun;
  809|  [0;35m86.4k[0m|      auto cl = frame[INS_A(i) + 1];
  810|  [0;35m86.4k[0m|      auto closure = (closure_s *)(cl - CLOSURE_TAG);
  811|  [0;35m86.4k[0m|      auto knum = arrlen(trace->consts);
  812|  86.4k|      arrput(trace->consts, closure->v[0]);
  813|  [0;35m86.4k[0m|      push_ir(trace, IR_EQ, fun, knum | IR_CONST_BIAS, IR_INS_TYPE_GUARD);
  814|  86.4k|    }
  815|       |    /* // Check call type */
  816|       |    /* { */
  817|       |    /*   auto v = frame[INS_A(i) + 1]; */
  818|       |    /*   auto knum = arrlen(trace->consts); */
  819|       |    /*   arrput(trace->consts, v); */
  820|       |    /*   ir_ins ins; */
  821|       |    /*   ins.reg = REG_NONE; */
  822|       |    /*   ins.op1 = record_stack_load(INS_A(i) + 1, frame); */
  823|       |    /*   ins.op2 = knum | IR_CONST_BIAS; */
  824|       |    /*   ins.op = IR_EQ; */
  825|       |    /*   // TODO magic number */
  826|       |    /*   ins.type = IR_INS_TYPE_GUARD | 0x5; */
  827|       |    /*   arrput(trace->ops, ins); */
  828|       |    /* } */
  829|  86.4k|    long cnt = 0;
  830|  86.4k|    auto *p_pc = (uint32_t *)frame[-1];
  831|   [0;35m289k[0m|    for (int d = depth; d > 0; d--) {
  832|   [0;35m203k[0m|      if (p_pc == pc + 1) {
  833|  5.48k|        cnt++;
  834|  5.48k|      }
  835|   203k|      p_pc = (uint32_t *)frame[-1];
  836|   203k|    }
  837|       |
  838|       |    // Setup frame
  839|  86.4k|    depth++;
  840|       |    // Push PC link as const
  841|  86.4k|    {
  842|  [0;35m86.4k[0m|      auto knum = (int)arrlen(trace->consts);
  843|  86.4k|      arrput(trace->consts, ((long)(pc + 1)));
  844|  [0;35m86.4k[0m|      regs[INS_A(i)] = knum | IR_CONST_BIAS; // TODO set PC
  845|  86.4k|    }
  846|       |
  847|       |    // Increment regs
  848|  86.4k|    assert(regs >= regs_list);
  849|  [0;35m86.4k[0m|    regs += INS_A(i) + 1;
  850|  86.4k|    assert(regs >= regs_list);
  851|       |
  852|  [0;35m86.4k[0m|    if (cnt >= UNROLL_LIMIT) {
  853|  [0;35m2.22k[0m|      auto v = frame[INS_A(i) + 1];
  854|  [0;35m2.22k[0m|      auto *closure = (closure_s *)(v - CLOSURE_TAG);
  855|  2.22k|      auto *cfunc = (bcfunc *)closure->v[0];
  856|  2.22k|      auto *target = cfunc->code;
  857|  [0;35m2.22k[0m|      if (target == pc_start) {
  858|     59|        if (verbose)
  859|      0|          [0;41mprintf("Record stop up-recursion\n")[0m;
  860|     59|	check_emit_funcv(trace->startpc, pc, frame, argcnt);
  861|     59|        record_stop(target, frame, arrlen(traces));
  862|     59|        return 1;
  863|     59|      } // TODO fix flush
  864|  2.16k|      pendpatch();
  865|  2.16k|      bool abort = false;
  866|  [0;35m2.16k[0m|      if (INS_OP(cfunc->code[0]) == JFUNC) {
  867|       |        // Check if it is already up-recursion (i.e. a side trace failed here)
  868|    [0;35m873[0m|        auto sl_trace = trace_cache_get(INS_D(cfunc->code[0]));
  869|    [0;35m873[0m|        if (sl_trace->link != INS_D(cfunc->code[0])) {
  870|    768|          if (verbose)
  871|      0|            [0;41mprintf("Flushing trace\n")[0m;
  872|    768|          cfunc->code[0] = traces[INS_D(cfunc->code[0])]->startpc;
  873|    768|          hotmap[(((long)pc) >> 2) & hotmap_mask] = 1;
  874|    768|          abort = true;
  875|    768|        }
  876|  1.28k|      } else {
  877|  1.28k|        abort = true;
  878|  1.28k|      }
  879|  [0;35m2.16k[0m|      if (abort) {
  880|       |        // TODO this isn't in luajit? fails with side exit without?
  881|  2.05k|        hotmap[(((long)cfunc->code[0]) >> 2) & hotmap_mask] = 1;
  882|  2.05k|        if (verbose)
  883|      0|          [0;41mprintf("Record abort: unroll limit reached\n")[0m;
  884|  2.05k|        record_abort();
  885|  2.05k|        return 1;
  886|  2.05k|      }
  887|  2.16k|    }
  888|  84.3k|    break;
  889|  86.4k|  }
  890|  84.3k|  case KSHORT: {
  891|  54.9k|    int64_t k = ((int16_t)INS_D(i)) << 3;
  892|  [0;35m54.9k[0m|    auto reg = INS_A(i);
  893|  [0;35m54.9k[0m|    regs[reg] = arrlen(trace->consts) | IR_CONST_BIAS;
  894|  54.9k|    arrput(trace->consts, k);
  895|  54.9k|    break;
  896|  86.4k|  }
  897|     14|  case STRING_SYMBOL: {
  898|       |    // TODO snapshots
  899|     [0;35m14[0m|    auto op1 = record_stack_load(INS_B(i), frame);
  900|     [0;35m14[0m|    auto knum = arrlen(trace->consts);
  901|     14|    arrput(trace->consts, (long)vm_string_symbol);
  902|     [0;35m14[0m|    auto sym = push_ir(trace, IR_CALLXS, op1, knum | IR_CONST_BIAS, SYMBOL_TAG);
  903|     14|    regs[INS_A(i)] = sym;
  904|     14|    knum = arrlen(trace->consts);
  905|     14|    arrput(trace->consts, FALSE_REP);
  906|     [0;35m14[0m|    push_ir(trace, IR_NE, sym, knum | IR_CONST_BIAS, UNDEFINED_TAG | IR_INS_TYPE_GUARD);
  907|     14|    break;
  908|  86.4k|  }
  909|    291|  case SYMBOL_STRING: {
  910|    [0;35m291[0m|    auto op1 = record_stack_load(INS_B(i), frame);
  911|    [0;35m291[0m|    auto ref = push_ir(trace, IR_REF, op1, 8 - SYMBOL_TAG, UNDEFINED_TAG);
  912|    [0;35m291[0m|    regs[INS_A(i)] = push_ir(trace, IR_LOAD, ref, 0, STRING_TAG);
  913|    291|    break;
  914|  86.4k|  }
  915|  3.26k|  case CHAR_INTEGER: {
  916|  [0;35m3.26k[0m|    auto op1 = record_stack_load(INS_B(i), frame);
  917|  [0;35m3.26k[0m|    regs[INS_A(i)] = push_ir(trace, IR_SHR, op1, 5, FIXNUM_TAG);
  918|  3.26k|    break;
  919|  86.4k|  }
  920|    312|  case INTEGER_CHAR: {
  921|    [0;35m312[0m|    auto op1 = record_stack_load(INS_B(i), frame);
  922|    [0;35m312[0m|    if (get_object_ir_type(frame[INS_B(i)]) != FIXNUM_TAG) [0;41m{[0m
  923|      0|[0;41m      printf("Record abort: integer->char with non-char");[0m
  924|      0|[0;41m      record_abort();[0m
  925|      0|[0;41m      return 1;[0m
  926|      0|[0;41m    }[0m
  927|    [0;35m312[0m|    regs[INS_A(i)] = push_ir(trace, IR_CHGTYPE, op1, FIXNUM_TAG, CHAR_TAG);
  928|    312|    break;
  929|    312|  }
  930|  28.7k|  case JISF: {
  931|  [0;35m28.7k[0m|    auto knum = arrlen(trace->consts);
  932|  28.7k|    arrput(trace->consts, FALSE_REP);
  933|  28.7k|    uint32_t *next_pc;
  934|  28.7k|    ir_ins_op op;
  935|  [0;35m28.7k[0m|    auto op1 = record_stack_load(INS_B(i), frame);
  936|  [0;35m28.7k[0m|    if (frame[INS_B(i)] == FALSE_REP) {
  937|  17.4k|      op = IR_EQ;
  938|  17.4k|      add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 2, depth);
  939|  17.4k|      next_pc = pc + INS_D(*(pc + 1)) + 1;
  940|  17.4k|    } else {
  941|  11.3k|      op = IR_NE;
  942|  11.3k|      add_snap(regs_list, (int)(regs - regs_list - 1), trace,
  943|  11.3k|               pc + INS_D(*(pc + 1)) + 1, depth);
  944|  11.3k|      next_pc = pc + 2;
  945|  11.3k|    }
  946|  [0;35m28.7k[0m|    push_ir(trace, op, op1, knum | IR_CONST_BIAS, IR_INS_TYPE_GUARD);
  947|  28.7k|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, next_pc, depth);
  948|  28.7k|    break;
  949|    312|  }
  950|    579|  case JIST: {
  951|    [0;35m579[0m|    auto knum = arrlen(trace->consts);
  952|    579|    arrput(trace->consts, FALSE_REP);
  953|    579|    ir_ins_op op;
  954|    579|    uint32_t *next_pc;
  955|    [0;35m579[0m|    auto op1 = record_stack_load(INS_B(i), frame);
  956|    [0;35m579[0m|    if (frame[INS_B(i)] == FALSE_REP) {
  957|    363|      op = IR_EQ;
  958|    363|      add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + INS_D(*(pc + 1)) + 1, depth);
  959|    363|      next_pc = pc + 2;
  960|    363|    } else {
  961|    216|      op = IR_NE;
  962|    216|      add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 2, depth);
  963|    216|      next_pc = pc + INS_D(*(pc + 1)) + 1;
  964|    216|    }
  965|    [0;35m579[0m|    push_ir(trace, op, op1, knum | IR_CONST_BIAS,  IR_INS_TYPE_GUARD);
  966|    579|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, next_pc, depth);
  967|    579|    break;
  968|    312|  }
  969|  4.29k|  case JISLT: {
  970|  4.29k|    uint32_t *next_pc;
  971|  4.29k|    ir_ins_op op;
  972|  [0;35m4.29k[0m|    if (frame[INS_B(i)] < frame[INS_C(i)]) {
  973|  2.49k|      op = IR_LT;
  974|  2.49k|      add_snap(regs_list, (int)(regs - regs_list - 1), trace,
  975|  2.49k|               pc + INS_D(*(pc + 1)) + 1, depth);
  976|  2.49k|      next_pc = pc + 2;
  977|  2.49k|    } else {
  978|  1.79k|      op = IR_GE;
  979|  1.79k|      add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 2, depth);
  980|  1.79k|      next_pc = pc + INS_D(*(pc + 1)) + 1;
  981|  1.79k|    }
  982|  4.29k|    uint8_t type;
  983|  4.29k|    uint32_t op1 = record_stack_load(INS_B(i), frame);
  984|  4.29k|    uint32_t op2 = record_stack_load(INS_C(i), frame);
  985|  [0;35m4.29k[0m|    if (op1 >= IR_CONST_BIAS) {
  986|    [0;35m585[0m|      type = trace->consts[op1 - IR_CONST_BIAS] & TAG_MASK;
  987|  3.71k|    } else {
  988|  3.71k|      type = trace->ops[op1].type & ~IR_INS_TYPE_GUARD;
  989|  3.71k|    }
  990|  [0;35m4.29k[0m|    if (type != 0) {
  991|    221|      if (verbose)
  992|      0|        [0;41mprintf("Record abort: Only int supported in trace: %i\n", type)[0m;
  993|    221|      record_abort();
  994|    221|      return 1;
  995|    221|    }
  996|  4.07k|    push_ir(trace, op, op1, op2, type);
  997|  4.07k|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, next_pc, depth);
  998|  4.07k|    break;
  999|  4.29k|  }
 1000|  2.79k|  case JISGT: {
 1001|  2.79k|    uint32_t *next_pc;
 1002|  2.79k|    ir_ins_op op;
 1003|  [0;35m2.79k[0m|    if (frame[INS_B(i)] > frame[INS_C(i)]) {
 1004|  1.90k|      op = IR_GT;
 1005|  1.90k|      add_snap(regs_list, (int)(regs - regs_list - 1), trace,
 1006|  1.90k|               pc + INS_D(*(pc + 1)) + 1, depth);
 1007|  1.90k|      next_pc = pc + 2;
 1008|  1.90k|    } else {
 1009|    892|      op = IR_LE;
 1010|    892|      add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 2, depth);
 1011|    892|      next_pc = pc + INS_D(*(pc + 1)) + 1;
 1012|    892|    }
 1013|  2.79k|    uint8_t type;
 1014|  2.79k|    uint32_t op1 = record_stack_load(INS_B(i), frame);
 1015|  2.79k|    uint32_t op2 = record_stack_load(INS_C(i), frame);
 1016|  [0;35m2.79k[0m|    if (op1 >= IR_CONST_BIAS) {
 1017|     [0;35m98[0m|      type = trace->consts[op1 - IR_CONST_BIAS] & TAG_MASK;
 1018|  2.70k|    } else {
 1019|  2.70k|      type = trace->ops[op1].type & ~IR_INS_TYPE_GUARD;
 1020|  2.70k|    }
 1021|  [0;35m2.79k[0m|    if (type != 0) {
 1022|    386|      if (verbose)
 1023|      0|        [0;41mprintf("Record abort: Only int supported in trace: %i\n", type)[0m;
 1024|    386|      record_abort();
 1025|    386|      return 1;
 1026|    386|    }
 1027|  2.41k|    push_ir(trace, op, op1, op2, type);
 1028|  2.41k|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, next_pc, depth);
 1029|  2.41k|    break;
 1030|  2.79k|  }
 1031|  3.75k|  case JISGTE: {
 1032|  3.75k|    uint32_t op1 = record_stack_load(INS_B(i), frame);
 1033|  3.75k|    uint32_t op2 = record_stack_load(INS_C(i), frame);
 1034|  3.75k|    ir_ins_op op;
 1035|  3.75k|    uint32_t *next_pc;
 1036|  [0;35m3.75k[0m|    if (frame[INS_B(i)] >= frame[INS_C(i)]) {
 1037|  2.13k|      op = IR_GE;
 1038|  2.13k|      add_snap(regs_list, (int)(regs - regs_list - 1), trace,
 1039|  2.13k|               pc + INS_D(*(pc + 1)) + 1, depth);
 1040|  2.13k|      next_pc = pc + 2;
 1041|  2.13k|    } else {
 1042|  1.61k|      op = IR_LT;
 1043|  1.61k|      add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 2, depth);
 1044|  1.61k|      next_pc = pc + INS_D(*(pc + 1)) + 1;
 1045|  1.61k|    }
 1046|  3.75k|    push_ir(trace, op, op1, op2, IR_INS_TYPE_GUARD);
 1047|  3.75k|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, next_pc, depth);
 1048|  3.75k|    break;
 1049|  2.79k|  }
 1050|    328|  case JISLTE: {
 1051|    328|    uint32_t op1 = record_stack_load(INS_B(i), frame);
 1052|    328|    uint32_t op2 = record_stack_load(INS_C(i), frame);
 1053|    328|    ir_ins_op op;
 1054|    328|    uint32_t *next_pc;
 1055|    [0;35m328[0m|    if ((frame[INS_B(i)] & TAG_MASK) == FLONUM_TAG ||
 1056|    [0;35m328[0m|        (frame[INS_C(i)] & TAG_MASK) == FLONUM_TAG) {
 1057|    218|      if (verbose)
 1058|      0|        [0;41mprintf("Record abort: flonum not supported in jeqv\n")[0m;
 1059|    218|      record_abort();
 1060|    218|      return 1;
 1061|    218|    }
 1062|    [0;35m110[0m|    if (frame[INS_B(i)] <= frame[INS_C(i)]) {
 1063|     73|      op = IR_LE;
 1064|     73|      add_snap(regs_list, (int)(regs - regs_list - 1), trace,
 1065|     73|               pc + INS_D(*(pc + 1)) + 1, depth);
 1066|     73|      next_pc = pc + 2;
 1067|     73|    } else {
 1068|     37|      op = IR_GT;
 1069|     37|      add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 2, depth);
 1070|     37|      next_pc = pc + INS_D(*(pc + 1)) + 1;
 1071|     37|    }
 1072|    110|    push_ir(trace, op, op1, op2, IR_INS_TYPE_GUARD);
 1073|    110|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, next_pc, depth);
 1074|    110|    break;
 1075|    328|  }
 1076|  6.45k|  case JEQV:
 1077|  17.9k|  case JEQ:
 1078|  23.3k|  case JISEQ: {
 1079|  23.3k|    uint32_t op1 = record_stack_load(INS_B(i), frame);
 1080|  23.3k|    uint32_t op2 = record_stack_load(INS_C(i), frame);
 1081|  23.3k|    uint32_t *next_pc;
 1082|  23.3k|    ir_ins_op op;
 1083|  [0;35m23.3k[0m|    if (INS_OP(i) == JEQV) {
 1084|  [0;35m6.45k[0m|      if ((frame[INS_B(i)] & TAG_MASK) == FLONUM_TAG ||
 1085|  [0;35m6.45k[0m|          (frame[INS_C(i)] & TAG_MASK) == FLONUM_TAG) [0;41m{[0m
 1086|      0|[0;41m        if ([0m[0;41mverbose[0m[0;41m)[0m
 1087|      0|[0;41m          [0m[0;41mprintf("Record abort: flonum not supported in jeqv\n")[0m[0;41m;[0m
 1088|      0|[0;41m        record_abort();[0m
 1089|      0|[0;41m        return 1;[0m
 1090|      0|[0;41m      }[0m
 1091|  6.45k|    }
 1092|  [0;35m23.3k[0m|    if (frame[INS_B(i)] == frame[INS_C(i)]) {
 1093|  4.36k|      op = IR_EQ;
 1094|  4.36k|      add_snap(regs_list, (int)(regs - regs_list - 1), trace,
 1095|  4.36k|               pc + INS_D(*(pc + 1)) + 1, depth);
 1096|  4.36k|      next_pc = pc + 2;
 1097|  18.9k|    } else {
 1098|  18.9k|      op = IR_NE;
 1099|  18.9k|      add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 2, depth);
 1100|  18.9k|      next_pc = pc + INS_D(*(pc + 1)) + 1;
 1101|  18.9k|    }
 1102|  23.3k|    push_ir(trace, op, op1, op2, IR_INS_TYPE_GUARD);
 1103|  23.3k|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, next_pc, depth);
 1104|  23.3k|    break;
 1105|  23.3k|  }
 1106|  2.10k|  case JNEQ:
 1107|  3.25k|  case JNEQV:
 1108|  3.33k|  case JISNEQ: {
 1109|  3.33k|    uint32_t op1 = record_stack_load(INS_B(i), frame);
 1110|  3.33k|    uint32_t op2 = record_stack_load(INS_C(i), frame);
 1111|  3.33k|    uint32_t *next_pc;
 1112|  3.33k|    ir_ins_op op;
 1113|  [0;35m3.33k[0m|    if (INS_OP(i) == JNEQV) {
 1114|  [0;35m1.15k[0m|      if ((frame[INS_B(i)] & TAG_MASK) == FLONUM_TAG ||
 1115|  [0;35m1.15k[0m|          (frame[INS_C(i)] & TAG_MASK) == FLONUM_TAG) [0;41m{[0m
 1116|      0|[0;41m        if ([0m[0;41mverbose[0m[0;41m)[0m
 1117|      0|[0;41m          [0m[0;41mprintf("Record abort: flonum not supported in jneqv\n")[0m[0;41m;[0m
 1118|      0|[0;41m        record_abort();[0m
 1119|      0|[0;41m        return 1;[0m
 1120|      0|[0;41m      }[0m
 1121|  1.15k|    }
 1122|  [0;35m3.33k[0m|    if (INS_OP(i) == JNEQV) {
 1123|  [0;35m1.15k[0m|      if ((frame[INS_B(i)] & TAG_MASK) == FLONUM_TAG ||
 1124|  [0;35m1.15k[0m|          (frame[INS_C(i)] & TAG_MASK) == FLONUM_TAG) [0;41m{[0m
 1125|      0|[0;41m        if ([0m[0;41mverbose[0m[0;41m)[0m
 1126|      0|[0;41m          [0m[0;41mprintf("Record abort: flonum not supported in jneqv\n")[0m[0;41m;[0m
 1127|      0|[0;41m        record_abort();[0m
 1128|      0|[0;41m        return 1;[0m
 1129|      0|[0;41m      }[0m
 1130|  1.15k|    }
 1131|  [0;35m3.33k[0m|    if (frame[INS_B(i)] != frame[INS_C(i)]) {
 1132|  3.09k|      op = IR_NE;
 1133|  3.09k|      add_snap(regs_list, (int)(regs - regs_list - 1), trace,
 1134|  3.09k|               pc + INS_D(*(pc + 1)) + 1, depth);
 1135|  3.09k|      next_pc = pc + 2;
 1136|  3.09k|    } else {
 1137|    237|      op = IR_EQ;
 1138|    237|      add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 2, depth);
 1139|    237|      next_pc = pc + INS_D(*(pc + 1)) + 1;
 1140|    237|    }
 1141|  3.33k|    push_ir(trace, op, op1, op2, IR_INS_TYPE_GUARD);
 1142|  3.33k|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, next_pc, depth);
 1143|  3.33k|    break;
 1144|  3.33k|  }
 1145|    561|  case SET_CDR:
 1146|  1.70k|  case SET_CAR: {
 1147|  [0;35m1.70k[0m|    auto box = record_stack_load(INS_A(i), frame);
 1148|  [0;35m1.70k[0m|    auto obj = record_stack_load(INS_B(i), frame);
 1149|  1.70k|    uint32_t offset = 0;
 1150|  [0;35m1.70k[0m|    if (INS_OP(i) == SET_CDR) {
 1151|    561|      offset = 8;
 1152|    561|    }
 1153|  [0;35m1.70k[0m|    auto ref = push_ir(trace, IR_REF, box, 8 + offset - CONS_TAG, 0);
 1154|  1.70k|    push_ir(trace, IR_STORE, ref, obj, UNDEFINED_TAG);
 1155|       |    // Modified state, need a snap.
 1156|  1.70k|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 1, depth);
 1157|  1.70k|    break;
 1158|    561|  }
 1159|  4.93k|  case SET_BOX: {
 1160|  [0;35m4.93k[0m|    auto box = record_stack_load(INS_B(i), frame);
 1161|  [0;35m4.93k[0m|    auto obj = record_stack_load(INS_C(i), frame);
 1162|  [0;35m4.93k[0m|    auto ref = push_ir(trace, IR_REF, box, 8 - CONS_TAG, 0);
 1163|  4.93k|    push_ir(trace, IR_STORE, ref, obj, UNDEFINED_TAG);
 1164|       |    // Modified state, need a snap.
 1165|  4.93k|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 1, depth);
 1166|  4.93k|    break;
 1167|    561|  }
 1168|  9.93k|  case UNBOX: // DO don't need typecheck
 1169|  33.2k|  case CDR:
 1170|  70.9k|  case CAR: {
 1171|  70.9k|    uint32_t op1 = record_stack_load(INS_B(i), frame);
 1172|  70.9k|    uint32_t offset = 0;
 1173|  70.9k|    uint8_t type;
 1174|  [0;35m70.9k[0m|    if (INS_OP(i) == CAR || INS_OP(i) == UNBOX) {
 1175|       |      // TODO typecheck
 1176|       |      // TODO cleanup
 1177|  [0;35m47.6k[0m|      type = get_object_ir_type(((cons_s *)(frame[INS_B(i)] - CONS_TAG))->a);
 1178|  47.6k|    } else {
 1179|  [0;35m23.3k[0m|      type = get_object_ir_type(((cons_s *)(frame[INS_B(i)] - CONS_TAG))->b);
 1180|  23.3k|      offset = sizeof(long);
 1181|  23.3k|    }
 1182|  70.9k|    auto ref =
 1183|  [0;35m70.9k[0m|        push_ir(trace, IR_REF, op1, 8 - CONS_TAG + offset, UNDEFINED_TAG);
 1184|  70.9k|    regs[INS_A(i)] =
 1185|  70.9k|        push_ir(trace, IR_LOAD, ref, IR_NONE, type | IR_INS_TYPE_GUARD);
 1186|  70.9k|    break;
 1187|  33.2k|  }
 1188|    944|  case ISEQ:
 1189|  1.12k|  case EQV:
 1190|  10.5k|  case EQ: {
 1191|  10.5k|    uint32_t op1 = record_stack_load(INS_B(i), frame);
 1192|  10.5k|    uint32_t op2 = record_stack_load(INS_C(i), frame);
 1193|  10.5k|    int64_t v1 = frame[INS_B(i)];
 1194|  10.5k|    int64_t v2 = frame[INS_C(i)];
 1195|  10.5k|    int64_t c = FALSE_REP;
 1196|  10.5k|    uint8_t op = IR_NE;
 1197|  [0;35m10.5k[0m|    if (v1 == v2) {
 1198|  2.84k|      c = TRUE_REP;
 1199|  2.84k|      op = IR_EQ;
 1200|  2.84k|    }
 1201|  [0;35m10.5k[0m|    if (get_object_ir_type(v1) == FLONUM_TAG ||
 1202|  [0;35m10.5k[0m|	get_object_ir_type(v2) == FLONUM_TAG) [0;41m{[0m
 1203|      0|[0;41m      if ([0m[0;41mverbose[0m[0;41m)[0m
 1204|      0|[0;41m        [0m[0;41mprintf("Record abort: flonum not supported in eqv\n")[0m[0;41m;[0m
 1205|      0|[0;41m      record_abort();[0m
 1206|      0|[0;41m      return 1;[0m
 1207|      0|[0;41m    }[0m
 1208|  [0;35m10.5k[0m|    auto knum = arrlen(trace->consts);
 1209|  10.5k|    arrput(trace->consts, c);
 1210|  10.5k|    push_ir(trace, op, op1, op2, UNDEFINED_TAG);
 1211|  [0;35m10.5k[0m|    regs[INS_A(i)] = IR_CONST_BIAS + knum;
 1212|  10.5k|    break;
 1213|  10.5k|  }
 1214|    917|  case ISLTE: {
 1215|    917|    uint32_t op1 = record_stack_load(INS_B(i), frame);
 1216|    917|    uint32_t op2 = record_stack_load(INS_C(i), frame);
 1217|    917|    int64_t v1 = frame[INS_B(i)];
 1218|    917|    int64_t v2 = frame[INS_C(i)];
 1219|    [0;35m917[0m|    if (get_object_ir_type(v1) == FLONUM_TAG ||
 1220|    [0;35m917[0m|        get_object_ir_type(v2) == FLONUM_TAG) [0;41m{[0m
 1221|      0|[0;41m      if ([0m[0;41mverbose[0m[0;41m)[0m
 1222|      0|[0;41m        [0m[0;41mprintf("Record abort: flonum not supported in islt\n")[0m[0;41m;[0m
 1223|      0|[0;41m      record_abort();[0m
 1224|      0|[0;41m      return 1;[0m
 1225|      0|[0;41m    }[0m
 1226|    [0;35m917[0m|    int64_t c = FALSE_REP;
 1227|    917|    uint8_t op = IR_GT;
 1228|    [0;35m917[0m|    if (v1 <= v2) {
 1229|    759|      c = TRUE_REP;
 1230|    759|      op = IR_LE;
 1231|    759|    }
 1232|    [0;35m917[0m|    auto knum = arrlen(trace->consts);
 1233|    917|    arrput(trace->consts, c);
 1234|    917|    push_ir(trace, op, op1, op2, UNDEFINED_TAG);
 1235|    [0;35m917[0m|    regs[INS_A(i)] = IR_CONST_BIAS + knum;
 1236|    917|    break;
 1237|    917|  }
 1238|  1.42k|  case ISLT: {
 1239|  1.42k|    uint32_t op1 = record_stack_load(INS_B(i), frame);
 1240|  1.42k|    uint32_t op2 = record_stack_load(INS_C(i), frame);
 1241|  1.42k|    int64_t v1 = frame[INS_B(i)];
 1242|  1.42k|    int64_t v2 = frame[INS_C(i)];
 1243|  [0;35m1.42k[0m|    if (get_object_ir_type(v1) == FLONUM_TAG ||
 1244|  [0;35m1.42k[0m|        get_object_ir_type(v2) == FLONUM_TAG) {
 1245|    589|      if (verbose)
 1246|      0|        [0;41mprintf("Record abort: flonum not supported in islt\n")[0m;
 1247|    589|      record_abort();
 1248|    589|      return 1;
 1249|    589|    }
 1250|    [0;35m839[0m|    int64_t c = FALSE_REP;
 1251|    839|    uint8_t op = IR_GE;
 1252|    [0;35m839[0m|    if (v1 < v2) {
 1253|    344|      c = TRUE_REP;
 1254|    344|      op = IR_LT;
 1255|    344|    }
 1256|    [0;35m839[0m|    auto knum = arrlen(trace->consts);
 1257|    839|    arrput(trace->consts, c);
 1258|    839|    push_ir(trace, op, op1, op2, UNDEFINED_TAG);
 1259|    [0;35m839[0m|    regs[INS_A(i)] = IR_CONST_BIAS + knum;
 1260|    839|    break;
 1261|  1.42k|  }
 1262|     74|  case ISGT: {
 1263|     74|    uint32_t op1 = record_stack_load(INS_B(i), frame);
 1264|     74|    uint32_t op2 = record_stack_load(INS_C(i), frame);
 1265|     74|    int64_t v1 = frame[INS_B(i)];
 1266|     74|    int64_t v2 = frame[INS_C(i)];
 1267|     [0;35m74[0m|    if (get_object_ir_type(v1) == FLONUM_TAG ||
 1268|     [0;35m74[0m|        get_object_ir_type(v2) == FLONUM_TAG) {
 1269|     33|      if (verbose)
 1270|      0|        [0;41mprintf("Record abort: flonum not supported in islt\n")[0m;
 1271|     33|      record_abort();
 1272|     33|      return 1;
 1273|     33|    }
 1274|     [0;35m41[0m|    int64_t c = FALSE_REP;
 1275|     41|    uint8_t op = IR_LE;
 1276|     [0;35m41[0m|    if (v1 > v2) {
 1277|     38|      c = TRUE_REP;
 1278|     38|      op = IR_GT;
 1279|     38|    }
 1280|     [0;35m41[0m|    auto knum = arrlen(trace->consts);
 1281|     41|    arrput(trace->consts, c);
 1282|     41|    push_ir(trace, op, op1, op2, UNDEFINED_TAG);
 1283|     [0;35m41[0m|    regs[INS_A(i)] = IR_CONST_BIAS + knum;
 1284|     41|    break;
 1285|     74|  }
 1286|    112|  case ISGTE: {
 1287|    112|    uint32_t op1 = record_stack_load(INS_B(i), frame);
 1288|    112|    uint32_t op2 = record_stack_load(INS_C(i), frame);
 1289|    112|    int64_t v1 = frame[INS_B(i)];
 1290|    112|    int64_t v2 = frame[INS_C(i)];
 1291|    [0;35m112[0m|    if (get_object_ir_type(v1) == FLONUM_TAG ||
 1292|    [0;35m112[0m|        get_object_ir_type(v2) == FLONUM_TAG) [0;41m{[0m
 1293|      0|[0;41m      if ([0m[0;41mverbose[0m[0;41m)[0m
 1294|      0|[0;41m        [0m[0;41mprintf("Record abort: flonum not supported in islt\n")[0m[0;41m;[0m
 1295|      0|[0;41m      record_abort();[0m
 1296|      0|[0;41m      return 1;[0m
 1297|      0|[0;41m    }[0m
 1298|    [0;35m112[0m|    int64_t c = FALSE_REP;
 1299|    112|    uint8_t op = IR_LT;
 1300|    [0;35m112[0m|    if (v1 >= v2) {
 1301|     30|      c = TRUE_REP;
 1302|     30|      op = IR_GE;
 1303|     30|    }
 1304|    [0;35m112[0m|    auto knum = arrlen(trace->consts);
 1305|    112|    arrput(trace->consts, c);
 1306|    112|    push_ir(trace, op, op1, op2, UNDEFINED_TAG);
 1307|    [0;35m112[0m|    regs[INS_A(i)] = IR_CONST_BIAS + knum;
 1308|    112|    break;
 1309|    112|  }
 1310|  5.68k|  case GUARD: {
 1311|  5.68k|    uint32_t op1 = record_stack_load(INS_B(i), frame);
 1312|  5.68k|    int64_t v = frame[INS_B(i)];
 1313|  [0;35m5.68k[0m|    auto type = INS_C(i);
 1314|  5.68k|    int64_t c = FALSE_REP;
 1315|  5.68k|    auto obj_type = get_object_ir_type(v);
 1316|  [0;35m5.68k[0m|    if (obj_type == type) {
 1317|  3.26k|      c = TRUE_REP;
 1318|  3.26k|    }
 1319|  [0;35m5.68k[0m|    auto knum = arrlen(trace->consts);
 1320|  5.68k|    arrput(trace->consts, c);
 1321|  [0;35m5.68k[0m|    regs[INS_A(i)] = IR_CONST_BIAS + knum;
 1322|  5.68k|    break;
 1323|    112|  }
 1324|    632|  case JNGUARD: {
 1325|    632|    record_stack_load(INS_B(i), frame);
 1326|    632|    uint8_t type = get_object_ir_type(frame[INS_B(i)]);
 1327|    [0;35m632[0m|    if (type != INS_C(i)) {
 1328|    551|      add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 2, depth);
 1329|    551|    } else {
 1330|     81|      add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 1 + INS_D(*(pc+1)), depth);
 1331|     81|    }
 1332|    632|    break;
 1333|    112|  }
 1334|  38.2k|  case JGUARD: {
 1335|  38.2k|    record_stack_load(INS_B(i), frame);
 1336|  38.2k|    uint8_t type = get_object_ir_type(frame[INS_B(i)]);
 1337|  [0;35m38.2k[0m|    if (type == INS_C(i)) {
 1338|  19.4k|      add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 2, depth);
 1339|  19.4k|    } else {
 1340|  18.7k|      add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 1 + INS_D(*(pc+1)), depth);
 1341|  18.7k|    }
 1342|  38.2k|    break;
 1343|    112|  }
 1344|  48.9k|  case KONST: {
 1345|  [0;35m48.9k[0m|    auto k = const_table[INS_D(i)];
 1346|  [0;35m48.9k[0m|    auto reg = INS_A(i);
 1347|  [0;35m48.9k[0m|    auto knum = arrlen(trace->consts);
 1348|  48.9k|    arrput(trace->consts, k);
 1349|  48.9k|    regs[reg] = IR_CONST_BIAS + knum;
 1350|  48.9k|    break;
 1351|    112|  }
 1352|  11.2k|  case KFUNC: {
 1353|  [0;35m11.2k[0m|    auto k = (long)funcs[INS_D(i)];
 1354|  [0;35m11.2k[0m|    auto reg = INS_A(i);
 1355|  [0;35m11.2k[0m|    auto knum = arrlen(trace->consts);
 1356|  11.2k|    arrput(trace->consts, k);
 1357|  11.2k|    regs[reg] = IR_CONST_BIAS + knum;
 1358|  11.2k|    break;
 1359|    112|  }
 1360|  2.11k|  case VECTOR_SET: {
 1361|  [0;35m2.11k[0m|    auto vec = record_stack_load(INS_A(i), frame);
 1362|  [0;35m2.11k[0m|    auto idx = record_stack_load(INS_B(i), frame);
 1363|  [0;35m2.11k[0m|    auto obj = record_stack_load(INS_C(i), frame);
 1364|       |
 1365|  2.11k|    push_ir(trace, IR_ABC, vec, idx, IR_INS_TYPE_GUARD);
 1366|  2.11k|    auto vref = push_ir(trace, IR_VREF, vec, idx, 0);
 1367|  2.11k|    push_ir(trace, IR_STORE, vref, obj, 0);
 1368|       |
 1369|       |    // Record state because of IR_STORE
 1370|  2.11k|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 1, depth);
 1371|       |
 1372|  2.11k|    break;
 1373|    112|  }
 1374|  22.5k|  case VECTOR_REF: {
 1375|  [0;35m22.5k[0m|    auto vec = record_stack_load(INS_B(i), frame);
 1376|  [0;35m22.5k[0m|    auto idx = record_stack_load(INS_C(i), frame);
 1377|       |
 1378|  22.5k|    push_ir(trace, IR_ABC, vec, idx, IR_INS_TYPE_GUARD);
 1379|  22.5k|    auto vref = push_ir(trace, IR_VREF, vec, idx, 0);
 1380|       |
 1381|  22.5k|    uint64_t pos = frame[INS_C(i)] >> 3;
 1382|  [0;35m22.5k[0m|    vector_s *vec_d = (vector_s *)(frame[INS_B(i)] - PTR_TAG);
 1383|  22.5k|    uint8_t type = get_object_ir_type(vec_d->v[pos]);
 1384|  [0;35m22.5k[0m|    regs[INS_A(i)] = push_ir(trace, IR_LOAD, vref, 0, IR_INS_TYPE_GUARD | type);
 1385|       |
 1386|  22.5k|    break;
 1387|    112|  }
 1388|  1.10k|  case STRING_REF: {
 1389|  [0;35m1.10k[0m|    auto str = record_stack_load(INS_B(i), frame);
 1390|  [0;35m1.10k[0m|    auto idx = record_stack_load(INS_C(i), frame);
 1391|       |
 1392|  1.10k|    push_ir(trace, IR_ABC, str, idx, IR_INS_TYPE_GUARD);
 1393|  [0;35m1.10k[0m|    regs[INS_A(i)] = push_ir(trace, IR_STRLD, str, idx, CHAR_TAG);
 1394|       |
 1395|  1.10k|    break;
 1396|    112|  }
 1397|    669|  case STRING_SET: {
 1398|    [0;35m669[0m|    auto str = record_stack_load(INS_A(i), frame);
 1399|    [0;35m669[0m|    auto idx = record_stack_load(INS_B(i), frame);
 1400|    [0;35m669[0m|    auto val = record_stack_load(INS_C(i), frame);
 1401|       |
 1402|    669|    push_ir(trace, IR_ABC, str, idx, IR_INS_TYPE_GUARD);
 1403|    669|    auto ref = push_ir(trace, IR_STRREF, str, idx, 0);
 1404|    669|    push_ir(trace, IR_STRST, ref, val, 0);
 1405|       |
 1406|    669|    break;
 1407|    112|  }
 1408|  11.2k|  case CLOSURE: {
 1409|  11.2k|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc, depth);
 1410|       |    //  TODO this forces a side exit without recording.
 1411|       |    //   Put GC inline in generated code?  Would have to flush
 1412|       |    //   all registers to stack.
 1413|  11.2k|    trace->snaps[arrlen(trace->snaps) - 1].exits = 255;
 1414|       |    // TODO fixed closz
 1415|  11.2k|    long closz = (frame[INS_A(i) + 1] >> 3) + 1;
 1416|  [0;35m11.2k[0m|    auto knum = arrlen(trace->consts);
 1417|  11.2k|    arrput(trace->consts, (sizeof(long) * (closz + 2)) << 3);
 1418|  [0;35m11.2k[0m|    auto cell = push_ir(trace, IR_ALLOC, knum | IR_CONST_BIAS, CLOSURE_TAG, CLOSURE_TAG);
 1419|  [0;35m11.2k[0m|    auto ref = push_ir(trace, IR_REF, cell, 8 - CLOSURE_TAG, UNDEFINED_TAG);
 1420|  11.2k|    knum = arrlen(trace->consts);
 1421|  11.2k|    arrput(trace->consts, (long)closz << 3);
 1422|  11.2k|    push_ir(trace, IR_STORE, ref, knum | IR_CONST_BIAS, 0);
 1423|  [0;35m11.2k[0m|    auto a = record_stack_load(INS_A(i), frame);
 1424|       |    // TODO
 1425|       |    // The first value *must* be the function ptr.
 1426|       |    // THe rest of the values are just *something*
 1427|       |    // so that if we abort, there is a valid GC object.
 1428|       |    // Could also be 0-initialized.
 1429|       |    // TODO figure out a way to ensure we always snapshpt
 1430|       |    // after fully setting? I.e. don't abort ever?
 1431|  [0;35m49.0k[0m|    for (long j = 0; j < closz; j++) {
 1432|  37.7k|      ref =
 1433|  [0;35m37.7k[0m|          push_ir(trace, IR_REF, cell, 16 + 8 * j - CLOSURE_TAG, UNDEFINED_TAG);
 1434|  37.7k|      push_ir(trace, IR_STORE, ref, a, 0);
 1435|  37.7k|    }
 1436|  11.2k|    regs[INS_A(i)] = cell;
 1437|       |    /* for(unsigned j = 1; j < INS_B(i); j++) { */
 1438|       |    /*   regs[INS_A(i) + j] = -1; */
 1439|       |    /* } */
 1440|  11.2k|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 1, depth);
 1441|  11.2k|    break;
 1442|    112|  }
 1443|  1.05k|  case BOX:
 1444|  9.42k|  case CONS: {
 1445|  [0;35m9.42k[0m|    auto a = record_stack_load(INS_B(i), frame);
 1446|  9.42k|    int b;
 1447|  [0;35m9.42k[0m|    if (INS_OP(i) == CONS) {
 1448|  8.37k|      b = record_stack_load(INS_C(i), frame);
 1449|  8.37k|    } else {
 1450|       |      // BOX
 1451|  [0;35m1.05k[0m|      auto knum = arrlen(trace->consts);
 1452|  1.05k|      arrput(trace->consts, NIL_TAG);
 1453|  1.05k|      b = knum | IR_CONST_BIAS;
 1454|  1.05k|    }
 1455|  9.42k|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc, depth);
 1456|       |    //  TODO this forces a side exit without recording.
 1457|       |    //   Put GC inline in generated code?  Would have to flush
 1458|       |    //   all registers to stack.
 1459|  9.42k|    trace->snaps[arrlen(trace->snaps) - 1].exits = 255;
 1460|  [0;35m9.42k[0m|    auto knum = arrlen(trace->consts);
 1461|  9.42k|    arrput(trace->consts, sizeof(cons_s) << 3);
 1462|  [0;35m9.42k[0m|    auto cell = push_ir(trace, IR_ALLOC, knum | IR_CONST_BIAS, CONS_TAG, CONS_TAG);
 1463|  9.42k|    regs[INS_A(i)] = cell;
 1464|  [0;35m9.42k[0m|    auto ref = push_ir(trace, IR_REF, cell, 8 - CONS_TAG, UNDEFINED_TAG);
 1465|  9.42k|    push_ir(trace, IR_STORE, ref, a, UNDEFINED_TAG);
 1466|  [0;35m9.42k[0m|    ref = push_ir(trace, IR_REF, cell, 8 + 8 - CONS_TAG, UNDEFINED_TAG);
 1467|  9.42k|    push_ir(trace, IR_STORE, ref, b, UNDEFINED_TAG);
 1468|  9.42k|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 1, depth);
 1469|       |
 1470|  9.42k|    break;
 1471|  1.05k|  }
 1472|    233|  case MAKE_STRING: {
 1473|    [0;35m233[0m|    auto sz = record_stack_load(INS_B(i), frame);
 1474|    [0;35m233[0m|    auto ch = record_stack_load(INS_C(i), frame);
 1475|       |
 1476|    233|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc, depth);
 1477|       |    //  TODO this forces a side exit without recording.
 1478|       |    //   Put GC inline in generated code?  Would have to flush
 1479|       |    //   all registers to stack.
 1480|    233|    trace->snaps[arrlen(trace->snaps) - 1].exits = 255;
 1481|       |    
 1482|    [0;35m233[0m|    auto knum = arrlen(trace->consts);
 1483|    233|    arrput(trace->consts, ((sizeof(long)*2) + 1 + 7 /* ptr align */) << 3);
 1484|    [0;35m233[0m|    auto alloc_sz = push_ir(trace, IR_ADD, sz, knum | IR_CONST_BIAS, FIXNUM_TAG);
 1485|    233|    knum = arrlen(trace->consts);
 1486|    233|    arrput(trace->consts, (unsigned long)(~TAG_MASK) << 3);
 1487|    [0;35m233[0m|    auto alloc_sz_aligned = push_ir(trace, IR_AND, alloc_sz, knum | IR_CONST_BIAS, FIXNUM_TAG);
 1488|       |    // TODO snaps??
 1489|    [0;35m233[0m|    auto cell = push_ir(trace, IR_ALLOC, alloc_sz_aligned, PTR_TAG, STRING_TAG);
 1490|       |
 1491|    [0;35m233[0m|    auto ref = push_ir(trace, IR_REF, cell, 8 - PTR_TAG, UNDEFINED_TAG);
 1492|    233|    push_ir(trace, IR_STORE, ref, sz, UNDEFINED_TAG);
 1493|    233|    regs[INS_A(i)] = cell;
 1494|       |
 1495|       |    // Set the string values to ch
 1496|       |    // Basically using memset, because that's what gcc/clang would do.
 1497|       |    // TODO could optimize away if sz = 0 or ch isn't passed (i.e. (make-string 100))
 1498|    [0;35m233[0m|    auto arg = push_ir(trace, IR_CARG, cell, ch, UNDEFINED_TAG);
 1499|    233|    knum = arrlen(trace->consts);
 1500|    233|    arrput(trace->consts, (long)vm_make_string);
 1501|    [0;35m233[0m|    push_ir(trace, IR_CALLXS, arg, knum | IR_CONST_BIAS, UNDEFINED_TAG);
 1502|    233|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc+1, depth);
 1503|       |
 1504|    233|    break;
 1505|  1.05k|  }
 1506|    201|  case MAKE_VECTOR: {
 1507|    [0;35m201[0m|    auto sz = record_stack_load(INS_B(i), frame);
 1508|    [0;35m201[0m|    auto ch = record_stack_load(INS_C(i), frame);
 1509|       |
 1510|    201|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc, depth);
 1511|       |    //  TODO this forces a side exit without recording.
 1512|       |    //   Put GC inline in generated code?  Would have to flush
 1513|       |    //   all registers to stack.
 1514|    201|    trace->snaps[arrlen(trace->snaps) - 1].exits = 255;
 1515|       |    
 1516|    [0;35m201[0m|    auto knum = arrlen(trace->consts);
 1517|    201|    arrput(trace->consts, (2) << 3);
 1518|    [0;35m201[0m|    auto alloc_sz = push_ir(trace, IR_ADD, sz, knum | IR_CONST_BIAS, FIXNUM_TAG);
 1519|    201|    knum = arrlen(trace->consts);
 1520|    201|    arrput(trace->consts, (unsigned long)(8) << 3);
 1521|    [0;35m201[0m|    auto alloc_sz_aligned = push_ir(trace, IR_MUL, alloc_sz, knum | IR_CONST_BIAS, FIXNUM_TAG);
 1522|       |    // TODO snaps??
 1523|    [0;35m201[0m|    auto cell = push_ir(trace, IR_ALLOC, alloc_sz_aligned, PTR_TAG, VECTOR_TAG);
 1524|       |
 1525|    [0;35m201[0m|    auto ref = push_ir(trace, IR_REF, cell, 8 - PTR_TAG, UNDEFINED_TAG);
 1526|    201|    push_ir(trace, IR_STORE, ref, sz, UNDEFINED_TAG);
 1527|    201|    regs[INS_A(i)] = cell;
 1528|       |
 1529|    [0;35m201[0m|    auto arg = push_ir(trace, IR_CARG, cell, ch, UNDEFINED_TAG);
 1530|    201|    knum = arrlen(trace->consts);
 1531|    201|    arrput(trace->consts, (long)vm_make_vector);
 1532|    [0;35m201[0m|    push_ir(trace, IR_CALLXS, arg, knum | IR_CONST_BIAS, UNDEFINED_TAG);
 1533|    201|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc+1, depth);
 1534|       |
 1535|    201|    break;
 1536|  1.05k|  }
 1537|  2.27k|  case VECTOR: {
 1538|  [0;35m2.27k[0m|    auto len = INS_B(i);
 1539|  [0;35m2.27k[0m|    auto reg = INS_A(i);
 1540|  2.27k|    int *loaded = NULL;
 1541|  [0;35m11.4k[0m|    for (uint32_t cnt = 0; cnt < len; cnt++) {
 1542|  9.16k|      arrput(loaded, record_stack_load(reg + cnt, frame));
 1543|  9.16k|    }
 1544|  2.27k|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc, depth);
 1545|       |    //  TODO this forces a side exit without recording.
 1546|       |    //   Put GC inline in generated code?  Would have to flush
 1547|       |    //   all registers to stack.
 1548|  2.27k|    trace->snaps[arrlen(trace->snaps) - 1].exits = 255;
 1549|       |
 1550|  [0;35m2.27k[0m|    auto knum = arrlen(trace->consts);
 1551|  2.27k|    arrput(trace->consts, (sizeof(vector_s) + 8 * len) << 3);
 1552|  [0;35m2.27k[0m|    auto cell = push_ir(trace, IR_ALLOC, knum | IR_CONST_BIAS, PTR_TAG,
 1553|  2.27k|                        VECTOR_TAG);
 1554|  2.27k|    regs[reg] = cell;
 1555|  [0;35m2.27k[0m|    auto ref = push_ir(trace, IR_REF, cell, 8 - PTR_TAG, UNDEFINED_TAG);
 1556|  2.27k|    knum = arrlen(trace->consts);
 1557|  2.27k|    arrput(trace->consts, (long)(len << 3));
 1558|  [0;35m2.27k[0m|    push_ir(trace, IR_STORE, ref, knum | IR_CONST_BIAS, UNDEFINED_TAG);
 1559|  [0;35m11.4k[0m|    for (uint32_t cnt = 0; cnt < len; cnt++) {
 1560|  [0;35m9.16k[0m|      ref = push_ir(trace, IR_REF, cell, 16 + cnt * 8 - PTR_TAG, UNDEFINED_TAG);
 1561|  9.16k|      push_ir(trace, IR_STORE, ref, loaded[cnt], UNDEFINED_TAG);
 1562|  9.16k|    }
 1563|  2.27k|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 1, depth);
 1564|  2.27k|    arrfree(loaded);
 1565|       |
 1566|  2.27k|    break;
 1567|  1.05k|  }
 1568|   135k|  case MOV: {
 1569|   [0;35m135k[0m|    regs[INS_A(i)] = record_stack_load(INS_B(i), frame);
 1570|       |    // TODO loop moves can clear
 1571|       |    // regs[INS_B(i)] = -1;
 1572|   135k|    break;
 1573|  1.05k|  }
 1574|    181|  case READ: {
 1575|    [0;35m181[0m|    port_s *port = (port_s *)(frame[INS_B(i)] - PTR_TAG);
 1576|    181|    uint8_t type = CHAR_TAG;
 1577|       |    // TODO peek instead.
 1578|    [0;35m181[0m|    if (port->eof == TRUE_REP) {
 1579|     14|      type = EOF_TAG;
 1580|     14|    }
 1581|    [0;35m181[0m|    auto knum = arrlen(trace->consts);
 1582|    181|    arrput(trace->consts, (long)vm_read_char);
 1583|    181|    regs[INS_A(i)] =
 1584|    181|        push_ir(trace, IR_CALLXS, record_stack_load(INS_B(i), frame),
 1585|    [0;35m181[0m|                knum | IR_CONST_BIAS, type | IR_INS_TYPE_GUARD);
 1586|    181|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 1, depth);
 1587|    181|    break;
 1588|  1.05k|  }
 1589|    865|  case PEEK: {
 1590|    [0;35m865[0m|    port_s *port = (port_s *)(frame[INS_B(i)] - PTR_TAG);
 1591|    865|    uint8_t type = CHAR_TAG;
 1592|       |    // TODO peek instead.
 1593|    [0;35m865[0m|    if (port->eof == TRUE_REP) {
 1594|    224|      type = EOF_TAG;
 1595|    224|    }
 1596|    [0;35m865[0m|    auto knum = arrlen(trace->consts);
 1597|    865|    arrput(trace->consts, (long)vm_peek_char);
 1598|    865|    regs[INS_A(i)] =
 1599|    865|        push_ir(trace, IR_CALLXS, record_stack_load(INS_B(i), frame),
 1600|    [0;35m865[0m|                knum | IR_CONST_BIAS, type | IR_INS_TYPE_GUARD);
 1601|    865|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 1, depth);
 1602|    865|    break;
 1603|  1.05k|  }
 1604|    517|  case WRITE: {
 1605|    [0;35m517[0m|    auto arg = push_ir(trace, IR_CARG, record_stack_load(INS_B(i), frame),
 1606|    [0;35m517[0m|                       record_stack_load(INS_C(i), frame), UNDEFINED_TAG);
 1607|    [0;35m517[0m|    auto knum = arrlen(trace->consts);
 1608|    517|    arrput(trace->consts, (long)vm_write);
 1609|    [0;35m517[0m|    push_ir(trace, IR_CALLXS, arg, knum | IR_CONST_BIAS, UNDEFINED_TAG);
 1610|    517|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 1, depth);
 1611|    517|    break;
 1612|  1.05k|  }
 1613|  99.8k|  case GGET: {
 1614|       |    // TODO check it is set?
 1615|  99.8k|    long gp = const_table[INS_D(i)];
 1616|       |
 1617|  [0;35m99.8k[0m|    auto knum = arrlen(trace->consts);
 1618|  99.8k|    arrput(trace->consts, gp);
 1619|  99.8k|    symbol *sym = (symbol *)(gp - SYMBOL_TAG);
 1620|  99.8k|    uint8_t type = get_object_ir_type(sym->val);
 1621|  [0;35m99.8k[0m|    regs[INS_A(i)] = push_ir(trace, IR_GGET, knum | IR_CONST_BIAS, IR_NONE,
 1622|  99.8k|                             type | IR_INS_TYPE_GUARD);
 1623|  99.8k|    break;
 1624|  1.05k|  }
 1625|  2.00k|  case GSET: {
 1626|  2.00k|    long gp = const_table[INS_D(i)];
 1627|  [0;35m2.00k[0m|    auto knum = arrlen(trace->consts);
 1628|  2.00k|    arrput(trace->consts, gp);
 1629|  2.00k|    push_ir(trace, IR_GSET, knum | IR_CONST_BIAS,
 1630|  [0;35m2.00k[0m|            record_stack_load(INS_A(i), frame), UNDEFINED_TAG);
 1631|       |    // We've changed global state, add a snap.
 1632|  2.00k|    add_snap(regs_list, (int)(regs - regs_list - 1), trace, pc + 1, depth);
 1633|  2.00k|    break;
 1634|  1.05k|  }
 1635|  2.34k|  case SUBVN: {
 1636|  [0;35m2.34k[0m|    auto knum = arrlen(trace->consts);
 1637|  2.34k|    arrput(trace->consts, ((int64_t)((int8_t)INS_C(i))) << 3);
 1638|  [0;35m2.34k[0m|    auto op1 = record_stack_load(INS_B(i), frame);
 1639|  2.34k|    uint8_t type = 0;
 1640|  [0;35m2.34k[0m|    if (op1 >= IR_CONST_BIAS) {
 1641|     [0;35m65[0m|      type = trace->consts[op1 - IR_CONST_BIAS] & TAG_MASK;
 1642|  2.28k|    } else {
 1643|  2.28k|      type = trace->ops[op1].type & ~IR_INS_TYPE_GUARD;
 1644|  2.28k|    }
 1645|  [0;35m2.34k[0m|    if (type != 0) [0;41m{[0m
 1646|      0|[0;41m      if ([0m[0;41mverbose[0m[0;41m)[0m
 1647|      0|[0;41m        [0m[0;41mprintf("Record abort: Only int supported in trace: %i\n", type)[0m[0;41m;[0m
 1648|      0|[0;41m      record_abort();[0m
 1649|      0|[0;41m      return 1;[0m
 1650|      0|[0;41m    }[0m
 1651|  [0;35m2.34k[0m|    regs[INS_A(i)] = push_ir(trace, IR_SUB, op1, knum | IR_CONST_BIAS,
 1652|  2.34k|                             IR_INS_TYPE_GUARD | type);
 1653|  2.34k|    break;
 1654|  2.34k|  }
 1655|  5.97k|  case ADDVN: {
 1656|       |    // TODO check type
 1657|  [0;35m5.97k[0m|    auto knum = arrlen(trace->consts);
 1658|  5.97k|    arrput(trace->consts, ((int64_t)((int8_t)INS_C(i))) << 3);
 1659|  [0;35m5.97k[0m|    auto op1 = record_stack_load(INS_B(i), frame);
 1660|  5.97k|    uint8_t type = 0;
 1661|  [0;35m5.97k[0m|    if (op1 >= IR_CONST_BIAS) {
 1662|    [0;35m196[0m|      type = trace->consts[op1 - IR_CONST_BIAS] & TAG_MASK;
 1663|  5.77k|    } else {
 1664|  5.77k|      type = trace->ops[op1].type & ~IR_INS_TYPE_GUARD;
 1665|  5.77k|    }
 1666|  [0;35m5.97k[0m|    if (type != 0) [0;41m{[0m
 1667|      0|[0;41m      if ([0m[0;41mverbose[0m[0;41m)[0m
 1668|      0|[0;41m        [0m[0;41mprintf("Record abort: Only int supported in trace: %i\n", type)[0m[0;41m;[0m
 1669|      0|[0;41m      record_abort();[0m
 1670|      0|[0;41m      return 1;[0m
 1671|      0|[0;41m    }[0m
 1672|  [0;35m5.97k[0m|    regs[INS_A(i)] = push_ir(trace, IR_ADD, op1, knum | IR_CONST_BIAS,
 1673|  5.97k|                             type | IR_INS_TYPE_GUARD);
 1674|  5.97k|    break;
 1675|  5.97k|  }
 1676|  1.90k|  case ADDVV: {
 1677|  [0;35m1.90k[0m|    auto op1 = record_stack_load(INS_B(i), frame);
 1678|  [0;35m1.90k[0m|    auto op2 = record_stack_load(INS_C(i), frame);
 1679|       |    // TODO: Assume no type change??
 1680|  1.90k|    uint8_t type = 0;
 1681|  [0;35m1.90k[0m|    if (op1 >= IR_CONST_BIAS) {
 1682|    [0;35m498[0m|      type = trace->consts[op1 - IR_CONST_BIAS] & TAG_MASK;
 1683|  1.41k|    } else {
 1684|  1.41k|      type = trace->ops[op1].type & ~IR_INS_TYPE_GUARD;
 1685|  1.41k|    }
 1686|  [0;35m1.90k[0m|    if (type != 0) {
 1687|    134|      if (verbose)
 1688|      0|        [0;41mprintf("Record abort: Only int supported in trace: %i\n", type)[0m;
 1689|    134|      record_abort();
 1690|    134|      return 1;
 1691|    134|    }
 1692|  [0;35m1.77k[0m|    regs[INS_A(i)] = push_ir(trace, IR_ADD, op1, op2, IR_INS_TYPE_GUARD | type);
 1693|  1.77k|    break;
 1694|  1.90k|  }
 1695|  2.13k|  case SUBVV: {
 1696|  [0;35m2.13k[0m|    auto op1 = record_stack_load(INS_B(i), frame);
 1697|  [0;35m2.13k[0m|    auto op2 = record_stack_load(INS_C(i), frame);
 1698|       |    // TODO: Assume no type change??
 1699|  2.13k|    uint8_t type = 0;
 1700|  [0;35m2.13k[0m|    if (op1 >= IR_CONST_BIAS) {
 1701|     [0;35m34[0m|      type = trace->consts[op1 - IR_CONST_BIAS] & TAG_MASK;
 1702|  2.09k|    } else {
 1703|  2.09k|      type = trace->ops[op1].type & ~IR_INS_TYPE_GUARD;
 1704|  2.09k|    }
 1705|  [0;35m2.13k[0m|    if (type != 0) {
 1706|    777|      if (verbose)
 1707|      0|        [0;41mprintf("Record abort: Only int supported in trace: %i\n", type)[0m;
 1708|    777|      record_abort();
 1709|    777|      return 1;
 1710|    777|    }
 1711|  [0;35m1.35k[0m|    regs[INS_A(i)] = push_ir(trace, IR_SUB, op1, op2, IR_INS_TYPE_GUARD | type);
 1712|  1.35k|    break;
 1713|  2.13k|  }
 1714|  3.42k|  case MULVV:
 1715|  4.33k|  case REM:
 1716|  5.95k|  case DIV: {
 1717|  [0;35m5.95k[0m|    auto op1 = record_stack_load(INS_B(i), frame);
 1718|  [0;35m5.95k[0m|    auto op2 = record_stack_load(INS_C(i), frame);
 1719|       |    // TODO: Assume no type change??
 1720|  5.95k|    uint8_t type = 0;
 1721|  [0;35m5.95k[0m|    if (get_object_ir_type(frame[INS_B(i)]) != 0 ||
 1722|  [0;35m5.95k[0m|        get_object_ir_type(frame[INS_C(i)]) != 0) {
 1723|  2.33k|      if (verbose)
 1724|      0|        [0;41mprintf("Record abort: Only int supported in trace: %i\n", type)[0m;
 1725|  2.33k|      record_abort();
 1726|  2.33k|      return 1;
 1727|  2.33k|    }
 1728|  3.62k|    uint8_t op = IR_DIV;
 1729|  [0;35m3.62k[0m|    if (INS_OP(i) == REM) {
 1730|    913|      op = IR_REM;
 1731|  [0;35m2.70k[0m|    } else if (INS_OP(i) == MULVV) {
 1732|  1.21k|      op = IR_MUL;
 1733|  1.21k|    }
 1734|  3.62k|    regs[INS_A(i)] = push_ir(trace, op, op1, op2, type);
 1735|  3.62k|    break;
 1736|  5.95k|  }
 1737|  1.46k|  case EXACT: {
 1738|  [0;35m1.46k[0m|    regs[INS_A(i)] = record_stack_load(INS_B(i), frame);
 1739|  [0;35m1.46k[0m|    auto type = get_object_ir_type(frame[INS_B(i)]);
 1740|  [0;35m1.46k[0m|    if (type != 0) [0;41m{[0m
 1741|      0|[0;41m      if ([0m[0;41mverbose[0m[0;41m)[0m
 1742|      0|[0;41m        [0m[0;41mprintf("Record abort: exact only supports fixnum\n")[0m[0;41m;[0m
 1743|      0|[0;41m      record_abort();[0m
 1744|      0|[0;41m      return 1;[0m
 1745|      0|[0;41m    }[0m
 1746|  1.46k|    break;
 1747|  1.46k|  }
 1748|  25.5k|  case CALLT: {
 1749|       |    // Check call type
 1750|  25.5k|    {
 1751|  [0;35m25.5k[0m|      auto clo = record_stack_load(INS_A(i) + 1, frame);
 1752|  [0;35m25.5k[0m|      auto ref = push_ir(trace, IR_REF, clo, 16 - CLOSURE_TAG, UNDEFINED_TAG);
 1753|  25.5k|      auto fun = push_ir(trace, IR_LOAD, ref, 0, 0);
 1754|  25.5k|      regs[INS_A(i)] = fun;
 1755|  [0;35m25.5k[0m|      auto cl = frame[INS_A(i) + 1];
 1756|  [0;35m25.5k[0m|      auto closure = (closure_s *)(cl - CLOSURE_TAG);
 1757|  [0;35m25.5k[0m|      auto knum = arrlen(trace->consts);
 1758|  25.5k|      arrput(trace->consts, closure->v[0]);
 1759|  [0;35m25.5k[0m|      push_ir(trace, IR_EQ, fun, knum | IR_CONST_BIAS, IR_INS_TYPE_GUARD);
 1760|  25.5k|    }
 1761|       |    /* { */
 1762|       |    /*   auto v = frame[INS_A(i) + 1]; */
 1763|       |    /*   auto knum = arrlen(trace->consts); */
 1764|       |    /*   arrput(trace->consts, v); */
 1765|       |    /*   ir_ins ins; */
 1766|       |    /*   ins.reg = REG_NONE; */
 1767|       |    /*   ins.op1 = record_stack_load(INS_A(i) + 1, frame); */
 1768|       |    /*   ins.op2 = knum | IR_CONST_BIAS; */
 1769|       |    /*   ins.op = IR_EQ; */
 1770|       |    /*   // TODO magic number */
 1771|       |    /*   ins.type = IR_INS_TYPE_GUARD | 0x5; */
 1772|       |    /*   arrput(trace->ops, ins); */
 1773|       |    /* } */
 1774|       |    // Move args down
 1775|       |    // TODO also chedck func
 1776|   [0;35m101k[0m|    for (int j = INS_A(i) + 1; j < INS_A(i) + INS_B(i); j++) {
 1777|  76.3k|      regs[j] = record_stack_load(j, frame);
 1778|  76.3k|    }
 1779|  [0;35m25.5k[0m|    memmove(&regs[0], &regs[INS_A(i) + 1], sizeof(int) * (INS_B(i) - 1));
 1780|  [0;35m6.20M[0m|    for (int j = INS_B(i) - 1; j < 256; j++) {
 1781|  [0;35m6.20M[0m|      if (&regs[j] >= regs_list + 256) {
 1782|  25.5k|        break;
 1783|  25.5k|      }
 1784|  6.17M|      regs[j] = -1;
 1785|  6.17M|    }
 1786|       |
 1787|  25.5k|    break;
 1788|  1.46k|  }
 1789|  1.00k|  case STRING_LENGTH:
 1790|  2.63k|  case VECTOR_LENGTH: {
 1791|  [0;35m2.63k[0m|    auto vec = record_stack_load(INS_B(i), frame);
 1792|  [0;35m2.63k[0m|    auto ref = push_ir(trace, IR_REF, vec, 8 - PTR_TAG, UNDEFINED_TAG);
 1793|  [0;35m2.63k[0m|    regs[INS_A(i)] = push_ir(trace, IR_LOAD, ref, 0, FIXNUM_TAG);
 1794|  2.63k|    break;
 1795|  1.00k|  }
 1796|  49.3k|  case CLOSURE_GET: {
 1797|  [0;35m49.3k[0m|    auto clo = record_stack_load(INS_B(i), frame);
 1798|  49.3k|    auto ref = push_ir(trace, IR_REF, clo,
 1799|  [0;35m49.3k[0m|                       16 + (8 * (1 + INS_C(i))) - CLOSURE_TAG, UNDEFINED_TAG);
 1800|       |
 1801|       |    // Note: Closure doesn't necessarily need typecheck since closures are
 1802|       |    // CONST. However, there are some situations where invalid code may hit bad
 1803|       |    // types? I.e. polymorphic functions could do a different STORE type?
 1804|       |    //
 1805|       |    // Actually, this is invalid: closures could close '() or a list, and still
 1806|       |    // be what code is expecting.
 1807|  49.3k|    uint64_t pos = INS_C(i) + 1;
 1808|  [0;35m49.3k[0m|    closure_s *clo_d = (closure_s *)(frame[INS_B(i)] - CLOSURE_TAG);
 1809|  49.3k|    uint8_t type = get_object_ir_type(clo_d->v[pos]);
 1810|       |
 1811|  [0;35m49.3k[0m|    regs[INS_A(i)] = push_ir(trace, IR_LOAD, ref, 0, IR_INS_TYPE_GUARD | type);
 1812|       |
 1813|       |    /* // TODO: closure may not be const */
 1814|       |    /* auto fb = frame[INS_B(i)]; */
 1815|       |    /* auto closure = (closure_s *)(fb - CLOSURE_TAG); */
 1816|       |
 1817|       |    /* auto knum = (int)arrlen(trace->consts); */
 1818|       |    /* arrput(trace->consts, closure->v[1 + INS_C(i)]); */
 1819|       |    /* regs[INS_A(i)] = knum | IR_CONST_BIAS; */
 1820|  49.3k|    break;
 1821|  1.00k|  }
 1822|  21.9k|  case CLOSURE_SET: {
 1823|  [0;35m21.9k[0m|    auto clo = record_stack_load(INS_A(i), frame);
 1824|  [0;35m21.9k[0m|    auto val = record_stack_load(INS_B(i), frame);
 1825|  21.9k|    auto ref = push_ir(trace, IR_REF, clo,
 1826|  [0;35m21.9k[0m|                       16 + (8 * (1 + INS_C(i))) - CLOSURE_TAG, UNDEFINED_TAG);
 1827|  21.9k|    push_ir(trace, IR_STORE, ref, val, UNDEFINED_TAG);
 1828|  21.9k|    break;
 1829|  1.00k|  }
 1830|  9.75k|  case JMP: {
 1831|  9.75k|    break;
 1832|  1.00k|  }
 1833|  65.3k|  case JFUNC: {
 1834|       |
 1835|       |    // Check if it is a returning trace
 1836|  [0;35m65.3k[0m|    auto *ctrace = trace_cache_get(INS_D(i));
 1837|  [0;35m65.3k[0m|    if (INS_OP(ctrace->startpc) == CLFUNC) {
 1838|  [0;35m3.69k[0m|      if (argcnt != INS_A(ctrace->startpc)) {
 1839|       |	// The check will fail, and we will fall through to a later
 1840|       |	// CLFUNC.
 1841|    655|        break;
 1842|    655|      }
 1843|  3.69k|    }
 1844|  [0;35m64.7k[0m|    if (INS_OP(ctrace->startpc) == CLFUNCV) {
 1845|      [0;35m3[0m|      if (argcnt < INS_A(ctrace->startpc)) [0;41m{[0m
 1846|       |[0;41m[0m	// The check will fail, and we will fall through to a later
 1847|       |	// CLFUNC.[0;41m[0m
 1848|      0|[0;41m        break;[0m
 1849|      0|[0;41m      }[0m
 1850|      3|    }
 1851|       |    // If it is a returning non-looping trace, trace through it.
 1852|  [0;35m64.7k[0m|    if (ctrace->link == -1) {
 1853|  61.5k|      assert(patchpc == nullptr);
 1854|  61.5k|      patchpc = pc;
 1855|  61.5k|      patchold = *pc;
 1856|  61.5k|      *pc = traces[INS_D(*pc)]->startpc;
 1857|       |
 1858|       |      // Check if it is a FUNCV and emit a list build if necessary.
 1859|  61.5k|      check_emit_funcv(*pc, pc, frame, argcnt);
 1860|  61.5k|      break;
 1861|  61.5k|    }
 1862|       |    // Otherwise, we're going to link to the JFUNC.
 1863|  [0;35m12.8k[0m|    for (int j = 0; j < INS_A(i); j++) {
 1864|  9.63k|      regs[j] = record_stack_load(j, frame);
 1865|  9.63k|    }
 1866|  3.17k|    if (verbose)
 1867|      0|      [0;41mprintf("Record stop JFUNC\n")[0m;
 1868|  3.17k|    check_emit_funcv(traces[INS_D(i)]->startpc, pc, frame, argcnt);
 1869|  3.17k|    record_stop(pc, frame, INS_D(i));
 1870|  3.17k|    return 1;
 1871|  64.7k|  }
 1872|  10.7k|  case JLOOP: {
 1873|  [0;35m10.7k[0m|    auto *ctrace = trace_cache_get(INS_D(i));
 1874|  [0;35m10.7k[0m|    if (side_exit == nullptr && INS_OP(ctrace->startpc) != RET1) {
 1875|  5.61k|      if (verbose)
 1876|      0|        [0;41mprintf("Record abort: root trace hit loop\n")[0m;
 1877|  5.61k|      record_abort();
 1878|  5.61k|      return 1;
 1879|  5.61k|    }
 1880|  [0;35m5.10k[0m|    if (verbose)
 1881|      0|      [0;41mprintf("Record stop hit JLOOP\n")[0m;
 1882|       |    // NOTE: stack load is for ret1 jloop returns.  Necessary?
 1883|       |    // TODO JLOOp also used for loop, only need to record for RET
 1884|  [0;35m5.10k[0m|    regs[INS_A(i)] = record_stack_load(INS_A(i), frame);
 1885|  5.10k|    record_stop(pc, frame, INS_D(i));
 1886|  5.10k|    return 1;
 1887|  10.7k|  }
 1888|  3.01k|  default: {
 1889|  3.01k|    bcfunc *fc = find_func_for_frame(pc);
 1890|  3.01k|    if (verbose)
 1891|      0|      [0;41mprintf("Record abort: NYI: CANT RECORD BYTECODE %s in %s\n",[0m
 1892|      [0;35m0[0m|[0;41m             ins_names[[0m[0;41mINS_OP[0m[0;41m(i)], [0m[0;41mfc[0m[0;41m ? [0m[0;41mfc->name[0m[0;41m : [0m[0;41m"???"[0m[0;41m)[0m;
 1893|  3.01k|    record_abort();
 1894|  3.01k|    return 1;
 1895|       |    // exit(-1);
 1896|  10.7k|  }
 1897|  1.04M|  }
 1898|  [0;35m1.01M[0m|  if (instr_count > 1000) {
 1899|     35|    if (verbose)
 1900|      0|      [0;41mprintf("Record abort: due to length\n")[0m;
 1901|     35|    record_abort();
 1902|     35|    return 1;
 1903|     35|  }
 1904|       |  // if (depth <= -3) {
 1905|       |  //   printf("Record stop [possible down-recursion]\n");
 1906|       |  //   return 1;
 1907|       |  // }
 1908|       |  // TODO check chain for down-recursion
 1909|       |  // TODO this should check regs depth
 1910|  [0;35m1.01M[0m|  if (depth >= 20) {
 1911|    223|    if (verbose)
 1912|      0|      [0;41mprintf("Record abort: (stack too deep)\n")[0m;
 1913|    223|    record_abort();
 1914|    223|    return 1;
 1915|    223|  }
 1916|  1.01M|  return 0;
 1917|  1.01M|}
 1918|       |
 1919|  2.72G|trace_s *trace_cache_get(unsigned int tnum) { return traces[tnum]; }
 1920|       |
 1921|     55|EXPORT void free_trace() {
 1922|     [0;35m55[0m|  if (verbose) [0;41m{[0m
 1923|      0|[0;41m    printf("Traces: %li\n", [0m[0;41marrlen[0m[0;41m(traces));[0m
 1924|      0|[0;41m  }[0m
 1925|  [0;35m10.0k[0m|  for(uint64_t i = 0; i < arrlen(traces); i++) {
 1926|   [0;35m111k[0m|    for(uint64_t j = 0; j < arrlen(traces[i]->snaps); j++) {
 1927|   101k|      free_snap(&traces[i]->snaps[j]);
 1928|   101k|    }
 1929|  10.0k|    arrfree(traces[i]->relocs);
 1930|  10.0k|    arrfree(traces[i]->ops);
 1931|  10.0k|    arrfree(traces[i]->consts);
 1932|  10.0k|    arrfree(traces[i]->snaps);
 1933|  10.0k|    free(traces[i]);
 1934|  10.0k|  }
 1935|     55|}

[0;36m/home/davejwatson/myprojects/boom/snap.c:
[0m    1|       |#include "snap.h"
    2|       |#include "asm_x64.h" // for REG_NONE
    3|       |#include "ir.h"      // for snap_s, snap_entry_s, ir_ins, trace_s, IR_CONST...
    4|       |#include "third-party/stb_ds.h"
    5|       |#include <stdint.h> // for uint32_t
    6|       |#include <stdio.h>  // for printf
    7|   155k|#define auto __auto_type
    8|       |
    9|       |void add_snap(const int *regs, int offset, trace_s *trace, uint32_t *pc,
   10|   286k|              uint32_t depth) {
   11|       |  // No need for duplicate snaps.
   12|   [0;35m286k[0m|  if ((arrlen(trace->snaps) != 0) &&
   13|   [0;35m286k[0m|      trace->snaps[arrlen(trace->snaps) - 1].ir == arrlen(trace->ops) &&
   14|   [0;35m286k[0m|      trace->snaps[arrlen(trace->snaps) - 1].pc == pc) {
   15|  9.22k|    return;
   16|  9.22k|  }
   17|   277k|  snap_s snap;
   18|   277k|  snap.ir = arrlen(trace->ops);
   19|   277k|  snap.pc = pc;
   20|   277k|  snap.offset = offset;
   21|   277k|  snap.exits = 0;
   22|   277k|  snap.link = -1;
   23|   277k|  snap.slots = NULL;
   24|   277k|  snap.depth = depth;
   25|   277k|  snap.argcnt = 1;
   26|       |  // TODO fix regs size/boj to vec?
   27|  [0;35m71.4M[0m|  for (int16_t i = 0; i < 257; i++) {
   28|  [0;35m71.2M[0m|    if (regs[i] != -1) {
   29|       |      // printf("Record snap entry %i val %i\n", i-1, regs[i]);
   30|  4.40M|      snap_entry_s entry;
   31|  4.40M|      entry.slot = (int16_t)(i - 1); // offset by one for callt
   32|  4.40M|      entry.val = regs[i];
   33|  4.40M|      arrput(snap.slots, entry);
   34|  4.40M|    }
   35|  71.2M|  }
   36|   [0;35m277k[0m|  if (arrlen(trace->snaps) > 0 && trace->snaps[arrlen(trace->snaps)-1].ir == snap.ir) {
   37|  41.2k|    snap_s sn = arrpop(trace->snaps);
   38|  41.2k|    free_snap(&sn);
   39|  41.2k|  }
   40|   277k|  arrput(trace->snaps, snap);
   41|   277k|}
   42|       |
   43|       |// Replay a snap for a side-trace.
   44|       |void snap_replay(int **regs, snap_s *snap, trace_s *parent, trace_s *trace,
   45|  12.2k|                 const long *frame, int *d) {
   46|  12.2k|  frame -= snap->offset;
   47|  [0;35m89.9k[0m|  for (uint64_t i = 0; i < arrlen(snap->slots); i++) {
   48|  77.7k|    auto slot = &snap->slots[i];
   49|  [0;35m77.7k[0m|    if ((slot->val & IR_CONST_BIAS) != 0) {
   50|  [0;35m15.4k[0m|      auto c = parent->consts[slot->val - IR_CONST_BIAS];
   51|       |      // Push const in new trace
   52|  15.4k|      int knum = arrlen(trace->consts);
   53|  15.4k|      arrput(trace->consts, c);
   54|  15.4k|      (*regs)[slot->slot] = knum | IR_CONST_BIAS;
   55|       |      // printf("Snap replay const %i %i\n", slot->slot, c);
   56|  62.2k|    } else {
   57|       |      // printf("Snap replay sload %i %i %li ptr %lx op %i\n", slot->slot,
   58|       |      // slot->val, frame[slot->slot], &frame[slot->val], arrlen(trace->ops));
   59|       |      //  Emit load
   60|  62.2k|      ir_ins ins;
   61|  62.2k|      ins.reg = REG_NONE;
   62|  62.2k|      ins.op1 = slot->slot;
   63|  62.2k|      ins.op = IR_SLOAD;
   64|  62.2k|      ins.slot = SLOT_NONE;
   65|       |      // TODO PARENT type, maybe inherit?
   66|  62.2k|      auto type = frame[slot->slot] & 0x7;
   67|  62.2k|      ins.type = type;
   68|  62.2k|      (*regs)[slot->slot] = arrlen(trace->ops);
   69|  62.2k|      arrput(trace->ops, ins);
   70|  62.2k|    }
   71|  77.7k|  }
   72|  12.2k|  *regs = *regs + snap->offset;
   73|  12.2k|  *d = snap->depth;
   74|  12.2k|}
   75|       |
   76|   277k|void free_snap(snap_s* snap) {
   77|   277k|  arrfree(snap->slots);
   78|   277k|}

[0;36m/home/davejwatson/myprojects/boom/symbol_table.c:
[0m    1|       |// Copyright 2023 Dave Watson
    2|       |
    3|       |#include "symbol_table.h"
    4|       |#include <assert.h> // for assert
    5|       |#include <stdbool.h>
    6|       |#include <stdint.h> // for uint64_t
    7|       |#include <stdlib.h> // for calloc, free, size_t
    8|       |#include <string.h> // for strcmp
    9|       |
   10|       |#include "types.h" // for string_s, symbol
   11|       |#include "defs.h"
   12|       |
   13|   101M|#define auto __auto_type
   14|       |
   15|       |/* FNV-1a */
   16|  12.9M|uint64_t str_hash(const char *str) {
   17|  12.9M|  const auto *p = str;
   18|  12.9M|  uint64_t hash = 0xcbf29ce484222325;
   19|       |
   20|  [0;35m77.3M[0m|  while (*p++ != 0) {
   21|  64.3M|    hash ^= *p;
   22|  64.3M|    hash *= 0x100000001b3;
   23|  64.3M|  }
   24|       |
   25|  12.9M|  return hash;
   26|  12.9M|}
   27|       |
   28|       |// string_s* to symbol* hash table.
   29|       |// Size must be power of two.
   30|       |// Bottom bits may be tombstone.
   31|       |// Open coded.
   32|       |
   33|       |// TODO weak GC syms, and evict entries when they are collected.  Somehow.
   34|       |
   35|       |// Non-empty default table so we don't have to null check.
   36|       |static table empty_table = {0, 0};
   37|       |table *sym_table = &empty_table;
   38|       |
   39|  12.7M|symbol *symbol_table_find(string_s *str) {
   40|  12.7M|  return symbol_table_find_cstr(str->str);
   41|  12.7M|}
   42|       |
   43|  12.7M|EXPORT symbol *symbol_table_find_cstr(const char *str) {
   44|  12.7M|  auto hash = str_hash(str);
   45|       |
   46|  12.7M|  auto mask = sym_table->sz - 1;
   47|  [0;35m75.1M[0m|  for (size_t i = 0; i < sym_table->sz; i++) {
   48|  75.1M|    auto cur = &sym_table->entries[(i + hash) & mask];
   49|  [0;35m75.1M[0m|    if (*cur == NULL) {
   50|  68.4k|      return NULL;
   51|  68.4k|    }
   52|  [0;35m75.1M[0m|    if (*cur == TOMBSTONE) [0;41m{[0m
   53|      0|[0;41m      continue;[0m
   54|      0|[0;41m    }[0m
   55|  [0;35m75.1M[0m|    string_s *sym_name = (string_s*)((*cur)->name - PTR_TAG);
   56|  [0;35m75.1M[0m|    if (strcmp(sym_name->str, str) == 0) {
   57|  12.7M|      return *cur;
   58|  12.7M|    } // Mismatched comparison, continue.
   59|  75.1M|  }
   60|       |
   61|     56|  return NULL;
   62|  12.7M|}
   63|       |
   64|       |static void rehash();
   65|   160k|void symbol_table_insert(symbol *sym) {
   66|   [0;35m160k[0m|  if ((sym_table->cnt + 1) > (sym_table->sz / 2)) {
   67|    637|    rehash();
   68|    637|  }
   69|   160k|  sym_table->cnt++;
   70|       |
   71|   160k|  string_s *sym_name = (string_s*)(sym->name - PTR_TAG);
   72|   160k|  auto hash = str_hash(sym_name->str);
   73|   160k|  auto mask = sym_table->sz - 1;
   74|       |
   75|   [0;35m289k[0m|  for (size_t i = 0; i < sym_table->sz; i++) {
   76|   289k|    auto cur = &sym_table->entries[(i + hash) & mask];
   77|   [0;35m289k[0m|    if (*cur == NULL || *cur == TOMBSTONE ||
   78|   [0;35m289k[0m|        strcmp(((string_s*)((*cur)->name - PTR_TAG))->str, sym_name->str) == 0) {
   79|       |      // Insert here.
   80|   160k|      *cur = sym;
   81|   160k|      return;
   82|   160k|    } // Mismatched comparison, continue.
   83|   289k|  }
   84|       |
   85|       |  // Definitely should find a spot.
   86|      0|  assert[0;41m(false);[0m
   87|      0|[0;41m}[0m
   88|       |
   89|    637|static void rehash() {
   90|    637|  auto *old = sym_table;
   91|    637|  auto new_sz = old->sz * 2;
   92|    [0;35m637[0m|  if (new_sz == 0) {
   93|     56|    new_sz = 2;
   94|     56|  }
   95|       |  // TODO realloc+memset
   96|    637|  sym_table = (table *)calloc(sizeof(table) + sizeof(symbol *) * new_sz, 1);
   97|    637|  sym_table->sz = new_sz;
   98|    637|  sym_table->cnt = 0;
   99|       |
  100|       |  // Rehash items.
  101|   [0;35m184k[0m|  for (size_t i = 0; i < old->sz; i++) {
  102|   184k|    auto cur = &old->entries[i];
  103|   [0;35m184k[0m|    if (*cur != NULL && *cur != TOMBSTONE) {
  104|  92.1k|      symbol_table_insert(*cur);
  105|  92.1k|    }
  106|   184k|  }
  107|       |
  108|    [0;35m637[0m|  if (old != &empty_table) {
  109|    581|    free(old);
  110|    581|  }
  111|    637|}
  112|       |
  113|     55|void symbol_table_clear() {
  114|     [0;35m55[0m|  if (sym_table != &empty_table) {
  115|     55|    free(sym_table);
  116|     55|    sym_table = &empty_table;
  117|     55|  }
  118|     55|}

[0;36m/home/davejwatson/myprojects/boom/symbol_table.h:
[0m    1|       |#pragma once
    2|       |
    3|       |#include <stddef.h>
    4|       |typedef struct string_s string_s;
    5|       |typedef struct symbol symbol;
    6|       |
    7|       |symbol *symbol_table_find(string_s *str);
    8|       |void symbol_table_insert(symbol *sym);
    9|       |symbol *symbol_table_find_cstr(const char *str);
   10|       |void symbol_table_clear();
   11|       |
   12|       |// GC needs access.
   13|       |typedef struct table {
   14|       |  size_t cnt; // Number of objects currently in hash.
   15|       |  size_t sz;  // Size of backing buffer.
   16|       |
   17|       |  symbol *entries[];
   18|       |} table;
   19|       |
   20|  75.6M|#define TOMBSTONE ((symbol *)0x01)
   21|       |
   22|       |extern table *sym_table;

[0;36m/home/davejwatson/myprojects/boom/third-party/jit-protocol.h:
[0m    1|       |/* Copyright (C) 2009-2020 Free Software Foundation, Inc.
    2|       |
    3|       |   This file is part of GDB.
    4|       |
    5|       |   This program is free software; you can redistribute it and/or modify
    6|       |   it under the terms of the GNU General Public License as published by
    7|       |   the Free Software Foundation; either version 3 of the License, or
    8|       |   (at your option) any later version.
    9|       |
   10|       |   This program is distributed in the hope that it will be useful,
   11|       |   but WITHOUT ANY WARRANTY; without even the implied warranty of
   12|       |   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   13|       |   GNU General Public License for more details.
   14|       |
   15|       |   You should have received a copy of the GNU General Public License
   16|       |   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
   17|       |
   18|       |#ifdef JIT_H
   19|       |#error "We don't include jit.h directly since we'd like the jit-reader unit  \
   20|       |        tests to break if we make ABI incompatible changes to the structures \
   21|       |        re-declared here."
   22|       |#endif
   23|       |
   24|       |#ifndef JIT_PROTOCOL_H
   25|       |#define JIT_PROTOCOL_H
   26|       |
   27|       |#include <stdint.h>
   28|       |
   29|       |typedef enum
   30|       |{
   31|       |  JIT_NOACTION = 0,
   32|       |  JIT_REGISTER,
   33|       |  JIT_UNREGISTER
   34|       |} jit_actions_t;
   35|       |
   36|       |
   37|       |struct jit_code_entry
   38|       |{
   39|       |  struct jit_code_entry *next_entry;
   40|       |  struct jit_code_entry *prev_entry;
   41|       |  const void *symfile_addr;
   42|       |  uint64_t symfile_size;
   43|       |};
   44|       |
   45|       |struct gdb_code_entry {
   46|       |  uint64_t fn;
   47|       |  int len;
   48|       |  char funcname[256];
   49|       |};
   50|       |
   51|       |struct jit_descriptor
   52|       |{
   53|       |  uint32_t version;
   54|       |  uint32_t action_flag;
   55|       |  struct jit_code_entry *relevant_entry;
   56|       |  struct jit_code_entry *first_entry;
   57|       |};
   58|       |
   59|       |struct jit_descriptor __jit_debug_descriptor = { 1, 0, 0, 0 };
   60|       |
   61|       |void __attribute__((noinline)) __jit_debug_register_code()
   62|      0|[0;41m{[0m
   63|       |[0;41m[0m/* GDB sets a breakpoint at this function. */[0;41m[0m
   64|      0|[0;41m  __asm__ __volatile__("");[0m
   65|      0|[0;41m}[0m
   66|       |
   67|       |#endif /* JIT_PROTOCOL_H */

[0;36m/home/davejwatson/myprojects/boom/third-party/stb_ds.c:
[0m    1|       |#include "stb_ds.h"
    2|       |
    3|       |//////////////////////////////////////////////////////////////////////////////
    4|       |//
    5|       |//   IMPLEMENTATION
    6|       |//
    7|       |
    8|       |#include <assert.h>
    9|       |#include <string.h>
   10|       |
   11|       |#ifndef STBDS_ASSERT
   12|       |#define STBDS_ASSERT_WAS_UNDEFINED
   13|      0|#define STBDS_ASSERT(x)   [0;41m((void) 0)[0m
   14|       |#endif
   15|       |
   16|       |#ifdef STBDS_STATISTICS
   17|       |#define STBDS_STATS(x)   x
   18|       |size_t stbds_array_grow;
   19|       |size_t stbds_hash_grow;
   20|       |size_t stbds_hash_shrink;
   21|       |size_t stbds_hash_rebuild;
   22|       |size_t stbds_hash_probes;
   23|       |size_t stbds_hash_alloc;
   24|       |size_t stbds_rehash_probes;
   25|       |size_t stbds_rehash_items;
   26|       |#else
   27|       |#define STBDS_STATS(x)
   28|       |#endif
   29|       |
   30|       |//
   31|       |// stbds_arr implementation
   32|       |//
   33|       |
   34|       |//int *prev_allocs[65536];
   35|       |//int num_prev;
   36|       |
   37|       |void *stbds_arrgrowf(void *a, size_t elemsize, size_t addlen, size_t min_cap)
   38|  1.00M|{
   39|  1.00M|  stbds_array_header temp={0}; // force debugging
   40|  1.00M|  void *b;
   41|  1.00M|  size_t min_len = stbds_arrlen(a) + addlen;
   42|  1.00M|  (void) sizeof(temp);
   43|       |
   44|       |  // compute the minimum capacity needed
   45|  1.00M|  if (min_len > min_cap)
   46|  1.00M|    min_cap = min_len;
   47|       |
   48|  [0;35m1.00M[0m|  if (min_cap <= stbds_arrcap(a))
   49|      0|    [0;41mreturn a[0m;
   50|       |
   51|       |  // increase needed capacity to guarantee O(1) amortized
   52|  [0;35m1.00M[0m|  if (min_cap < 2 * stbds_arrcap(a))
   53|   [0;35m653k[0m|    min_cap = 2 * stbds_arrcap(a);
   54|   [0;35m356k[0m|  else if (min_cap < 4)
   55|   356k|    min_cap = 4;
   56|       |
   57|       |  //if (num_prev < 65536) if (a) prev_allocs[num_prev++] = (int *) ((char *) a+1);
   58|       |  //if (num_prev == 2201)
   59|       |  //  num_prev = num_prev;
   60|  1.00M|  b = STBDS_REALLOC(NULL, (a) ? stbds_header(a) : 0, elemsize * min_cap + sizeof(stbds_array_header));
   61|       |  //if (num_prev < 65536) prev_allocs[num_prev++] = (int *) (char *) b;
   62|  1.00M|  b = (char *) b + sizeof(stbds_array_header);
   63|  [0;35m1.00M[0m|  if (a == NULL) {
   64|   356k|    stbds_header(b)->length = 0;
   65|   356k|    stbds_header(b)->hash_table = 0;
   66|   356k|    stbds_header(b)->temp = 0;
   67|   653k|  } else {
   68|   653k|    STBDS_STATS(++stbds_array_grow);
   69|   653k|  }
   70|  1.00M|  stbds_header(b)->capacity = min_cap;
   71|       |
   72|  1.00M|  return b;
   73|  1.00M|}
   74|       |
   75|       |void stbds_arrfreef(void *a)
   76|      0|[0;41m{[0m
   77|      0|[0;41m  [0m[0;41mSTBDS_FREE[0m[0;41m(NULL, stbds_header(a));[0m
   78|      0|[0;41m}[0m
   79|       |
   80|       |//
   81|       |// stbds_hm hash table implementation
   82|       |//
   83|       |
   84|       |#ifdef STBDS_INTERNAL_SMALL_BUCKET
   85|       |#define STBDS_BUCKET_LENGTH      4
   86|       |#else
   87|      0|#define STBDS_BUCKET_LENGTH      [0;41m8[0m
   88|       |#endif
   89|       |
   90|      [0;35m0[0m|#define STBDS_BUCKET_SHIFT      [0;41m([0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m == 8[0m[0;41m ? [0m[0;41m3[0m[0;41m : [0m[0;41m2[0m[0;41m)[0m
   91|      [0;35m0[0m|#define STBDS_BUCKET_MASK       [0;41m([0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m-1)[0m
   92|       |#define STBDS_CACHE_LINE_SIZE   64
   93|       |
   94|      0|#define STBDS_ALIGN_FWD(n,a)   [0;41m(((n) + (a) - 1) & ~((a)-1))[0m
   95|       |
   96|       |typedef struct
   97|       |{
   98|       |   size_t    hash [STBDS_BUCKET_LENGTH];
   99|       |   ptrdiff_t index[STBDS_BUCKET_LENGTH];
  100|       |} stbds_hash_bucket; // in 32-bit, this is one 64-byte cache line; in 64-bit, each array is one 64-byte cache line
  101|       |
  102|       |typedef struct
  103|       |{
  104|       |  char * temp_key; // this MUST be the first field of the hash table
  105|       |  size_t slot_count;
  106|       |  size_t used_count;
  107|       |  size_t used_count_threshold;
  108|       |  size_t used_count_shrink_threshold;
  109|       |  size_t tombstone_count;
  110|       |  size_t tombstone_count_threshold;
  111|       |  size_t seed;
  112|       |  size_t slot_count_log2;
  113|       |  stbds_string_arena string;
  114|       |  stbds_hash_bucket *storage; // not a separate allocation, just 64-byte aligned storage after this struct
  115|       |} stbds_hash_index;
  116|       |
  117|      0|#define STBDS_INDEX_EMPTY    [0;41m-1[0m
  118|      0|#define STBDS_INDEX_DELETED  [0;41m-2[0m
  119|      0|#define STBDS_INDEX_IN_USE(x)  [0;41m((x) >= 0)[0m
  120|       |
  121|      0|#define STBDS_HASH_EMPTY      [0;41m0[0m
  122|      0|#define STBDS_HASH_DELETED    [0;41m1[0m
  123|       |
  124|       |static size_t stbds_hash_seed=0x31415926;
  125|       |
  126|       |void stbds_rand_seed(size_t seed)
  127|      0|[0;41m{[0m
  128|      0|[0;41m  stbds_hash_seed = seed;[0m
  129|      0|[0;41m}[0m
  130|       |
  131|       |#define stbds_load_32_or_64(var, temp, v32, v64_hi, v64_lo)                                          \
  132|      0|  [0;41mtemp = v64_lo ^ v32, temp <<= 16, temp <<= 16, temp >>= 16, temp >>= 16, /* discard if 32-bit */   \[0m
  133|      0|[0;41m  var = v64_hi, var <<= 16, var <<= 16,                                    /* discard if 32-bit */   \[0m
  134|      0|[0;41m  var ^= temp ^ v32[0m
  135|       |
  136|      0|#define STBDS_SIZE_T_BITS           [0;41m((sizeof (size_t)) * 8)[0m
  137|       |
  138|       |static size_t stbds_probe_position(size_t hash, size_t slot_count, size_t slot_log2)
  139|      0|[0;41m{[0m
  140|      0|[0;41m  size_t pos;[0m
  141|      0|[0;41m  [0m[0;41mSTBDS_NOTUSED[0m[0;41m(slot_log2);[0m
  142|      0|[0;41m  pos = hash & (slot_count-1);[0m
  143|       |[0;41m[0m  #ifdef STBDS_INTERNAL_BUCKET_START
  144|       |  pos &= ~STBDS_BUCKET_MASK;
  145|       |  #endif[0;41m[0m
  146|      0|[0;41m  return pos;[0m
  147|      0|[0;41m}[0m
  148|       |
  149|       |static size_t stbds_log2(size_t slot_count)
  150|      0|[0;41m{[0m
  151|      0|[0;41m  size_t n=0;[0m
  152|      [0;35m0[0m|[0;41m  while ([0m[0;41mslot_count > 1[0m[0;41m) [0m[0;41m{[0m
  153|      0|[0;41m    slot_count >>= 1;[0m
  154|      0|[0;41m    ++n;[0m
  155|      0|[0;41m  }[0m[0;41m[0m
  156|      0|[0;41m  return n;[0m
  157|      0|[0;41m}[0m
  158|       |
  159|       |static stbds_hash_index *stbds_make_hash_index(size_t slot_count, stbds_hash_index *ot)
  160|      0|[0;41m{[0m
  161|      0|[0;41m  stbds_hash_index *t;[0m
  162|      0|[0;41m  t = (stbds_hash_index *) [0m[0;41mSTBDS_REALLOC[0m[0;41m(NULL,0,(slot_count >> STBDS_BUCKET_SHIFT) * sizeof(stbds_hash_bucket) + sizeof(stbds_hash_index) + STBDS_CACHE_LINE_SIZE-1);[0m
  163|      0|[0;41m  t->storage = (stbds_hash_bucket *) [0m[0;41mSTBDS_ALIGN_FWD[0m[0;41m((size_t) (t+1), STBDS_CACHE_LINE_SIZE);[0m
  164|      0|[0;41m  t->slot_count = slot_count;[0m
  165|      0|[0;41m  t->slot_count_log2 = stbds_log2(slot_count);[0m
  166|      0|[0;41m  t->tombstone_count = 0;[0m
  167|      0|[0;41m  t->used_count = 0;[0m
  168|       |[0;41m[0m[0;41m[0m
  169|       |[0;41m[0m  #if 0 // A1
  170|       |  t->used_count_threshold        = slot_count*12/16; // if 12/16th of table is occupied, grow
  171|       |  t->tombstone_count_threshold   = slot_count* 2/16; // if tombstones are 2/16th of table, rebuild
  172|       |  t->used_count_shrink_threshold = slot_count* 4/16; // if table is only 4/16th full, shrink
  173|       |  #elif 1 // A2
  174|       |  //t->used_count_threshold        = slot_count*12/16; // if 12/16th of table is occupied, grow
  175|       |  //t->tombstone_count_threshold   = slot_count* 3/16; // if tombstones are 3/16th of table, rebuild
  176|       |  //t->used_count_shrink_threshold = slot_count* 4/16; // if table is only 4/16th full, shrink
  177|       |
  178|       |  // compute without overflowing[0;41m[0m
  179|      0|[0;41m  t->used_count_threshold        = slot_count - (slot_count>>2);[0m
  180|      0|[0;41m  t->tombstone_count_threshold   = (slot_count>>3) + (slot_count>>4);[0m
  181|      0|[0;41m  t->used_count_shrink_threshold = slot_count >> 2;[0m
  182|       |[0;41m[0m[0;41m[0m
  183|       |[0;41m[0m  #elif 0 // B1
  184|       |  t->used_count_threshold        = slot_count*13/16; // if 13/16th of table is occupied, grow
  185|       |  t->tombstone_count_threshold   = slot_count* 2/16; // if tombstones are 2/16th of table, rebuild
  186|       |  t->used_count_shrink_threshold = slot_count* 5/16; // if table is only 5/16th full, shrink
  187|       |  #else // C1
  188|       |  t->used_count_threshold        = slot_count*14/16; // if 14/16th of table is occupied, grow
  189|       |  t->tombstone_count_threshold   = slot_count* 2/16; // if tombstones are 2/16th of table, rebuild
  190|       |  t->used_count_shrink_threshold = slot_count* 6/16; // if table is only 6/16th full, shrink
  191|       |  #endif
  192|       |  // Following statistics were measured on a Core i7-6700 @ 4.00Ghz, compiled with clang 7.0.1 -O2
  193|       |    // Note that the larger tables have high variance as they were run fewer times
  194|       |  //     A1            A2          B1           C1
  195|       |  //    0.10ms :     0.10ms :     0.10ms :     0.11ms :      2,000 inserts creating 2K table
  196|       |  //    0.96ms :     0.95ms :     0.97ms :     1.04ms :     20,000 inserts creating 20K table
  197|       |  //   14.48ms :    14.46ms :    10.63ms :    11.00ms :    200,000 inserts creating 200K table
  198|       |  //  195.74ms :   196.35ms :   203.69ms :   214.92ms :  2,000,000 inserts creating 2M table
  199|       |  // 2193.88ms :  2209.22ms :  2285.54ms :  2437.17ms : 20,000,000 inserts creating 20M table
  200|       |  //   65.27ms :    53.77ms :    65.33ms :    65.47ms : 500,000 inserts & deletes in 2K table
  201|       |  //   72.78ms :    62.45ms :    71.95ms :    72.85ms : 500,000 inserts & deletes in 20K table
  202|       |  //   89.47ms :    77.72ms :    96.49ms :    96.75ms : 500,000 inserts & deletes in 200K table
  203|       |  //   97.58ms :    98.14ms :    97.18ms :    97.53ms : 500,000 inserts & deletes in 2M table
  204|       |  //  118.61ms :   119.62ms :   120.16ms :   118.86ms : 500,000 inserts & deletes in 20M table
  205|       |  //  192.11ms :   194.39ms :   196.38ms :   195.73ms : 500,000 inserts & deletes in 200M table
  206|       |[0;41m[0m
  207|      [0;35m0[0m|[0;41m  if ([0m[0;41mslot_count <= [0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m)[0m
  208|      0|[0;41m    [0m[0;41mt->used_count_shrink_threshold = 0[0m[0;41m;[0m
  209|       |[0;41m[0m  // to avoid infinite loop, we need to guarantee that at least one slot is empty and will terminate probes[0;41m[0m
  210|      0|[0;41m  [0m[0;41mSTBDS_ASSERT[0m[0;41m(t->used_count_threshold + t->tombstone_count_threshold < t->slot_count);[0m
  211|      0|[0;41m  STBDS_STATS(++stbds_hash_alloc);[0m
  212|      [0;35m0[0m|[0;41m  if ([0m[0;41mot[0m[0;41m) [0m[0;41m{[0m
  213|      0|[0;41m    t->string = ot->string;[0m
  214|       |[0;41m[0m    // reuse old seed so we can reuse old hashes so below "copy out old data" doesn't do any hashing[0;41m[0m
  215|      0|[0;41m    t->seed = ot->seed;[0m
  216|      0|[0;41m  } else [0m[0;41m{[0m
  217|      0|[0;41m    size_t a,b,temp;[0m
  218|      0|[0;41m    memset(&t->string, 0, sizeof(t->string));[0m
  219|      0|[0;41m    t->seed = stbds_hash_seed;[0m
  220|       |[0;41m[0m    // LCG
  221|       |    // in 32-bit, a =          2147001325   b =  715136305
  222|       |    // in 64-bit, a = 2862933555777941757   b = 3037000493[0;41m[0m
  223|      0|[0;41m    [0m[0;41mstbds_load_32_or_64[0m[0;41m(a,temp, 2147001325, 0x27bb2ee6, 0x87b0b0fd);[0m
  224|      0|[0;41m    [0m[0;41mstbds_load_32_or_64[0m[0;41m(b,temp,  715136305,          0, 0xb504f32d);[0m
  225|      0|[0;41m    stbds_hash_seed = stbds_hash_seed  * a + b;[0m
  226|      0|[0;41m  }[0m
  227|       |[0;41m[0m[0;41m[0m
  228|      0|[0;41m  {[0m
  229|      0|[0;41m    size_t i,j;[0m
  230|      [0;35m0[0m|[0;41m    for (i=0; [0m[0;41mi < slot_count >> [0m[0;41mSTBDS_BUCKET_SHIFT[0m[0;41m; [0m[0;41m++i[0m[0;41m) [0m[0;41m{[0m
  231|      0|[0;41m      stbds_hash_bucket *b = &t->storage[i];[0m
  232|      [0;35m0[0m|[0;41m      for (j=0; [0m[0;41mj < [0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m; [0m[0;41m++j[0m[0;41m)[0m
  233|      [0;35m0[0m|[0;41m        [0m[0;41mb->hash[j] = [0m[0;41mSTBDS_HASH_EMPTY[0m[0;41m;[0m
  234|      [0;35m0[0m|[0;41m      for (j=0; [0m[0;41mj < [0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m; [0m[0;41m++j[0m[0;41m)[0m
  235|      [0;35m0[0m|[0;41m        [0m[0;41mb->index[j] = [0m[0;41mSTBDS_INDEX_EMPTY[0m[0;41m;[0m
  236|      0|[0;41m    }[0m
  237|      0|[0;41m  }[0m
  238|       |[0;41m[0m
  239|       |  // copy out the old data, if any[0;41m[0m
  240|      [0;35m0[0m|[0;41m  if ([0m[0;41mot[0m[0;41m) [0m[0;41m{[0m
  241|      0|[0;41m    size_t i,j;[0m
  242|      0|[0;41m    t->used_count = ot->used_count;[0m
  243|      [0;35m0[0m|[0;41m    for (i=0; [0m[0;41mi < ot->slot_count >> [0m[0;41mSTBDS_BUCKET_SHIFT[0m[0;41m; [0m[0;41m++i[0m[0;41m) [0m[0;41m{[0m
  244|      0|[0;41m      stbds_hash_bucket *ob = &ot->storage[i];[0m
  245|      [0;35m0[0m|[0;41m      for (j=0; [0m[0;41mj < [0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m; [0m[0;41m++j[0m[0;41m) [0m[0;41m{[0m
  246|      [0;35m0[0m|[0;41m        if ([0m[0;41mSTBDS_INDEX_IN_USE[0m[0;41m(ob->index[j])) [0m[0;41m{[0m
  247|      0|[0;41m          size_t hash = ob->hash[j];[0m
  248|      0|[0;41m          size_t pos = stbds_probe_position(hash, t->slot_count, t->slot_count_log2);[0m
  249|      0|[0;41m          size_t step = [0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m;[0m
  250|      0|[0;41m          STBDS_STATS(++stbds_rehash_items);[0m
  251|      0|[0;41m          for (;;) [0m[0;41m{[0m
  252|      0|[0;41m            size_t limit,z;[0m
  253|      0|[0;41m            stbds_hash_bucket *bucket;[0m
  254|      0|[0;41m            bucket = &t->storage[pos >> [0m[0;41mSTBDS_BUCKET_SHIFT[0m[0;41m];[0m
  255|      0|[0;41m            STBDS_STATS(++stbds_rehash_probes);[0m
  256|       |[0;41m[0m[0;41m[0m
  257|      [0;35m0[0m|[0;41m            for (z=pos & [0m[0;41mSTBDS_BUCKET_MASK[0m[0;41m; [0m[0;41mz < [0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m; [0m[0;41m++z[0m[0;41m) [0m[0;41m{[0m
  258|      [0;35m0[0m|[0;41m              if ([0m[0;41mbucket->hash[z] == 0[0m[0;41m) [0m[0;41m{[0m
  259|      0|[0;41m                bucket->hash[z] = hash;[0m
  260|      0|[0;41m                bucket->index[z] = ob->index[j];[0m
  261|      0|[0;41m                goto done;[0m
  262|      0|[0;41m              }[0m[0;41m[0m
  263|      0|[0;41m            }[0m
  264|       |[0;41m[0m
  265|      [0;35m0[0m|            [0;41mlimit = pos & [0m[0;41mSTBDS_BUCKET_MASK[0m[0;41m;[0m
  266|      [0;35m0[0m|[0;41m            for (z = 0; [0m[0;41mz < limit[0m[0;41m; [0m[0;41m++z[0m[0;41m) [0m[0;41m{[0m
  267|      [0;35m0[0m|[0;41m              if ([0m[0;41mbucket->hash[z] == 0[0m[0;41m) [0m[0;41m{[0m
  268|      0|[0;41m                bucket->hash[z] = hash;[0m
  269|      0|[0;41m                bucket->index[z] = ob->index[j];[0m
  270|      0|[0;41m                goto done;[0m
  271|      0|[0;41m              }[0m[0;41m[0m
  272|      0|[0;41m            }[0m
  273|       |[0;41m[0m
  274|      0|            [0;41mpos += step;                  // quadratic probing[0m
  275|      0|[0;41m            step += [0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m;[0m
  276|      0|[0;41m            pos &= (t->slot_count-1);[0m
  277|      0|[0;41m          }[0m
  278|      0|[0;41m        }[0m
  279|      0|[0;41m       [0m[0;41mdone:[0m
  280|      0|[0;41m        ;[0m
  281|      0|[0;41m      }[0m[0;41m[0m
  282|      0|[0;41m    }[0m
  283|      0|[0;41m  }[0m
  284|       |[0;41m[0m
  285|      0|  [0;41mreturn t[0m[0;41m;[0m
  286|      0|[0;41m}[0m
  287|       |
  288|      [0;35m0[0m|#define STBDS_ROTATE_LEFT(val, n)   [0;41m(((val) << (n)) | ((val) >> ([0m[0;41mSTBDS_SIZE_T_BITS[0m[0;41m - (n))))[0m
  289|      [0;35m0[0m|#define STBDS_ROTATE_RIGHT(val, n)  [0;41m(((val) >> (n)) | ((val) << ([0m[0;41mSTBDS_SIZE_T_BITS[0m[0;41m - (n))))[0m
  290|       |
  291|       |size_t stbds_hash_string(char *str, size_t seed)
  292|      0|[0;41m{[0m
  293|      0|[0;41m  size_t hash = seed;[0m
  294|      0|[0;41m  while ([0m[0;41m*str[0m[0;41m)[0m
  295|      [0;35m0[0m|[0;41m     [0m[0;41mhash = [0m[0;41mSTBDS_ROTATE_LEFT[0m[0;41m(hash, 9) + (unsigned char) *str++;[0m
  296|       |[0;41m[0m
  297|       |  // Thomas Wang 64-to-32 bit mix function, hopefully also works in 32 bits[0;41m[0m
  298|      0|[0;41m  hash ^= seed;[0m
  299|      0|[0;41m  hash = (~hash) + (hash << 18);[0m
  300|      0|[0;41m  hash ^= hash ^ [0m[0;41mSTBDS_ROTATE_RIGHT[0m[0;41m(hash,31);[0m
  301|      0|[0;41m  hash = hash * 21;[0m
  302|      0|[0;41m  hash ^= hash ^ [0m[0;41mSTBDS_ROTATE_RIGHT[0m[0;41m(hash,11);[0m
  303|      0|[0;41m  hash += (hash << 6);[0m
  304|      0|[0;41m  hash ^= [0m[0;41mSTBDS_ROTATE_RIGHT[0m[0;41m(hash,22);[0m
  305|      0|[0;41m  return hash+seed;[0m
  306|      0|[0;41m}[0m
  307|       |
  308|       |#ifdef STBDS_SIPHASH_2_4
  309|       |#define STBDS_SIPHASH_C_ROUNDS 2
  310|       |#define STBDS_SIPHASH_D_ROUNDS 4
  311|       |typedef int STBDS_SIPHASH_2_4_can_only_be_used_in_64_bit_builds[sizeof(size_t) == 8 ? 1 : -1];
  312|       |#endif
  313|       |
  314|       |#ifndef STBDS_SIPHASH_C_ROUNDS
  315|      0|#define STBDS_SIPHASH_C_ROUNDS [0;41m1[0m
  316|       |#endif
  317|       |#ifndef STBDS_SIPHASH_D_ROUNDS
  318|      0|#define STBDS_SIPHASH_D_ROUNDS [0;41m1[0m
  319|       |#endif
  320|       |
  321|       |#ifdef _MSC_VER
  322|       |#pragma warning(push)
  323|       |#pragma warning(disable:4127) // conditional expression is constant, for do..while(0) and sizeof()==
  324|       |#endif
  325|       |
  326|       |static size_t stbds_siphash_bytes(void *p, size_t len, size_t seed)
  327|      0|[0;41m{[0m
  328|      0|[0;41m  unsigned char *d = (unsigned char *) p;[0m
  329|      0|[0;41m  size_t i,j;[0m
  330|      0|[0;41m  size_t v0,v1,v2,v3, data;[0m
  331|       |[0;41m[0m
  332|       |  // hash that works on 32- or 64-bit registers without knowing which we have
  333|       |  // (computes different results on 32-bit and 64-bit platform)
  334|       |  // derived from siphash, but on 32-bit platforms very different as it uses 4 32-bit state not 4 64-bit[0;41m[0m
  335|      0|[0;41m  v0 = ((((size_t) 0x736f6d65 << 16) << 16) + 0x70736575) ^  seed;[0m
  336|      0|[0;41m  v1 = ((((size_t) 0x646f7261 << 16) << 16) + 0x6e646f6d) ^ ~seed;[0m
  337|      0|[0;41m  v2 = ((((size_t) 0x6c796765 << 16) << 16) + 0x6e657261) ^  seed;[0m
  338|      0|[0;41m  v3 = ((((size_t) 0x74656462 << 16) << 16) + 0x79746573) ^ ~seed;[0m
  339|       |[0;41m[0m[0;41m[0m
  340|       |[0;41m[0m  #ifdef STBDS_TEST_SIPHASH_2_4
  341|       |  // hardcoded with key material in the siphash test vectors
  342|       |  v0 ^= 0x0706050403020100ull ^  seed;
  343|       |  v1 ^= 0x0f0e0d0c0b0a0908ull ^ ~seed;
  344|       |  v2 ^= 0x0706050403020100ull ^  seed;
  345|       |  v3 ^= 0x0f0e0d0c0b0a0908ull ^ ~seed;
  346|       |  #endif
  347|       |[0;41m[0m
  348|      0|[0;41m  #define STBDS_SIPROUND() \[0m
  349|      [0;35m0[0m|[0;41m    [0m[0;41mdo [0m[0;41m{                   \[0m
  350|      [0;35m0[0m|[0;41m      v0 += v1; v1 = [0m[0;41mSTBDS_ROTATE_LEFT[0m[0;41m(v1, 13);  v1 ^= v0; v0 = [0m[0;41mSTBDS_ROTATE_LEFT[0m[0;41m(v0,STBDS_SIZE_T_BITS/2); \[0m
  351|      0|[0;41m      v2 += v3; v3 = [0m[0;41mSTBDS_ROTATE_LEFT[0m[0;41m(v3, 16);  v3 ^= v2;                                                 \[0m
  352|      [0;35m0[0m|[0;41m      v2 += v1; v1 = [0m[0;41mSTBDS_ROTATE_LEFT[0m[0;41m(v1, 17);  v1 ^= v2; v2 = [0m[0;41mSTBDS_ROTATE_LEFT[0m[0;41m(v2,STBDS_SIZE_T_BITS/2); \[0m
  353|      0|[0;41m      v0 += v3; v3 = [0m[0;41mSTBDS_ROTATE_LEFT[0m[0;41m(v3, 21);  v3 ^= v0;                                                 \[0m
  354|      0|[0;41m    } while ([0m[0;41m0[0m[0;41m)[0m
  355|       |[0;41m[0m[0;41m[0m
  356|      [0;35m0[0m|[0;41m  for (i=0; [0m[0;41mi+sizeof(size_t) <= len[0m[0;41m; [0m[0;41mi += sizeof(size_t), d += sizeof(size_t)[0m[0;41m) [0m[0;41m{[0m
  357|      0|[0;41m    data = d[0] | (d[1] << 8) | (d[2] << 16) | (d[3] << 24);[0m
  358|      0|[0;41m    data |= (size_t) (d[4] | (d[5] << 8) | (d[6] << 16) | (d[7] << 24)) << 16 << 16; // discarded if size_t == 4[0m
  359|       |[0;41m[0m[0;41m[0m
  360|      0|[0;41m    v3 ^= data;[0m
  361|      [0;35m0[0m|[0;41m    for (j=0; [0m[0;41mj < [0m[0;41mSTBDS_SIPHASH_C_ROUNDS[0m[0;41m; [0m[0;41m++j[0m[0;41m)[0m
  362|      0|[0;41m      [0m[0;41mSTBDS_SIPROUND[0m[0;41m();[0m
  363|      0|[0;41m    v0 ^= data;[0m
  364|      0|[0;41m  }[0m
  365|      0|[0;41m  data = len << ([0m[0;41mSTBDS_SIZE_T_BITS[0m[0;41m-8);[0m
  366|      0|[0;41m  switch (len - i) {[0m
  367|      0|[0;41m    [0m[0;41mcase 7: data |= ((size_t) d[6] << 24) << 24; // fall through[0m
  368|      0|[0;41m    [0m[0;41mcase 6: data |= ((size_t) d[5] << 20) << 20; // fall through[0m
  369|      0|[0;41m    [0m[0;41mcase 5: data |= ((size_t) d[4] << 16) << 16; // fall through[0m
  370|      0|[0;41m    [0m[0;41mcase 4: data |= (d[3] << 24); // fall through[0m
  371|      0|[0;41m    [0m[0;41mcase 3: data |= (d[2] << 16); // fall through[0m
  372|      0|[0;41m    [0m[0;41mcase 2: data |= (d[1] << 8); // fall through[0m
  373|      0|[0;41m    [0m[0;41mcase 1: data |= d[0]; // fall through[0m
  374|      0|[0;41m    [0m[0;41mcase 0: break[0m[0;41m;[0m
  375|      0|[0;41m  }[0m
  376|      0|[0;41m  [0m[0;41mv3 ^= data;[0m
  377|      [0;35m0[0m|[0;41m  for (j=0; [0m[0;41mj < [0m[0;41mSTBDS_SIPHASH_C_ROUNDS[0m[0;41m; [0m[0;41m++j[0m[0;41m)[0m
  378|      0|[0;41m    [0m[0;41mSTBDS_SIPROUND[0m[0;41m();[0m
  379|      0|[0;41m  v0 ^= data;[0m
  380|      0|[0;41m  v2 ^= 0xff;[0m
  381|      [0;35m0[0m|[0;41m  for (j=0; [0m[0;41mj < [0m[0;41mSTBDS_SIPHASH_D_ROUNDS[0m[0;41m; [0m[0;41m++j[0m[0;41m)[0m
  382|      0|[0;41m    [0m[0;41mSTBDS_SIPROUND[0m[0;41m();[0m
  383|       |[0;41m[0m[0;41m[0m
  384|       |[0;41m[0m#ifdef STBDS_SIPHASH_2_4
  385|       |  return v0^v1^v2^v3;
  386|       |#else[0;41m[0m
  387|      0|[0;41m  return v1^v2^v3; // slightly stronger since v0^v3 in above cancels out final round operation? I tweeted at the authors of SipHash about this but they didn't reply[0m
  388|      0|[0;41m#endif[0m
  389|      0|[0;41m}[0m
  390|       |
  391|       |size_t stbds_hash_bytes(void *p, size_t len, size_t seed)
  392|      0|[0;41m{[0m
  393|       |[0;41m[0m#ifdef STBDS_SIPHASH_2_4
  394|       |  return stbds_siphash_bytes(p,len,seed);
  395|       |#else[0;41m[0m
  396|      0|[0;41m  unsigned char *d = (unsigned char *) p;[0m
  397|       |[0;41m[0m[0;41m[0m
  398|      [0;35m0[0m|[0;41m  if ([0m[0;41mlen == 4[0m[0;41m) [0m[0;41m{[0m
  399|      0|[0;41m    unsigned int hash = d[0] | (d[1] << 8) | (d[2] << 16) | (d[3] << 24);[0m
  400|       |[0;41m[0m    #if 0
  401|       |    // HASH32-A  Bob Jenkin's hash function w/o large constants
  402|       |    hash ^= seed;
  403|       |    hash -= (hash<<6);
  404|       |    hash ^= (hash>>17);
  405|       |    hash -= (hash<<9);
  406|       |    hash ^= seed;
  407|       |    hash ^= (hash<<4);
  408|       |    hash -= (hash<<3);
  409|       |    hash ^= (hash<<10);
  410|       |    hash ^= (hash>>15);
  411|       |    #elif 1
  412|       |    // HASH32-BB  Bob Jenkin's presumably-accidental version of Thomas Wang hash with rotates turned into shifts.
  413|       |    // Note that converting these back to rotates makes it run a lot slower, presumably due to collisions, so I'm
  414|       |    // not really sure what's going on.[0;41m[0m
  415|      0|[0;41m    hash ^= seed;[0m
  416|      0|[0;41m    hash = (hash ^ 61) ^ (hash >> 16);[0m
  417|      0|[0;41m    hash = hash + (hash << 3);[0m
  418|      0|[0;41m    hash = hash ^ (hash >> 4);[0m
  419|      0|[0;41m    hash = hash * 0x27d4eb2d;[0m
  420|      0|[0;41m    hash ^= seed;[0m
  421|      0|[0;41m    hash = hash ^ (hash >> 15);[0m
  422|       |[0;41m[0m    #else  // HASH32-C   -  Murmur3
  423|       |    hash ^= seed;
  424|       |    hash *= 0xcc9e2d51;
  425|       |    hash = (hash << 17) | (hash >> 15);
  426|       |    hash *= 0x1b873593;
  427|       |    hash ^= seed;
  428|       |    hash = (hash << 19) | (hash >> 13);
  429|       |    hash = hash*5 + 0xe6546b64;
  430|       |    hash ^= hash >> 16;
  431|       |    hash *= 0x85ebca6b;
  432|       |    hash ^= seed;
  433|       |    hash ^= hash >> 13;
  434|       |    hash *= 0xc2b2ae35;
  435|       |    hash ^= hash >> 16;
  436|       |    #endif
  437|       |    // Following statistics were measured on a Core i7-6700 @ 4.00Ghz, compiled with clang 7.0.1 -O2
  438|       |    // Note that the larger tables have high variance as they were run fewer times
  439|       |    //  HASH32-A   //  HASH32-BB  //  HASH32-C
  440|       |    //    0.10ms   //    0.10ms   //    0.10ms :      2,000 inserts creating 2K table
  441|       |    //    0.96ms   //    0.95ms   //    0.99ms :     20,000 inserts creating 20K table
  442|       |    //   14.69ms   //   14.43ms   //   14.97ms :    200,000 inserts creating 200K table
  443|       |    //  199.99ms   //  195.36ms   //  202.05ms :  2,000,000 inserts creating 2M table
  444|       |    // 2234.84ms   // 2187.74ms   // 2240.38ms : 20,000,000 inserts creating 20M table
  445|       |    //   55.68ms   //   53.72ms   //   57.31ms : 500,000 inserts & deletes in 2K table
  446|       |    //   63.43ms   //   61.99ms   //   65.73ms : 500,000 inserts & deletes in 20K table
  447|       |    //   80.04ms   //   77.96ms   //   81.83ms : 500,000 inserts & deletes in 200K table
  448|       |    //  100.42ms   //   97.40ms   //  102.39ms : 500,000 inserts & deletes in 2M table
  449|       |    //  119.71ms   //  120.59ms   //  121.63ms : 500,000 inserts & deletes in 20M table
  450|       |    //  185.28ms   //  195.15ms   //  187.74ms : 500,000 inserts & deletes in 200M table
  451|       |    //   15.58ms   //   14.79ms   //   15.52ms : 200,000 inserts creating 200K table with varying key spacing
  452|       |[0;41m[0m
  453|      0|[0;41m    return (((size_t) hash << 16 << 16) | hash) ^ seed;[0m
  454|      [0;35m0[0m|[0;41m  } else [0m[0;41mif ([0m[0;41mlen == 8[0m[0;41m && [0m[0;41msizeof(size_t) == 8[0m[0;41m) [0m[0;41m{[0m
  455|      0|[0;41m    size_t hash = d[0] | (d[1] << 8) | (d[2] << 16) | (d[3] << 24);[0m
  456|      0|[0;41m    hash |= (size_t) (d[4] | (d[5] << 8) | (d[6] << 16) | (d[7] << 24)) << 16 << 16; // avoid warning if size_t == 4[0m
  457|      0|[0;41m    hash ^= seed;[0m
  458|      0|[0;41m    hash = (~hash) + (hash << 21);[0m
  459|      0|[0;41m    hash ^= [0m[0;41mSTBDS_ROTATE_RIGHT[0m[0;41m(hash,24);[0m
  460|      0|[0;41m    hash *= 265;[0m
  461|      0|[0;41m    hash ^= [0m[0;41mSTBDS_ROTATE_RIGHT[0m[0;41m(hash,14);[0m
  462|      0|[0;41m    hash ^= seed;[0m
  463|      0|[0;41m    hash *= 21;[0m
  464|      0|[0;41m    hash ^= [0m[0;41mSTBDS_ROTATE_RIGHT[0m[0;41m(hash,28);[0m
  465|      0|[0;41m    hash += (hash << 31);[0m
  466|      0|[0;41m    hash = (~hash) + (hash << 18);[0m
  467|      0|[0;41m    return hash;[0m
  468|      0|[0;41m  } else [0m[0;41m{[0m
  469|      0|[0;41m    return stbds_siphash_bytes(p,len,seed);[0m
  470|      0|[0;41m  }[0m[0;41m[0m
  471|      0|[0;41m#endif[0m
  472|      0|[0;41m}[0m
  473|       |#ifdef _MSC_VER
  474|       |#pragma warning(pop)
  475|       |#endif
  476|       |
  477|       |
  478|       |static int stbds_is_key_equal(void *a, size_t elemsize, void *key, size_t keysize, size_t keyoffset, int mode, size_t i)
  479|      0|[0;41m{[0m
  480|      [0;35m0[0m|[0;41m  if ([0m[0;41mmode >= [0m[0;41mSTBDS_HM_STRING[0m[0;41m)[0m
  481|      0|[0;41m    [0m[0;41mreturn 0==strcmp((char *) key, * (char **) ((char *) a + elemsize*i + keyoffset))[0m[0;41m;[0m
  482|      0|[0;41m  else[0m
  483|      0|[0;41m    [0m[0;41mreturn 0==memcmp(key, (char *) a + elemsize*i + keyoffset, keysize)[0m[0;41m;[0m
  484|      0|[0;41m}[0m
  485|       |
  486|      0|#define STBDS_HASH_TO_ARR(x,elemsize) [0;41m((char*) (x) - (elemsize))[0m
  487|      0|#define STBDS_ARR_TO_HASH(x,elemsize) [0;41m((char*) (x) + (elemsize))[0m
  488|       |
  489|      [0;35m0[0m|#define stbds_hash_table(a)  [0;41m((stbds_hash_index *) [0m[0;41mstbds_header[0m[0;41m(a)->hash_table)[0m
  490|       |
  491|       |void stbds_hmfree_func(void *a, size_t elemsize)
  492|      0|[0;41m{[0m
  493|      [0;35m0[0m|[0;41m  if ([0m[0;41ma == NULL[0m[0;41m) [0m[0;41mreturn[0m[0;41m;[0m
  494|      [0;35m0[0m|[0;41m  [0m[0;41mif ([0m[0;41mstbds_hash_table[0m[0;41m(a) != NULL[0m[0;41m) [0m[0;41m{[0m
  495|      [0;35m0[0m|[0;41m    if ([0m[0;41mstbds_hash_table[0m[0;41m(a)->string.mode == STBDS_SH_STRDUP[0m[0;41m) [0m[0;41m{[0m
  496|      0|[0;41m      size_t i;[0m
  497|       |[0;41m[0m      // skip 0th element, which is default[0;41m[0m
  498|      [0;35m0[0m|[0;41m      for (i=1; [0m[0;41mi < [0m[0;41mstbds_header[0m[0;41m(a)->length; [0m[0;41m++i[0m[0;41m)[0m
  499|      0|[0;41m        [0m[0;41mSTBDS_FREE[0m[0;41m(NULL, *(char**) ((char *) a + elemsize*i));[0m
  500|      0|[0;41m    }[0m
  501|      0|[0;41m    stbds_strreset(&[0m[0;41mstbds_hash_table[0m[0;41m(a)->string);[0m
  502|      0|[0;41m  }[0m
  503|      0|[0;41m  [0m[0;41mSTBDS_FREE[0m[0;41m(NULL, stbds_header(a)->hash_table);[0m
  504|      0|[0;41m  [0m[0;41mSTBDS_FREE[0m[0;41m(NULL, stbds_header(a));[0m
  505|      0|[0;41m}[0m
  506|       |
  507|       |static ptrdiff_t stbds_hm_find_slot(void *a, size_t elemsize, void *key, size_t keysize, size_t keyoffset, int mode)
  508|      0|[0;41m{[0m
  509|      0|[0;41m  void *raw_a = [0m[0;41mSTBDS_HASH_TO_ARR[0m[0;41m(a,elemsize);[0m
  510|      0|[0;41m  stbds_hash_index *table = [0m[0;41mstbds_hash_table[0m[0;41m(raw_a);[0m
  511|      [0;35m0[0m|[0;41m  size_t hash = [0m[0;41mmode >= [0m[0;41mSTBDS_HM_STRING[0m[0;41m ? [0m[0;41mstbds_hash_string((char*)key,table->seed)[0m[0;41m : [0m[0;41mstbds_hash_bytes(key, keysize,table->seed)[0m[0;41m;[0m
  512|      0|[0;41m  size_t step = [0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m;[0m
  513|      0|[0;41m  size_t limit,i;[0m
  514|      0|[0;41m  size_t pos;[0m
  515|      0|[0;41m  stbds_hash_bucket *bucket;[0m
  516|       |[0;41m[0m[0;41m[0m
  517|      [0;35m0[0m|[0;41m  if ([0m[0;41mhash < 2[0m[0;41m) [0m[0;41mhash += 2[0m[0;41m; // stored hash values are forbidden from being 0, so we can detect empty slots[0m
  518|       |[0;41m[0m[0;41m[0m
  519|      0|[0;41m  pos = stbds_probe_position(hash, table->slot_count, table->slot_count_log2);[0m
  520|       |[0;41m[0m[0;41m[0m
  521|      0|[0;41m  for (;;) [0m[0;41m{[0m
  522|      0|[0;41m    STBDS_STATS(++stbds_hash_probes);[0m
  523|      0|[0;41m    bucket = &table->storage[pos >> [0m[0;41mSTBDS_BUCKET_SHIFT[0m[0;41m];[0m
  524|       |[0;41m[0m
  525|       |    // start searching from pos to end of bucket, this should help performance on small hash tables that fit in cache[0;41m[0m
  526|      [0;35m0[0m|[0;41m    for (i=pos & [0m[0;41mSTBDS_BUCKET_MASK[0m[0;41m; [0m[0;41mi < [0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m; [0m[0;41m++i[0m[0;41m) [0m[0;41m{[0m
  527|      [0;35m0[0m|[0;41m      if ([0m[0;41mbucket->hash[i] == hash[0m[0;41m) [0m[0;41m{[0m
  528|      [0;35m0[0m|[0;41m        if ([0m[0;41mstbds_is_key_equal(a, elemsize, key, keysize, keyoffset, mode, bucket->index[i])[0m[0;41m) [0m[0;41m{[0m
  529|      0|[0;41m          return (pos & ~[0m[0;41mSTBDS_BUCKET_MASK[0m[0;41m)+i;[0m
  530|      0|[0;41m        }[0m
  531|      [0;35m0[0m|[0;41m      } else [0m[0;41mif ([0m[0;41mbucket->hash[i] == [0m[0;41mSTBDS_HASH_EMPTY[0m[0;41m) [0m[0;41m{[0m
  532|      0|[0;41m        return -1;[0m
  533|      0|[0;41m      }[0m[0;41m[0m
  534|      0|[0;41m    }[0m
  535|       |[0;41m[0m
  536|       |    // search from beginning of bucket to pos
  537|      [0;35m0[0m|    [0;41mlimit = pos & [0m[0;41mSTBDS_BUCKET_MASK[0m[0;41m;[0m
  538|      [0;35m0[0m|[0;41m    for (i = 0; [0m[0;41mi < limit[0m[0;41m; [0m[0;41m++i[0m[0;41m) [0m[0;41m{[0m
  539|      [0;35m0[0m|[0;41m      if ([0m[0;41mbucket->hash[i] == hash[0m[0;41m) [0m[0;41m{[0m
  540|      [0;35m0[0m|[0;41m        if ([0m[0;41mstbds_is_key_equal(a, elemsize, key, keysize, keyoffset, mode, bucket->index[i])[0m[0;41m) [0m[0;41m{[0m
  541|      0|[0;41m          return (pos & ~[0m[0;41mSTBDS_BUCKET_MASK[0m[0;41m)+i;[0m
  542|      0|[0;41m        }[0m
  543|      [0;35m0[0m|[0;41m      } else [0m[0;41mif ([0m[0;41mbucket->hash[i] == [0m[0;41mSTBDS_HASH_EMPTY[0m[0;41m) [0m[0;41m{[0m
  544|      0|[0;41m        return -1;[0m
  545|      0|[0;41m      }[0m[0;41m[0m
  546|      0|[0;41m    }[0m
  547|       |[0;41m[0m
  548|       |    // quadratic probing
  549|      0|    [0;41mpos += step;[0m
  550|      0|[0;41m    step += [0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m;[0m
  551|      0|[0;41m    pos &= (table->slot_count-1);[0m
  552|      0|[0;41m  }[0m
  553|       |[0;41m[0m  /* NOTREACHED */[0;41m[0m
  554|      0|[0;41m}[0m
  555|       |
  556|       |void * stbds_hmget_key_ts(void *a, size_t elemsize, void *key, size_t keysize, ptrdiff_t *temp, int mode)
  557|      0|[0;41m{[0m
  558|      0|[0;41m  size_t keyoffset = 0;[0m
  559|      [0;35m0[0m|[0;41m  if ([0m[0;41ma == NULL[0m[0;41m) [0m[0;41m{[0m
  560|       |[0;41m[0m    // make it non-empty so we can return a temp[0;41m[0m
  561|      0|[0;41m    a = stbds_arrgrowf(0, elemsize, 0, 1);[0m
  562|      0|[0;41m    [0m[0;41mstbds_header[0m[0;41m(a)->length += 1;[0m
  563|      0|[0;41m    memset(a, 0, elemsize);[0m
  564|      0|[0;41m    *temp = [0m[0;41mSTBDS_INDEX_EMPTY[0m[0;41m;[0m
  565|       |[0;41m[0m    // adjust a to point after the default element[0;41m[0m
  566|      0|[0;41m    return [0m[0;41mSTBDS_ARR_TO_HASH[0m[0;41m(a,elemsize);[0m
  567|      0|[0;41m  } else [0m[0;41m{[0m
  568|      0|[0;41m    stbds_hash_index *table;[0m
  569|      0|[0;41m    void *raw_a = [0m[0;41mSTBDS_HASH_TO_ARR[0m[0;41m(a,elemsize);[0m
  570|       |[0;41m[0m    // adjust a to point to the default element[0;41m[0m
  571|      0|[0;41m    table = (stbds_hash_index *) [0m[0;41mstbds_header[0m[0;41m(raw_a)->hash_table;[0m
  572|      [0;35m0[0m|[0;41m    if ([0m[0;41mtable == 0[0m[0;41m) [0m[0;41m{[0m
  573|      0|[0;41m      *temp = -1;[0m
  574|      0|[0;41m    }[0m[0;41m else [0m[0;41m{[0m
  575|      0|[0;41m      ptrdiff_t slot = stbds_hm_find_slot(a, elemsize, key, keysize, keyoffset, mode);[0m
  576|      [0;35m0[0m|[0;41m      if ([0m[0;41mslot < 0[0m[0;41m) [0m[0;41m{[0m
  577|      0|[0;41m        *temp = [0m[0;41mSTBDS_INDEX_EMPTY[0m[0;41m;[0m
  578|      0|[0;41m      } else [0m[0;41m{[0m
  579|      0|[0;41m        stbds_hash_bucket *b = &table->storage[slot >> [0m[0;41mSTBDS_BUCKET_SHIFT[0m[0;41m];[0m
  580|      0|[0;41m        *temp = b->index[slot & [0m[0;41mSTBDS_BUCKET_MASK[0m[0;41m];[0m
  581|      0|[0;41m      }[0m
  582|      0|[0;41m    }[0m
  583|      0|[0;41m    return a;[0m
  584|      0|[0;41m  }[0m
  585|      0|[0;41m}[0m
  586|       |
  587|       |void * stbds_hmget_key(void *a, size_t elemsize, void *key, size_t keysize, int mode)
  588|      0|[0;41m{[0m
  589|      0|[0;41m  ptrdiff_t temp;[0m
  590|      0|[0;41m  void *p = stbds_hmget_key_ts(a, elemsize, key, keysize, &temp, mode);[0m
  591|      0|[0;41m  [0m[0;41mstbds_temp[0m[0;41m(STBDS_HASH_TO_ARR(p,elemsize)) = temp;[0m
  592|      0|[0;41m  return p;[0m
  593|      0|[0;41m}[0m
  594|       |
  595|       |void * stbds_hmput_default(void *a, size_t elemsize)
  596|      0|[0;41m{[0m
  597|       |[0;41m[0m  // three cases:
  598|       |  //   a is NULL <- allocate
  599|       |  //   a has a hash table but no entries, because of shmode <- grow
  600|       |  //   a has entries <- do nothing[0;41m[0m
  601|      [0;35m0[0m|[0;41m  if ([0m[0;41ma == NULL[0m[0;41m || [0m[0;41mstbds_header[0m[0;41m(STBDS_HASH_TO_ARR(a,elemsize))->length == 0[0m[0;41m) [0m[0;41m{[0m
  602|      [0;35m0[0m|[0;41m    a = stbds_arrgrowf([0m[0;41ma[0m[0;41m ? [0m[0;41mSTBDS_HASH_TO_ARR[0m[0;41m(a,elemsize) : NULL, elemsize, 0, 1);[0m
  603|      0|[0;41m    [0m[0;41mstbds_header[0m[0;41m(a)->length += 1;[0m
  604|      0|[0;41m    memset(a, 0, elemsize);[0m
  605|      0|[0;41m    a=[0m[0;41mSTBDS_ARR_TO_HASH[0m[0;41m(a,elemsize);[0m
  606|      0|[0;41m  }[0m
  607|      0|[0;41m  return a;[0m
  608|      0|[0;41m}[0m
  609|       |
  610|       |static char *stbds_strdup(char *str);
  611|       |
  612|       |void *stbds_hmput_key(void *a, size_t elemsize, void *key, size_t keysize, int mode)
  613|      0|[0;41m{[0m
  614|      0|[0;41m  size_t keyoffset=0;[0m
  615|      0|[0;41m  void *raw_a;[0m
  616|      0|[0;41m  stbds_hash_index *table;[0m
  617|       |[0;41m[0m[0;41m[0m
  618|      [0;35m0[0m|[0;41m  if ([0m[0;41ma == NULL[0m[0;41m) [0m[0;41m{[0m
  619|      0|[0;41m    a = stbds_arrgrowf(0, elemsize, 0, 1);[0m
  620|      0|[0;41m    memset(a, 0, elemsize);[0m
  621|      0|[0;41m    [0m[0;41mstbds_header[0m[0;41m(a)->length += 1;[0m
  622|       |[0;41m[0m    // adjust a to point AFTER the default element[0;41m[0m
  623|      0|[0;41m    a = [0m[0;41mSTBDS_ARR_TO_HASH[0m[0;41m(a,elemsize);[0m
  624|      0|[0;41m  }[0m
  625|       |[0;41m[0m
  626|       |  // adjust a to point to the default element[0;41m[0m
  627|      0|[0;41m  raw_a = a;[0m
  628|      0|[0;41m  a = [0m[0;41mSTBDS_HASH_TO_ARR[0m[0;41m(a,elemsize);[0m
  629|       |[0;41m[0m[0;41m[0m
  630|      0|[0;41m  table = (stbds_hash_index *) [0m[0;41mstbds_header[0m[0;41m(a)->hash_table;[0m
  631|       |[0;41m[0m[0;41m[0m
  632|      [0;35m0[0m|[0;41m  if ([0m[0;41mtable == NULL[0m[0;41m || [0m[0;41mtable->used_count >= table->used_count_threshold[0m[0;41m) [0m[0;41m{[0m
  633|      0|[0;41m    stbds_hash_index *nt;[0m
  634|      0|[0;41m    size_t slot_count;[0m
  635|       |[0;41m[0m[0;41m[0m
  636|      [0;35m0[0m|[0;41m    slot_count = [0m[0;41m(table == NULL)[0m[0;41m ? [0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m : [0m[0;41mtable->slot_count*2[0m[0;41m;[0m
  637|      0|[0;41m    nt = stbds_make_hash_index(slot_count, table);[0m
  638|      0|[0;41m    if ([0m[0;41mtable[0m[0;41m)[0m
  639|      0|[0;41m      [0m[0;41mSTBDS_FREE[0m[0;41m(NULL, table);[0m
  640|      0|[0;41m    else[0m
  641|      [0;35m0[0m|[0;41m      [0m[0;41mnt->string.mode = [0m[0;41mmode >= [0m[0;41mSTBDS_HM_STRING[0m[0;41m ? [0m[0;41mSTBDS_SH_DEFAULT[0m[0;41m : [0m[0;41m0[0m[0;41m;[0m
  642|      0|[0;41m    [0m[0;41mstbds_header[0m[0;41m(a)->hash_table = table = nt;[0m
  643|      0|[0;41m    STBDS_STATS(++stbds_hash_grow);[0m
  644|      0|[0;41m  }[0m
  645|       |[0;41m[0m
  646|       |  // we iterate hash table explicitly because we want to track if we saw a tombstone[0;41m[0m
  647|      0|[0;41m  {[0m
  648|      [0;35m0[0m|[0;41m    size_t hash = [0m[0;41mmode >= [0m[0;41mSTBDS_HM_STRING[0m[0;41m ? [0m[0;41mstbds_hash_string((char*)key,table->seed)[0m[0;41m : [0m[0;41mstbds_hash_bytes(key, keysize,table->seed)[0m[0;41m;[0m
  649|      0|[0;41m    size_t step = [0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m;[0m
  650|      0|[0;41m    size_t pos;[0m
  651|      0|[0;41m    ptrdiff_t tombstone = -1;[0m
  652|      0|[0;41m    stbds_hash_bucket *bucket;[0m
  653|       |[0;41m[0m
  654|       |    // stored hash values are forbidden from being 0, so we can detect empty slots to early out quickly[0;41m[0m
  655|      [0;35m0[0m|[0;41m    if ([0m[0;41mhash < 2[0m[0;41m) [0m[0;41mhash += 2[0m[0;41m;[0m
  656|       |[0;41m[0m[0;41m[0m
  657|      0|[0;41m    pos = stbds_probe_position(hash, table->slot_count, table->slot_count_log2);[0m
  658|       |[0;41m[0m[0;41m[0m
  659|      0|[0;41m    for (;;) [0m[0;41m{[0m
  660|      0|[0;41m      size_t limit, i;[0m
  661|      0|[0;41m      STBDS_STATS(++stbds_hash_probes);[0m
  662|      0|[0;41m      bucket = &table->storage[pos >> [0m[0;41mSTBDS_BUCKET_SHIFT[0m[0;41m];[0m
  663|       |[0;41m[0m
  664|       |      // start searching from pos to end of bucket[0;41m[0m
  665|      [0;35m0[0m|[0;41m      for (i=pos & [0m[0;41mSTBDS_BUCKET_MASK[0m[0;41m; [0m[0;41mi < [0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m; [0m[0;41m++i[0m[0;41m) [0m[0;41m{[0m
  666|      [0;35m0[0m|[0;41m        if ([0m[0;41mbucket->hash[i] == hash[0m[0;41m) [0m[0;41m{[0m
  667|      [0;35m0[0m|[0;41m          if ([0m[0;41mstbds_is_key_equal(raw_a, elemsize, key, keysize, keyoffset, mode, bucket->index[i])[0m[0;41m) [0m[0;41m{[0m
  668|      0|[0;41m            [0m[0;41mstbds_temp[0m[0;41m(a) = bucket->index[i];[0m
  669|      [0;35m0[0m|[0;41m            if ([0m[0;41mmode >= [0m[0;41mSTBDS_HM_STRING[0m[0;41m)[0m
  670|      [0;35m0[0m|[0;41m              [0m[0;41mstbds_temp_key[0m[0;41m(a) = * (char **) ((char *) raw_a + elemsize*bucket->index[i] + keyoffset)[0m[0;41m;[0m
  671|      0|[0;41m            return [0m[0;41mSTBDS_ARR_TO_HASH[0m[0;41m(a,elemsize);[0m
  672|      0|[0;41m          }[0m
  673|      [0;35m0[0m|[0;41m        } else [0m[0;41mif ([0m[0;41mbucket->hash[i] == 0[0m[0;41m) [0m[0;41m{[0m
  674|      0|[0;41m          pos = (pos & ~[0m[0;41mSTBDS_BUCKET_MASK[0m[0;41m) + i;[0m
  675|      0|[0;41m          goto found_empty_slot;[0m
  676|      [0;35m0[0m|[0;41m        } else [0m[0;41mif ([0m[0;41mtombstone < 0[0m[0;41m) [0m[0;41m{[0m
  677|      [0;35m0[0m|[0;41m          if ([0m[0;41mbucket->index[i] == [0m[0;41mSTBDS_INDEX_DELETED[0m[0;41m)[0m
  678|      [0;35m0[0m|[0;41m            [0m[0;41mtombstone = (ptrdiff_t) ((pos & ~[0m[0;41mSTBDS_BUCKET_MASK[0m[0;41m) + i);[0m
  679|      0|[0;41m        }[0m
  680|      0|[0;41m      }[0m
  681|       |[0;41m[0m
  682|       |      // search from beginning of bucket to pos
  683|      [0;35m0[0m|      [0;41mlimit = pos & [0m[0;41mSTBDS_BUCKET_MASK[0m[0;41m;[0m
  684|      [0;35m0[0m|[0;41m      for (i = 0; [0m[0;41mi < limit[0m[0;41m; [0m[0;41m++i[0m[0;41m) [0m[0;41m{[0m
  685|      [0;35m0[0m|[0;41m        if ([0m[0;41mbucket->hash[i] == hash[0m[0;41m) [0m[0;41m{[0m
  686|      [0;35m0[0m|[0;41m          if ([0m[0;41mstbds_is_key_equal(raw_a, elemsize, key, keysize, keyoffset, mode, bucket->index[i])[0m[0;41m) [0m[0;41m{[0m
  687|      0|[0;41m            [0m[0;41mstbds_temp[0m[0;41m(a) = bucket->index[i];[0m
  688|      0|[0;41m            return [0m[0;41mSTBDS_ARR_TO_HASH[0m[0;41m(a,elemsize);[0m
  689|      0|[0;41m          }[0m
  690|      [0;35m0[0m|[0;41m        } else [0m[0;41mif ([0m[0;41mbucket->hash[i] == 0[0m[0;41m) [0m[0;41m{[0m
  691|      0|[0;41m          pos = (pos & ~[0m[0;41mSTBDS_BUCKET_MASK[0m[0;41m) + i;[0m
  692|      0|[0;41m          goto found_empty_slot;[0m
  693|      [0;35m0[0m|[0;41m        } else [0m[0;41mif ([0m[0;41mtombstone < 0[0m[0;41m) [0m[0;41m{[0m
  694|      [0;35m0[0m|[0;41m          if ([0m[0;41mbucket->index[i] == [0m[0;41mSTBDS_INDEX_DELETED[0m[0;41m)[0m
  695|      [0;35m0[0m|[0;41m            [0m[0;41mtombstone = (ptrdiff_t) ((pos & ~[0m[0;41mSTBDS_BUCKET_MASK[0m[0;41m) + i);[0m
  696|      0|[0;41m        }[0m
  697|      0|[0;41m      }[0m
  698|       |[0;41m[0m
  699|       |      // quadratic probing
  700|      0|      [0;41mpos += step;[0m
  701|      0|[0;41m      step += [0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m;[0m
  702|      0|[0;41m      pos &= (table->slot_count-1);[0m
  703|      0|[0;41m    }[0m
  704|      0|[0;41m   [0m[0;41mfound_empty_slot:[0m
  705|      [0;35m0[0m|[0;41m    if ([0m[0;41mtombstone >= 0[0m[0;41m) [0m[0;41m{[0m
  706|      0|[0;41m      pos = tombstone;[0m
  707|      0|[0;41m      --table->tombstone_count;[0m
  708|      0|[0;41m    }[0m[0;41m[0m
  709|      0|[0;41m    ++table->used_count;[0m
  710|       |[0;41m[0m[0;41m[0m
  711|      0|[0;41m    {[0m
  712|      0|[0;41m      ptrdiff_t i = (ptrdiff_t) [0m[0;41mstbds_arrlen[0m[0;41m(a);[0m
  713|       |[0;41m[0m      // we want to do stbds_arraddn(1), but we can't use the macros since we don't have something of the right type[0;41m[0m
  714|      [0;35m0[0m|[0;41m      if ([0m[0;41m(size_t) i+1 > [0m[0;41mstbds_arrcap[0m[0;41m(a))[0m
  715|      0|[0;41m        [0m[0;41m*(void **) &a = stbds_arrgrowf(a, elemsize, 1, 0)[0m[0;41m;[0m
  716|      0|[0;41m      raw_a = [0m[0;41mSTBDS_ARR_TO_HASH[0m[0;41m(a,elemsize);[0m
  717|       |[0;41m[0m[0;41m[0m
  718|      0|[0;41m      [0m[0;41mSTBDS_ASSERT[0m[0;41m((size_t) i+1 <= stbds_arrcap(a));[0m
  719|      0|[0;41m      [0m[0;41mstbds_header[0m[0;41m(a)->length = i+1;[0m
  720|      0|[0;41m      bucket = &table->storage[pos >> [0m[0;41mSTBDS_BUCKET_SHIFT[0m[0;41m];[0m
  721|      0|[0;41m      bucket->hash[pos & [0m[0;41mSTBDS_BUCKET_MASK[0m[0;41m] = hash;[0m
  722|      0|[0;41m      bucket->index[pos & [0m[0;41mSTBDS_BUCKET_MASK[0m[0;41m] = i-1;[0m
  723|      0|[0;41m      [0m[0;41mstbds_temp[0m[0;41m(a) = i-1;[0m
  724|       |[0;41m[0m[0;41m[0m
  725|      0|[0;41m      switch (table->string.mode) {[0m
  726|      [0;35m0[0m|[0;41m         [0m[0;41mcase STBDS_SH_STRDUP:  [0m[0;41mstbds_temp_key[0m[0;41m(a) = *(char **) ((char *) a + elemsize*i) = stbds_strdup((char*) key); break;[0m
  727|      [0;35m0[0m|[0;41m         [0m[0;41mcase STBDS_SH_ARENA:   [0m[0;41mstbds_temp_key[0m[0;41m(a) = *(char **) ((char *) a + elemsize*i) = stbds_stralloc(&table->string, (char*)key); break;[0m
  728|      [0;35m0[0m|[0;41m         [0m[0;41mcase STBDS_SH_DEFAULT: [0m[0;41mstbds_temp_key[0m[0;41m(a) = *(char **) ((char *) a + elemsize*i) = (char *) key; break;[0m
  729|      0|[0;41m         [0m[0;41mdefault:                memcpy((char *) a + elemsize*i, key, keysize); break[0m[0;41m;[0m
  730|      0|[0;41m      }[0m
  731|      0|[0;41m    }[0m
  732|      [0;35m0[0m|[0;41m    [0m[0;41mreturn [0m[0;41mSTBDS_ARR_TO_HASH[0m[0;41m(a,elemsize);[0m
  733|      0|[0;41m  }[0m
  734|      0|[0;41m}[0m
  735|       |
  736|       |void * stbds_shmode_func(size_t elemsize, int mode)
  737|      0|[0;41m{[0m
  738|      0|[0;41m  void *a = stbds_arrgrowf(0, elemsize, 0, 1);[0m
  739|      0|[0;41m  stbds_hash_index *h;[0m
  740|      0|[0;41m  memset(a, 0, elemsize);[0m
  741|      0|[0;41m  [0m[0;41mstbds_header[0m[0;41m(a)->length = 1;[0m
  742|      [0;35m0[0m|[0;41m  [0m[0;41mstbds_header[0m[0;41m(a)->hash_table = h = (stbds_hash_index *) stbds_make_hash_index([0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m, NULL);[0m
  743|      0|[0;41m  h->string.mode = (unsigned char) mode;[0m
  744|      0|[0;41m  return [0m[0;41mSTBDS_ARR_TO_HASH[0m[0;41m(a,elemsize);[0m
  745|      0|[0;41m}[0m
  746|       |
  747|       |void * stbds_hmdel_key(void *a, size_t elemsize, void *key, size_t keysize, size_t keyoffset, int mode)
  748|      0|[0;41m{[0m
  749|      [0;35m0[0m|[0;41m  if ([0m[0;41ma == NULL[0m[0;41m) [0m[0;41m{[0m
  750|      0|[0;41m    return 0;[0m
  751|      0|[0;41m  }[0m[0;41m else [0m[0;41m{[0m
  752|      0|[0;41m    stbds_hash_index *table;[0m
  753|      0|[0;41m    void *raw_a = [0m[0;41mSTBDS_HASH_TO_ARR[0m[0;41m(a,elemsize);[0m
  754|      0|[0;41m    table = (stbds_hash_index *) [0m[0;41mstbds_header[0m[0;41m(raw_a)->hash_table;[0m
  755|      0|[0;41m    [0m[0;41mstbds_temp[0m[0;41m(raw_a) = 0;[0m
  756|      [0;35m0[0m|[0;41m    if ([0m[0;41mtable == 0[0m[0;41m) [0m[0;41m{[0m
  757|      0|[0;41m      return a;[0m
  758|      0|[0;41m    }[0m[0;41m else [0m[0;41m{[0m
  759|      0|[0;41m      ptrdiff_t slot;[0m
  760|      0|[0;41m      slot = stbds_hm_find_slot(a, elemsize, key, keysize, keyoffset, mode);[0m
  761|      0|[0;41m      if ([0m[0;41mslot < 0[0m[0;41m)[0m
  762|      0|[0;41m        [0m[0;41mreturn a[0m[0;41m;[0m
  763|      0|[0;41m      else [0m[0;41m{[0m
  764|      0|[0;41m        stbds_hash_bucket *b = &table->storage[slot >> [0m[0;41mSTBDS_BUCKET_SHIFT[0m[0;41m];[0m
  765|      0|[0;41m        int i = slot & [0m[0;41mSTBDS_BUCKET_MASK[0m[0;41m;[0m
  766|      0|[0;41m        ptrdiff_t old_index = b->index[i];[0m
  767|      0|[0;41m        ptrdiff_t final_index = (ptrdiff_t) [0m[0;41mstbds_arrlen[0m[0;41m(raw_a)-1-1; // minus one for the raw_a vs a, and minus one for 'last'[0m
  768|      0|[0;41m        [0m[0;41mSTBDS_ASSERT[0m[0;41m(slot < (ptrdiff_t) table->slot_count);[0m
  769|      0|[0;41m        --table->used_count;[0m
  770|      0|[0;41m        ++table->tombstone_count;[0m
  771|      0|[0;41m        [0m[0;41mstbds_temp[0m[0;41m(raw_a) = 1;[0m
  772|      0|[0;41m        [0m[0;41mSTBDS_ASSERT[0m[0;41m(table->used_count >= 0);[0m
  773|       |[0;41m[0m        //STBDS_ASSERT(table->tombstone_count < table->slot_count/4);[0;41m[0m
  774|      0|[0;41m        b->hash[i] = [0m[0;41mSTBDS_HASH_DELETED[0m[0;41m;[0m
  775|      0|[0;41m        b->index[i] = [0m[0;41mSTBDS_INDEX_DELETED[0m[0;41m;[0m
  776|       |[0;41m[0m[0;41m[0m
  777|      [0;35m0[0m|[0;41m        if ([0m[0;41mmode == [0m[0;41mSTBDS_HM_STRING[0m[0;41m && [0m[0;41mtable->string.mode == STBDS_SH_STRDUP[0m[0;41m)[0m
  778|      0|[0;41m          [0m[0;41mSTBDS_FREE[0m[0;41m(NULL, *(char**) ((char *) a+elemsize*old_index));[0m
  779|       |[0;41m[0m
  780|       |        // if indices are the same, memcpy is a no-op, but back-pointer-fixup will fail, so skip[0;41m[0m
  781|      [0;35m0[0m|[0;41m        if ([0m[0;41mold_index != final_index[0m[0;41m) [0m[0;41m{[0m
  782|       |[0;41m[0m          // swap delete[0;41m[0m
  783|      0|[0;41m          memmove((char*) a + elemsize*old_index, (char*) a + elemsize*final_index, elemsize);[0m
  784|       |[0;41m[0m
  785|       |          // now find the slot for the last element[0;41m[0m
  786|      [0;35m0[0m|[0;41m          if ([0m[0;41mmode == [0m[0;41mSTBDS_HM_STRING[0m[0;41m)[0m
  787|      0|[0;41m            [0m[0;41mslot = stbds_hm_find_slot(a, elemsize, *(char**) ((char *) a+elemsize*old_index + keyoffset), keysize, keyoffset, mode)[0m[0;41m;[0m
  788|      0|[0;41m          else[0m
  789|      0|[0;41m            [0m[0;41mslot = stbds_hm_find_slot(a, elemsize,  (char* ) a+elemsize*old_index + keyoffset, keysize, keyoffset, mode)[0m[0;41m;[0m
  790|      0|[0;41m          [0m[0;41mSTBDS_ASSERT[0m[0;41m(slot >= 0);[0m
  791|      0|[0;41m          b = &table->storage[slot >> [0m[0;41mSTBDS_BUCKET_SHIFT[0m[0;41m];[0m
  792|      0|[0;41m          i = slot & [0m[0;41mSTBDS_BUCKET_MASK[0m[0;41m;[0m
  793|      0|[0;41m          [0m[0;41mSTBDS_ASSERT[0m[0;41m(b->index[i] == final_index);[0m
  794|      0|[0;41m          b->index[i] = old_index;[0m
  795|      0|[0;41m        }[0m
  796|      0|[0;41m        [0m[0;41mstbds_header[0m[0;41m(raw_a)->length -= 1;[0m
  797|       |[0;41m[0m[0;41m[0m
  798|      [0;35m0[0m|[0;41m        if ([0m[0;41mtable->used_count < table->used_count_shrink_threshold[0m[0;41m && [0m[0;41mtable->slot_count > [0m[0;41mSTBDS_BUCKET_LENGTH[0m[0;41m) [0m[0;41m{[0m
  799|      0|[0;41m          [0m[0;41mstbds_header[0m[0;41m(raw_a)->hash_table = stbds_make_hash_index(table->slot_count>>1, table);[0m
  800|      0|[0;41m          [0m[0;41mSTBDS_FREE[0m[0;41m(NULL, table);[0m
  801|      0|[0;41m          STBDS_STATS(++stbds_hash_shrink);[0m
  802|      [0;35m0[0m|[0;41m        } else [0m[0;41mif ([0m[0;41mtable->tombstone_count > table->tombstone_count_threshold[0m[0;41m) [0m[0;41m{[0m
  803|      0|[0;41m          [0m[0;41mstbds_header[0m[0;41m(raw_a)->hash_table = stbds_make_hash_index(table->slot_count   , table);[0m
  804|      0|[0;41m          [0m[0;41mSTBDS_FREE[0m[0;41m(NULL, table);[0m
  805|      0|[0;41m          STBDS_STATS(++stbds_hash_rebuild);[0m
  806|      0|[0;41m        }[0m
  807|       |[0;41m[0m[0;41m[0m
  808|      0|[0;41m        return a;[0m
  809|      0|[0;41m      }[0m
  810|      0|[0;41m    }[0m
  811|      0|[0;41m  }[0m
  812|       |[0;41m[0m  /* NOTREACHED */[0;41m[0m
  813|      0|[0;41m}[0m
  814|       |
  815|       |static char *stbds_strdup(char *str)
  816|      0|[0;41m{[0m
  817|       |[0;41m[0m  // to keep replaceable allocator simple, we don't want to use strdup.
  818|       |  // rolling our own also avoids problem of strdup vs _strdup[0;41m[0m
  819|      0|[0;41m  size_t len = strlen(str)+1;[0m
  820|      0|[0;41m  char *p = (char*) [0m[0;41mSTBDS_REALLOC[0m[0;41m(NULL, 0, len);[0m
  821|      0|[0;41m  memmove(p, str, len);[0m
  822|      0|[0;41m  return p;[0m
  823|      0|[0;41m}[0m
  824|       |
  825|       |#ifndef STBDS_STRING_ARENA_BLOCKSIZE_MIN
  826|      0|#define STBDS_STRING_ARENA_BLOCKSIZE_MIN  [0;41m512u[0m
  827|       |#endif
  828|       |#ifndef STBDS_STRING_ARENA_BLOCKSIZE_MAX
  829|      0|#define STBDS_STRING_ARENA_BLOCKSIZE_MAX  [0;41m(1u<<20)[0m
  830|       |#endif
  831|       |
  832|       |char *stbds_stralloc(stbds_string_arena *a, char *str)
  833|      0|[0;41m{[0m
  834|      0|[0;41m  char *p;[0m
  835|      0|[0;41m  size_t len = strlen(str)+1;[0m
  836|      [0;35m0[0m|[0;41m  if ([0m[0;41mlen > a->remaining[0m[0;41m) [0m[0;41m{[0m
  837|       |[0;41m[0m    // compute the next blocksize[0;41m[0m
  838|      0|[0;41m    size_t blocksize = a->block;[0m
  839|       |[0;41m[0m
  840|       |    // size is 512, 512, 1024, 1024, 2048, 2048, 4096, 4096, etc., so that
  841|       |    // there are log(SIZE) allocations to free when we destroy the table[0;41m[0m
  842|      0|[0;41m    blocksize = (size_t) ([0m[0;41mSTBDS_STRING_ARENA_BLOCKSIZE_MIN[0m[0;41m) << (blocksize>>1);[0m
  843|       |[0;41m[0m
  844|       |    // if size is under 1M, advance to next blocktype[0;41m[0m
  845|      [0;35m0[0m|[0;41m    if ([0m[0;41mblocksize < (size_t)([0m[0;41mSTBDS_STRING_ARENA_BLOCKSIZE_MAX[0m[0;41m))[0m
  846|      0|[0;41m      [0m[0;41m++a->block[0m[0;41m;[0m
  847|       |[0;41m[0m[0;41m[0m
  848|      [0;35m0[0m|[0;41m    if ([0m[0;41mlen > blocksize[0m[0;41m) [0m[0;41m{[0m
  849|       |[0;41m[0m      // if string is larger than blocksize, then just allocate the full size.
  850|       |      // note that we still advance string_block so block size will continue
  851|       |      // increasing, so e.g. if somebody only calls this with 1000-long strings,
  852|       |      // eventually the arena will start doubling and handling those as well[0;41m[0m
  853|      0|[0;41m      stbds_string_block *sb = (stbds_string_block *) [0m[0;41mSTBDS_REALLOC[0m[0;41m(NULL, 0, sizeof(*sb)-8 + len);[0m
  854|      0|[0;41m      memmove(sb->storage, str, len);[0m
  855|      [0;35m0[0m|[0;41m      if ([0m[0;41ma->storage[0m[0;41m) [0m[0;41m{[0m
  856|       |[0;41m[0m        // insert it after the first element, so that we don't waste the space there[0;41m[0m
  857|      0|[0;41m        sb->next = a->storage->next;[0m
  858|      0|[0;41m        a->storage->next = sb;[0m
  859|      0|[0;41m      } else [0m[0;41m{[0m
  860|      0|[0;41m        sb->next = 0;[0m
  861|      0|[0;41m        a->storage = sb;[0m
  862|      0|[0;41m        a->remaining = 0; // this is redundant, but good for clarity[0m
  863|      0|[0;41m      }[0m[0;41m[0m
  864|      0|[0;41m      return sb->storage;[0m
  865|      0|[0;41m    } else [0m[0;41m{[0m
  866|      0|[0;41m      stbds_string_block *sb = (stbds_string_block *) [0m[0;41mSTBDS_REALLOC[0m[0;41m(NULL, 0, sizeof(*sb)-8 + blocksize);[0m
  867|      0|[0;41m      sb->next = a->storage;[0m
  868|      0|[0;41m      a->storage = sb;[0m
  869|      0|[0;41m      a->remaining = blocksize;[0m
  870|      0|[0;41m    }[0m
  871|      0|[0;41m  }[0m
  872|       |[0;41m[0m
  873|      [0;35m0[0m|  [0;41mSTBDS_ASSERT[0m[0;41m(len <= a->remaining);[0m
  874|      0|[0;41m  p = a->storage->storage + a->remaining - len;[0m
  875|      0|[0;41m  a->remaining -= len;[0m
  876|      0|[0;41m  memmove(p, str, len);[0m
  877|      0|[0;41m  return p[0m[0;41m;[0m
  878|      0|[0;41m}[0m
  879|       |
  880|       |void stbds_strreset(stbds_string_arena *a)
  881|      0|[0;41m{[0m
  882|      0|[0;41m  stbds_string_block *x,*y;[0m
  883|      0|[0;41m  x = a->storage;[0m
  884|      [0;35m0[0m|[0;41m  while ([0m[0;41mx[0m[0;41m) [0m[0;41m{[0m
  885|      0|[0;41m    y = x->next;[0m
  886|      0|[0;41m    [0m[0;41mSTBDS_FREE[0m[0;41m(NULL, x);[0m
  887|      0|[0;41m    x = y;[0m
  888|      0|[0;41m  }[0m
  889|      0|[0;41m  memset(a, 0, sizeof(*a));[0m
  890|      0|[0;41m}[0m
  891|       |
  892|       |
  893|       |
  894|       |/*
  895|       |------------------------------------------------------------------------------
  896|       |This software is available under 2 licenses -- choose whichever you prefer.
  897|       |------------------------------------------------------------------------------
  898|       |ALTERNATIVE A - MIT License
  899|       |Copyright (c) 2019 Sean Barrett
  900|       |Permission is hereby granted, free of charge, to any person obtaining a copy of
  901|       |this software and associated documentation files (the "Software"), to deal in
  902|       |the Software without restriction, including without limitation the rights to
  903|       |use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
  904|       |of the Software, and to permit persons to whom the Software is furnished to do
  905|       |so, subject to the following conditions:
  906|       |The above copyright notice and this permission notice shall be included in all
  907|       |copies or substantial portions of the Software.
  908|       |THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  909|       |IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  910|       |FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  911|       |AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  912|       |LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  913|       |OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  914|       |SOFTWARE.
  915|       |------------------------------------------------------------------------------
  916|       |ALTERNATIVE B - Public Domain (www.unlicense.org)
  917|       |This is free and unencumbered software released into the public domain.
  918|       |Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
  919|       |software, either in source code form or as a compiled binary, for any purpose,
  920|       |commercial or non-commercial, and by any means.
  921|       |In jurisdictions that recognize copyright laws, the author or authors of this
  922|       |software dedicate any and all copyright interest in the software to the public
  923|       |domain. We make this dedication for the benefit of the public at large and to
  924|       |the detriment of our heirs and successors. We intend this dedication to be an
  925|       |overt act of relinquishment in perpetuity of all present and future rights to
  926|       |this software under copyright law.
  927|       |THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  928|       |IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  929|       |FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  930|       |AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  931|       |ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  932|       |WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  933|       |------------------------------------------------------------------------------
  934|       |*/
  935|       |
  936|       |

[0;36m/home/davejwatson/myprojects/boom/third-party/stb_ds.h:
[0m    1|       |#pragma once
    2|       |/* stb_ds.h - v0.67 - public domain data structures - Sean Barrett 2019
    3|       |
    4|       |   This is a single-header-file library that provides easy-to-use
    5|       |   dynamic arrays and hash tables for C (also works in C++).
    6|       |
    7|       |   For a gentle introduction:
    8|       |      http://nothings.org/stb_ds
    9|       |
   10|       |   To use this library, do this in *one* C or C++ file:
   11|       |      #define STB_DS_IMPLEMENTATION
   12|       |      #include "stb_ds.h"
   13|       |
   14|       |TABLE OF CONTENTS
   15|       |
   16|       |  Table of Contents
   17|       |  Compile-time options
   18|       |  License
   19|       |  Documentation
   20|       |  Notes
   21|       |  Notes - Dynamic arrays
   22|       |  Notes - Hash maps
   23|       |  Credits
   24|       |
   25|       |COMPILE-TIME OPTIONS
   26|       |
   27|       |  #define STBDS_NO_SHORT_NAMES
   28|       |
   29|       |     This flag needs to be set globally.
   30|       |
   31|       |     By default stb_ds exposes shorter function names that are not qualified
   32|       |     with the "stbds_" prefix. If these names conflict with the names in your
   33|       |     code, define this flag.
   34|       |
   35|       |  #define STBDS_SIPHASH_2_4
   36|       |
   37|       |     This flag only needs to be set in the file containing #define STB_DS_IMPLEMENTATION.
   38|       |
   39|       |     By default stb_ds.h hashes using a weaker variant of SipHash and a custom hash for
   40|       |     4- and 8-byte keys. On 64-bit platforms, you can define the above flag to force
   41|       |     stb_ds.h to use specification-compliant SipHash-2-4 for all keys. Doing so makes
   42|       |     hash table insertion about 20% slower on 4- and 8-byte keys, 5% slower on
   43|       |     64-byte keys, and 10% slower on 256-byte keys on my test computer.
   44|       |
   45|       |  #define STBDS_REALLOC(context,ptr,size) better_realloc
   46|       |  #define STBDS_FREE(context,ptr)         better_free
   47|       |
   48|       |     These defines only need to be set in the file containing #define STB_DS_IMPLEMENTATION.
   49|       |
   50|       |     By default stb_ds uses stdlib realloc() and free() for memory management. You can
   51|       |     substitute your own functions instead by defining these symbols. You must either
   52|       |     define both, or neither. Note that at the moment, 'context' will always be NULL.
   53|       |     @TODO add an array/hash initialization function that takes a memory context pointer.
   54|       |
   55|       |  #define STBDS_UNIT_TESTS
   56|       |
   57|       |     Defines a function stbds_unit_tests() that checks the functioning of the data structures.
   58|       |
   59|       |  Note that on older versions of gcc (e.g. 5.x.x) you may need to build with '-std=c++0x'
   60|       |     (or equivalentally '-std=c++11') when using anonymous structures as seen on the web
   61|       |     page or in STBDS_UNIT_TESTS.
   62|       |
   63|       |LICENSE
   64|       |
   65|       |  Placed in the public domain and also MIT licensed.
   66|       |  See end of file for detailed license information.
   67|       |
   68|       |DOCUMENTATION
   69|       |
   70|       |  Dynamic Arrays
   71|       |
   72|       |    Non-function interface:
   73|       |
   74|       |      Declare an empty dynamic array of type T
   75|       |        T* foo = NULL;
   76|       |
   77|       |      Access the i'th item of a dynamic array 'foo' of type T, T* foo:
   78|       |        foo[i]
   79|       |
   80|       |    Functions (actually macros)
   81|       |
   82|       |      arrfree:
   83|       |        void arrfree(T*);
   84|       |          Frees the array.
   85|       |
   86|       |      arrlen:
   87|       |        ptrdiff_t arrlen(T*);
   88|       |          Returns the number of elements in the array.
   89|       |
   90|       |      arrlenu:
   91|       |        size_t arrlenu(T*);
   92|       |          Returns the number of elements in the array as an unsigned type.
   93|       |
   94|       |      arrpop:
   95|       |        T arrpop(T* a)
   96|       |          Removes the final element of the array and returns it.
   97|       |
   98|       |      arrput:
   99|       |        T arrput(T* a, T b);
  100|       |          Appends the item b to the end of array a. Returns b.
  101|       |
  102|       |      arrins:
  103|       |        T arrins(T* a, int p, T b);
  104|       |          Inserts the item b into the middle of array a, into a[p],
  105|       |          moving the rest of the array over. Returns b.
  106|       |
  107|       |      arrinsn:
  108|       |        void arrinsn(T* a, int p, int n);
  109|       |          Inserts n uninitialized items into array a starting at a[p],
  110|       |          moving the rest of the array over.
  111|       |
  112|       |      arraddnptr:
  113|       |        T* arraddnptr(T* a, int n)
  114|       |          Appends n uninitialized items onto array at the end.
  115|       |          Returns a pointer to the first uninitialized item added.
  116|       |
  117|       |      arraddnindex:
  118|       |        size_t arraddnindex(T* a, int n)
  119|       |          Appends n uninitialized items onto array at the end.
  120|       |          Returns the index of the first uninitialized item added.
  121|       |
  122|       |      arrdel:
  123|       |        void arrdel(T* a, int p);
  124|       |          Deletes the element at a[p], moving the rest of the array over.
  125|       |
  126|       |      arrdeln:
  127|       |        void arrdeln(T* a, int p, int n);
  128|       |          Deletes n elements starting at a[p], moving the rest of the array over.
  129|       |
  130|       |      arrdelswap:
  131|       |        void arrdelswap(T* a, int p);
  132|       |          Deletes the element at a[p], replacing it with the element from
  133|       |          the end of the array. O(1) performance.
  134|       |
  135|       |      arrsetlen:
  136|       |        void arrsetlen(T* a, int n);
  137|       |          Changes the length of the array to n. Allocates uninitialized
  138|       |          slots at the end if necessary.
  139|       |
  140|       |      arrsetcap:
  141|       |        size_t arrsetcap(T* a, int n);
  142|       |          Sets the length of allocated storage to at least n. It will not
  143|       |          change the length of the array.
  144|       |
  145|       |      arrcap:
  146|       |        size_t arrcap(T* a);
  147|       |          Returns the number of total elements the array can contain without
  148|       |          needing to be reallocated.
  149|       |
  150|       |  Hash maps & String hash maps
  151|       |
  152|       |    Given T is a structure type: struct { TK key; TV value; }. Note that some
  153|       |    functions do not require TV value and can have other fields. For string
  154|       |    hash maps, TK must be 'char *'.
  155|       |
  156|       |    Special interface:
  157|       |
  158|       |      stbds_rand_seed:
  159|       |        void stbds_rand_seed(size_t seed);
  160|       |          For security against adversarially chosen data, you should seed the
  161|       |          library with a strong random number. Or at least seed it with time().
  162|       |
  163|       |      stbds_hash_string:
  164|       |        size_t stbds_hash_string(char *str, size_t seed);
  165|       |          Returns a hash value for a string.
  166|       |
  167|       |      stbds_hash_bytes:
  168|       |        size_t stbds_hash_bytes(void *p, size_t len, size_t seed);
  169|       |          These functions hash an arbitrary number of bytes. The function
  170|       |          uses a custom hash for 4- and 8-byte data, and a weakened version
  171|       |          of SipHash for everything else. On 64-bit platforms you can get
  172|       |          specification-compliant SipHash-2-4 on all data by defining
  173|       |          STBDS_SIPHASH_2_4, at a significant cost in speed.
  174|       |
  175|       |    Non-function interface:
  176|       |
  177|       |      Declare an empty hash map of type T
  178|       |        T* foo = NULL;
  179|       |
  180|       |      Access the i'th entry in a hash table T* foo:
  181|       |        foo[i]
  182|       |
  183|       |    Function interface (actually macros):
  184|       |
  185|       |      hmfree
  186|       |      shfree
  187|       |        void hmfree(T*);
  188|       |        void shfree(T*);
  189|       |          Frees the hashmap and sets the pointer to NULL.
  190|       |
  191|       |      hmlen
  192|       |      shlen
  193|       |        ptrdiff_t hmlen(T*)
  194|       |        ptrdiff_t shlen(T*)
  195|       |          Returns the number of elements in the hashmap.
  196|       |
  197|       |      hmlenu
  198|       |      shlenu
  199|       |        size_t hmlenu(T*)
  200|       |        size_t shlenu(T*)
  201|       |          Returns the number of elements in the hashmap.
  202|       |
  203|       |      hmgeti
  204|       |      shgeti
  205|       |      hmgeti_ts
  206|       |        ptrdiff_t hmgeti(T*, TK key)
  207|       |        ptrdiff_t shgeti(T*, char* key)
  208|       |        ptrdiff_t hmgeti_ts(T*, TK key, ptrdiff_t tempvar)
  209|       |          Returns the index in the hashmap which has the key 'key', or -1
  210|       |          if the key is not present.
  211|       |
  212|       |      hmget
  213|       |      hmget_ts
  214|       |      shget
  215|       |        TV hmget(T*, TK key)
  216|       |        TV shget(T*, char* key)
  217|       |        TV hmget_ts(T*, TK key, ptrdiff_t tempvar)
  218|       |          Returns the value corresponding to 'key' in the hashmap.
  219|       |          The structure must have a 'value' field
  220|       |
  221|       |      hmgets
  222|       |      shgets
  223|       |        T hmgets(T*, TK key)
  224|       |        T shgets(T*, char* key)
  225|       |          Returns the structure corresponding to 'key' in the hashmap.
  226|       |
  227|       |      hmgetp
  228|       |      shgetp
  229|       |      hmgetp_ts
  230|       |      hmgetp_null
  231|       |      shgetp_null
  232|       |        T* hmgetp(T*, TK key)
  233|       |        T* shgetp(T*, char* key)
  234|       |        T* hmgetp_ts(T*, TK key, ptrdiff_t tempvar)
  235|       |        T* hmgetp_null(T*, TK key)
  236|       |        T* shgetp_null(T*, char *key)
  237|       |          Returns a pointer to the structure corresponding to 'key' in
  238|       |          the hashmap. Functions ending in "_null" return NULL if the key
  239|       |          is not present in the hashmap; the others return a pointer to a
  240|       |          structure holding the default value (but not the searched-for key).
  241|       |
  242|       |      hmdefault
  243|       |      shdefault
  244|       |        TV hmdefault(T*, TV value)
  245|       |        TV shdefault(T*, TV value)
  246|       |          Sets the default value for the hashmap, the value which will be
  247|       |          returned by hmget/shget if the key is not present.
  248|       |
  249|       |      hmdefaults
  250|       |      shdefaults
  251|       |        TV hmdefaults(T*, T item)
  252|       |        TV shdefaults(T*, T item)
  253|       |          Sets the default struct for the hashmap, the contents which will be
  254|       |          returned by hmgets/shgets if the key is not present.
  255|       |
  256|       |      hmput
  257|       |      shput
  258|       |        TV hmput(T*, TK key, TV value)
  259|       |        TV shput(T*, char* key, TV value)
  260|       |          Inserts a <key,value> pair into the hashmap. If the key is already
  261|       |          present in the hashmap, updates its value.
  262|       |
  263|       |      hmputs
  264|       |      shputs
  265|       |        T hmputs(T*, T item)
  266|       |        T shputs(T*, T item)
  267|       |          Inserts a struct with T.key into the hashmap. If the struct is already
  268|       |          present in the hashmap, updates it.
  269|       |
  270|       |      hmdel
  271|       |      shdel
  272|       |        int hmdel(T*, TK key)
  273|       |        int shdel(T*, char* key)
  274|       |          If 'key' is in the hashmap, deletes its entry and returns 1.
  275|       |          Otherwise returns 0.
  276|       |
  277|       |    Function interface (actually macros) for strings only:
  278|       |
  279|       |      sh_new_strdup
  280|       |        void sh_new_strdup(T*);
  281|       |          Overwrites the existing pointer with a newly allocated
  282|       |          string hashmap which will automatically allocate and free
  283|       |          each string key using realloc/free
  284|       |
  285|       |      sh_new_arena
  286|       |        void sh_new_arena(T*);
  287|       |          Overwrites the existing pointer with a newly allocated
  288|       |          string hashmap which will automatically allocate each string
  289|       |          key to a string arena. Every string key ever used by this
  290|       |          hash table remains in the arena until the arena is freed.
  291|       |          Additionally, any key which is deleted and reinserted will
  292|       |          be allocated multiple times in the string arena.
  293|       |
  294|       |NOTES
  295|       |
  296|       |  * These data structures are realloc'd when they grow, and the macro
  297|       |    "functions" write to the provided pointer. This means: (a) the pointer
  298|       |    must be an lvalue, and (b) the pointer to the data structure is not
  299|       |    stable, and you must maintain it the same as you would a realloc'd
  300|       |    pointer. For example, if you pass a pointer to a dynamic array to a
  301|       |    function which updates it, the function must return back the new
  302|       |    pointer to the caller. This is the price of trying to do this in C.
  303|       |
  304|       |  * The following are the only functions that are thread-safe on a single data
  305|       |    structure, i.e. can be run in multiple threads simultaneously on the same
  306|       |    data structure
  307|       |        hmlen        shlen
  308|       |        hmlenu       shlenu
  309|       |        hmget_ts     shget_ts
  310|       |        hmgeti_ts    shgeti_ts
  311|       |        hmgets_ts    shgets_ts
  312|       |
  313|       |  * You iterate over the contents of a dynamic array and a hashmap in exactly
  314|       |    the same way, using arrlen/hmlen/shlen:
  315|       |
  316|       |      for (i=0; i < arrlen(foo); ++i)
  317|       |         ... foo[i] ...
  318|       |
  319|       |  * All operations except arrins/arrdel are O(1) amortized, but individual
  320|       |    operations can be slow, so these data structures may not be suitable
  321|       |    for real time use. Dynamic arrays double in capacity as needed, so
  322|       |    elements are copied an average of once. Hash tables double/halve
  323|       |    their size as needed, with appropriate hysteresis to maintain O(1)
  324|       |    performance.
  325|       |
  326|       |NOTES - DYNAMIC ARRAY
  327|       |
  328|       |  * If you know how long a dynamic array is going to be in advance, you can avoid
  329|       |    extra memory allocations by using arrsetlen to allocate it to that length in
  330|       |    advance and use foo[n] while filling it out, or arrsetcap to allocate the memory
  331|       |    for that length and use arrput/arrpush as normal.
  332|       |
  333|       |  * Unlike some other versions of the dynamic array, this version should
  334|       |    be safe to use with strict-aliasing optimizations.
  335|       |
  336|       |NOTES - HASH MAP
  337|       |
  338|       |  * For compilers other than GCC and clang (e.g. Visual Studio), for hmput/hmget/hmdel
  339|       |    and variants, the key must be an lvalue (so the macro can take the address of it).
  340|       |    Extensions are used that eliminate this requirement if you're using C99 and later
  341|       |    in GCC or clang, or if you're using C++ in GCC. But note that this can make your
  342|       |    code less portable.
  343|       |
  344|       |  * To test for presence of a key in a hashmap, just do 'hmgeti(foo,key) >= 0'.
  345|       |
  346|       |  * The iteration order of your data in the hashmap is determined solely by the
  347|       |    order of insertions and deletions. In particular, if you never delete, new
  348|       |    keys are always added at the end of the array. This will be consistent
  349|       |    across all platforms and versions of the library. However, you should not
  350|       |    attempt to serialize the internal hash table, as the hash is not consistent
  351|       |    between different platforms, and may change with future versions of the library.
  352|       |
  353|       |  * Use sh_new_arena() for string hashmaps that you never delete from. Initialize
  354|       |    with NULL if you're managing the memory for your strings, or your strings are
  355|       |    never freed (at least until the hashmap is freed). Otherwise, use sh_new_strdup().
  356|       |    @TODO: make an arena variant that garbage collects the strings with a trivial
  357|       |    copy collector into a new arena whenever the table shrinks / rebuilds. Since
  358|       |    current arena recommendation is to only use arena if it never deletes, then
  359|       |    this can just replace current arena implementation.
  360|       |
  361|       |  * If adversarial input is a serious concern and you're on a 64-bit platform,
  362|       |    enable STBDS_SIPHASH_2_4 (see the 'Compile-time options' section), and pass
  363|       |    a strong random number to stbds_rand_seed.
  364|       |
  365|       |  * The default value for the hash table is stored in foo[-1], so if you
  366|       |    use code like 'hmget(T,k)->value = 5' you can accidentally overwrite
  367|       |    the value stored by hmdefault if 'k' is not present.
  368|       |
  369|       |CREDITS
  370|       |
  371|       |  Sean Barrett -- library, idea for dynamic array API/implementation
  372|       |  Per Vognsen  -- idea for hash table API/implementation
  373|       |  Rafael Sachetto -- arrpop()
  374|       |  github:HeroicKatora -- arraddn() reworking
  375|       |
  376|       |  Bugfixes:
  377|       |    Andy Durdin
  378|       |    Shane Liesegang
  379|       |    Vinh Truong
  380|       |    Andreas Molzer
  381|       |    github:hashitaku
  382|       |    github:srdjanstipic
  383|       |    Macoy Madson
  384|       |    Andreas Vennstrom
  385|       |    Tobias Mansfield-Williams
  386|       |*/
  387|       |
  388|       |#ifdef STBDS_UNIT_TESTS
  389|       |#define _CRT_SECURE_NO_WARNINGS
  390|       |#endif
  391|       |
  392|       |#ifndef INCLUDE_STB_DS_H
  393|       |#define INCLUDE_STB_DS_H
  394|       |
  395|       |#include <stddef.h>
  396|       |#include <string.h>
  397|       |
  398|       |#ifndef STBDS_NO_SHORT_NAMES
  399|  12.6G|#define arrlen      stbds_arrlen
  400|       |#define arrlenu     stbds_arrlenu
  401|  18.4M|#define arrput      stbds_arrput
  402|       |#define arrpush     stbds_arrput
  403|  11.7M|#define arrpop      stbds_arrpop
  404|   416k|#define arrfree     stbds_arrfree
  405|       |#define arraddn     stbds_arraddn // deprecated, use one of the following instead:
  406|       |#define arraddnptr  stbds_arraddnptr
  407|       |#define arraddnindex stbds_arraddnindex
  408|      0|#define arrsetlen   [0;41mstbds_arrsetlen[0m
  409|       |#define arrlast     stbds_arrlast
  410|       |#define arrins      stbds_arrins
  411|       |#define arrinsn     stbds_arrinsn
  412|       |#define arrdel      stbds_arrdel
  413|       |#define arrdeln     stbds_arrdeln
  414|       |#define arrdelswap  stbds_arrdelswap
  415|       |#define arrcap      stbds_arrcap
  416|       |#define arrsetcap   stbds_arrsetcap
  417|       |
  418|       |#define hmput       stbds_hmput
  419|       |#define hmputs      stbds_hmputs
  420|       |#define hmget       stbds_hmget
  421|       |#define hmget_ts    stbds_hmget_ts
  422|       |#define hmgets      stbds_hmgets
  423|       |#define hmgetp      stbds_hmgetp
  424|       |#define hmgetp_ts   stbds_hmgetp_ts
  425|       |#define hmgetp_null stbds_hmgetp_null
  426|       |#define hmgeti      stbds_hmgeti
  427|       |#define hmgeti_ts   stbds_hmgeti_ts
  428|       |#define hmdel       stbds_hmdel
  429|       |#define hmlen       stbds_hmlen
  430|       |#define hmlenu      stbds_hmlenu
  431|       |#define hmfree      stbds_hmfree
  432|       |#define hmdefault   stbds_hmdefault
  433|       |#define hmdefaults  stbds_hmdefaults
  434|       |
  435|       |#define shput       stbds_shput
  436|       |#define shputi      stbds_shputi
  437|       |#define shputs      stbds_shputs
  438|       |#define shget       stbds_shget
  439|       |#define shgeti      stbds_shgeti
  440|       |#define shgets      stbds_shgets
  441|       |#define shgetp      stbds_shgetp
  442|       |#define shgetp_null stbds_shgetp_null
  443|       |#define shdel       stbds_shdel
  444|       |#define shlen       stbds_shlen
  445|       |#define shlenu      stbds_shlenu
  446|       |#define shfree      stbds_shfree
  447|       |#define shdefault   stbds_shdefault
  448|       |#define shdefaults  stbds_shdefaults
  449|       |#define sh_new_arena  stbds_sh_new_arena
  450|       |#define sh_new_strdup stbds_sh_new_strdup
  451|       |
  452|       |#define stralloc    stbds_stralloc
  453|       |#define strreset    stbds_strreset
  454|       |#endif
  455|       |
  456|       |#if defined(STBDS_REALLOC) && !defined(STBDS_FREE) || !defined(STBDS_REALLOC) && defined(STBDS_FREE)
  457|       |#error "You must define both STBDS_REALLOC and STBDS_FREE, or neither."
  458|       |#endif
  459|       |#if !defined(STBDS_REALLOC) && !defined(STBDS_FREE)
  460|       |#include <stdlib.h>
  461|  [0;35m2.01M[0m|#define STBDS_REALLOC(c,p,s) realloc(p,[0;41ms[0m)
  462|   356k|#define STBDS_FREE(c,p)      free(p)
  463|       |#endif
  464|       |
  465|       |#ifdef _MSC_VER
  466|       |#define STBDS_NOTUSED(v)  (void)(v)
  467|       |#else
  468|      0|#define STBDS_NOTUSED(v)  [0;41m(void)sizeof(v)[0m
  469|       |#endif
  470|       |
  471|       |#ifdef __cplusplus
  472|       |extern "C" {
  473|       |#endif
  474|       |
  475|       |// for security against attackers, seed the library with a random number, at least time() but stronger is better
  476|       |extern void stbds_rand_seed(size_t seed);
  477|       |
  478|       |// these are the hash functions used internally if you want to test them or use them for other purposes
  479|       |extern size_t stbds_hash_bytes(void *p, size_t len, size_t seed);
  480|       |extern size_t stbds_hash_string(char *str, size_t seed);
  481|       |
  482|       |// this is a simple string arena allocator, initialize with e.g. 'stbds_string_arena my_arena={0}'.
  483|       |typedef struct stbds_string_arena stbds_string_arena;
  484|       |extern char * stbds_stralloc(stbds_string_arena *a, char *str);
  485|       |extern void   stbds_strreset(stbds_string_arena *a);
  486|       |
  487|       |// have to #define STBDS_UNIT_TESTS to call this
  488|       |extern void stbds_unit_tests(void);
  489|       |
  490|       |///////////////
  491|       |//
  492|       |// Everything below here is implementation details
  493|       |//
  494|       |
  495|       |extern void * stbds_arrgrowf(void *a, size_t elemsize, size_t addlen, size_t min_cap);
  496|       |extern void   stbds_arrfreef(void *a);
  497|       |extern void   stbds_hmfree_func(void *p, size_t elemsize);
  498|       |extern void * stbds_hmget_key(void *a, size_t elemsize, void *key, size_t keysize, int mode);
  499|       |extern void * stbds_hmget_key_ts(void *a, size_t elemsize, void *key, size_t keysize, ptrdiff_t *temp, int mode);
  500|       |extern void * stbds_hmput_default(void *a, size_t elemsize);
  501|       |extern void * stbds_hmput_key(void *a, size_t elemsize, void *key, size_t keysize, int mode);
  502|       |extern void * stbds_hmdel_key(void *a, size_t elemsize, void *key, size_t keysize, size_t keyoffset, int mode);
  503|       |extern void * stbds_shmode_func(size_t elemsize, int mode);
  504|       |
  505|       |#ifdef __cplusplus
  506|       |}
  507|       |#endif
  508|       |
  509|       |#if defined(__GNUC__) || defined(__clang__)
  510|       |#define STBDS_HAS_TYPEOF
  511|       |#ifdef __cplusplus
  512|       |//#define STBDS_HAS_LITERAL_ARRAY  // this is currently broken for clang
  513|       |#endif
  514|       |#endif
  515|       |
  516|       |#if !defined(__cplusplus)
  517|       |#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
  518|       |#define STBDS_HAS_LITERAL_ARRAY
  519|       |#endif
  520|       |#endif
  521|       |
  522|       |// this macro takes the address of the argument, but on gcc/clang can accept rvalues
  523|       |#if defined(STBDS_HAS_LITERAL_ARRAY) && defined(STBDS_HAS_TYPEOF)
  524|       |  #if __clang__
  525|       |  #define STBDS_ADDRESSOF(typevar, value)     ((__typeof__(typevar)[1]){value}) // literal array decays to pointer to value
  526|       |  #else
  527|       |  #define STBDS_ADDRESSOF(typevar, value)     ((typeof(typevar)[1]){value}) // literal array decays to pointer to value
  528|       |  #endif
  529|       |#else
  530|       |#define STBDS_ADDRESSOF(typevar, value)     &(value)
  531|       |#endif
  532|       |
  533|       |#define STBDS_OFFSETOF(var,field)           ((char *) &(var)->field - (char *) (var))
  534|       |
  535|  12.6G|#define stbds_header(t)  ((stbds_array_header *) (t) - 1)
  536|      0|#define stbds_temp(t)    [0;41mstbds_header[0m[0;41m(t)->temp[0m
  537|      [0;35m0[0m|#define stbds_temp_key(t) [0;41m(*(char **) [0m[0;41mstbds_header[0m[0;41m(t)->hash_table)[0m
  538|       |
  539|      [0;35m0[0m|#define stbds_arrsetcap(a,n)   [0;41m([0m[0;41mstbds_arrgrow[0m[0;41m(a,0,n))[0m
  540|      [0;35m0[0m|#define stbds_arrsetlen(a,n)   [0;41m(([0m[0;41mstbds_arrcap[0m[0;41m(a) < (size_t) (n)[0m[0;41m ? [0m[0;41mstbds_arrsetcap[0m[0;41m((a),(size_t)(n)),0[0m[0;41m : [0m[0;41m0[0m[0;41m), [0m[0;41m(a)[0m[0;41m ? [0m[0;41mstbds_header[0m[0;41m(a)->length = (size_t) (n)[0m[0;41m : [0m[0;41m0[0m[0;41m)[0m
  541|  [0;35m2.67M[0m|#define stbds_arrcap(a)        ((a) ? stbds_header(a)->capacity : 0)
  542|  [0;35m12.6G[0m|#define stbds_arrlen(a)        ((a) ? (ptrdiff_t) stbds_header(a)->length : 0)
  543|       |#define stbds_arrlenu(a)       ((a) ?             stbds_header(a)->length : 0)
  544|  [0;35m18.4M[0m|#define stbds_arrput(a,v)      (stbds_arrmaybegrow(a,1), (a)[stbds_header(a)->length++] = (v))
  545|       |#define stbds_arrpush          stbds_arrput  // synonym
  546|  [0;35m11.7M[0m|#define stbds_arrpop(a)        (stbds_header(a)->length--, (a)[stbds_header(a)->length])
  547|       |#define stbds_arraddn(a,n)     ((void)(stbds_arraddnindex(a, n)))    // deprecated, use one of the following instead:
  548|       |#define stbds_arraddnptr(a,n)  (stbds_arrmaybegrow(a,n), (n) ? (stbds_header(a)->length += (n), &(a)[stbds_header(a)->length-(n)]) : (a))
  549|       |#define stbds_arraddnindex(a,n)(stbds_arrmaybegrow(a,n), (n) ? (stbds_header(a)->length += (n), stbds_header(a)->length-(n)) : stbds_arrlen(a))
  550|       |#define stbds_arraddnoff       stbds_arraddnindex
  551|       |#define stbds_arrlast(a)       ((a)[stbds_header(a)->length-1])
  552|   [0;35m416k[0m|#define stbds_arrfree(a)       ((void) ((a) ? STBDS_FREE(NULL,stbds_header(a)) : (void)0), (a)=NULL)
  553|       |#define stbds_arrdel(a,i)      stbds_arrdeln(a,i,1)
  554|       |#define stbds_arrdeln(a,i,n)   (memmove(&(a)[i], &(a)[(i)+(n)], sizeof *(a) * (stbds_header(a)->length-(n)-(i))), stbds_header(a)->length -= (n))
  555|       |#define stbds_arrdelswap(a,i)  ((a)[i] = stbds_arrlast(a), stbds_header(a)->length -= 1)
  556|       |#define stbds_arrinsn(a,i,n)   (stbds_arraddn((a),(n)), memmove(&(a)[(i)+(n)], &(a)[i], sizeof *(a) * (stbds_header(a)->length-(n)-(i))))
  557|       |#define stbds_arrins(a,i,v)    (stbds_arrinsn((a),(i),1), (a)[i]=(v))
  558|       |
  559|  [0;35m18.4M[0m|#define stbds_arrmaybegrow(a,n)  ((!(a) || stbds_header(a)->length + (n) > stbds_header(a)->capacity) \
  560|  [0;35m18.4M[0m|                                  ? (stbds_arrgrow(a,n,0),0) : 0)
  561|       |
  562|  [0;35m1.00M[0m|#define stbds_arrgrow(a,b,c)   ((a) = stbds_arrgrowf_wrapper((a), sizeof *(a), (b), (c)))
  563|       |
  564|       |#define stbds_hmput(t, k, v) \
  565|       |    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), (void*) STBDS_ADDRESSOF((t)->key, (k)), sizeof (t)->key, 0),   \
  566|       |     (t)[stbds_temp((t)-1)].key = (k),    \
  567|       |     (t)[stbds_temp((t)-1)].value = (v))
  568|       |
  569|       |#define stbds_hmputs(t, s) \
  570|       |    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), &(s).key, sizeof (s).key, STBDS_HM_BINARY), \
  571|       |     (t)[stbds_temp((t)-1)] = (s))
  572|       |
  573|       |#define stbds_hmgeti(t,k) \
  574|       |    ((t) = stbds_hmget_key_wrapper((t), sizeof *(t), (void*) STBDS_ADDRESSOF((t)->key, (k)), sizeof (t)->key, STBDS_HM_BINARY), \
  575|       |      stbds_temp((t)-1))
  576|       |
  577|       |#define stbds_hmgeti_ts(t,k,temp) \
  578|       |    ((t) = stbds_hmget_key_ts_wrapper((t), sizeof *(t), (void*) STBDS_ADDRESSOF((t)->key, (k)), sizeof (t)->key, &(temp), STBDS_HM_BINARY), \
  579|       |      (temp))
  580|       |
  581|       |#define stbds_hmgetp(t, k) \
  582|       |    ((void) stbds_hmgeti(t,k), &(t)[stbds_temp((t)-1)])
  583|       |
  584|       |#define stbds_hmgetp_ts(t, k, temp) \
  585|       |    ((void) stbds_hmgeti_ts(t,k,temp), &(t)[temp])
  586|       |
  587|       |#define stbds_hmdel(t,k) \
  588|       |    (((t) = stbds_hmdel_key_wrapper((t),sizeof *(t), (void*) STBDS_ADDRESSOF((t)->key, (k)), sizeof (t)->key, STBDS_OFFSETOF((t),key), STBDS_HM_BINARY)),(t)?stbds_temp((t)-1):0)
  589|       |
  590|       |#define stbds_hmdefault(t, v) \
  591|       |    ((t) = stbds_hmput_default_wrapper((t), sizeof *(t)), (t)[-1].value = (v))
  592|       |
  593|       |#define stbds_hmdefaults(t, s) \
  594|       |    ((t) = stbds_hmput_default_wrapper((t), sizeof *(t)), (t)[-1] = (s))
  595|       |
  596|       |#define stbds_hmfree(p)        \
  597|       |    ((void) ((p) != NULL ? stbds_hmfree_func((p)-1,sizeof*(p)),0 : 0),(p)=NULL)
  598|       |
  599|       |#define stbds_hmgets(t, k)    (*stbds_hmgetp(t,k))
  600|       |#define stbds_hmget(t, k)     (stbds_hmgetp(t,k)->value)
  601|       |#define stbds_hmget_ts(t, k, temp)  (stbds_hmgetp_ts(t,k,temp)->value)
  602|       |#define stbds_hmlen(t)        ((t) ? (ptrdiff_t) stbds_header((t)-1)->length-1 : 0)
  603|       |#define stbds_hmlenu(t)       ((t) ?             stbds_header((t)-1)->length-1 : 0)
  604|       |#define stbds_hmgetp_null(t,k)  (stbds_hmgeti(t,k) == -1 ? NULL : &(t)[stbds_temp((t)-1)])
  605|       |
  606|       |#define stbds_shput(t, k, v) \
  607|       |    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), (void*) (k), sizeof (t)->key, STBDS_HM_STRING),   \
  608|       |     (t)[stbds_temp((t)-1)].value = (v))
  609|       |
  610|       |#define stbds_shputi(t, k, v) \
  611|       |    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), (void*) (k), sizeof (t)->key, STBDS_HM_STRING),   \
  612|       |     (t)[stbds_temp((t)-1)].value = (v), stbds_temp((t)-1))
  613|       |
  614|       |#define stbds_shputs(t, s) \
  615|       |    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), (void*) (s).key, sizeof (s).key, STBDS_HM_STRING), \
  616|       |     (t)[stbds_temp((t)-1)] = (s), \
  617|       |     (t)[stbds_temp((t)-1)].key = stbds_temp_key((t)-1)) // above line overwrites whole structure, so must rewrite key here if it was allocated internally
  618|       |
  619|       |#define stbds_pshput(t, p) \
  620|       |    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), (void*) (p)->key, sizeof (p)->key, STBDS_HM_PTR_TO_STRING), \
  621|       |     (t)[stbds_temp((t)-1)] = (p))
  622|       |
  623|       |#define stbds_shgeti(t,k) \
  624|       |     ((t) = stbds_hmget_key_wrapper((t), sizeof *(t), (void*) (k), sizeof (t)->key, STBDS_HM_STRING), \
  625|       |      stbds_temp((t)-1))
  626|       |
  627|       |#define stbds_pshgeti(t,k) \
  628|       |     ((t) = stbds_hmget_key_wrapper((t), sizeof *(t), (void*) (k), sizeof (*(t))->key, STBDS_HM_PTR_TO_STRING), \
  629|       |      stbds_temp((t)-1))
  630|       |
  631|       |#define stbds_shgetp(t, k) \
  632|       |    ((void) stbds_shgeti(t,k), &(t)[stbds_temp((t)-1)])
  633|       |
  634|       |#define stbds_pshget(t, k) \
  635|       |    ((void) stbds_pshgeti(t,k), (t)[stbds_temp((t)-1)])
  636|       |
  637|       |#define stbds_shdel(t,k) \
  638|       |    (((t) = stbds_hmdel_key_wrapper((t),sizeof *(t), (void*) (k), sizeof (t)->key, STBDS_OFFSETOF((t),key), STBDS_HM_STRING)),(t)?stbds_temp((t)-1):0)
  639|       |#define stbds_pshdel(t,k) \
  640|       |    (((t) = stbds_hmdel_key_wrapper((t),sizeof *(t), (void*) (k), sizeof (*(t))->key, STBDS_OFFSETOF(*(t),key), STBDS_HM_PTR_TO_STRING)),(t)?stbds_temp((t)-1):0)
  641|       |
  642|       |#define stbds_sh_new_arena(t)  \
  643|       |    ((t) = stbds_shmode_func_wrapper(t, sizeof *(t), STBDS_SH_ARENA))
  644|       |#define stbds_sh_new_strdup(t) \
  645|       |    ((t) = stbds_shmode_func_wrapper(t, sizeof *(t), STBDS_SH_STRDUP))
  646|       |
  647|       |#define stbds_shdefault(t, v)  stbds_hmdefault(t,v)
  648|       |#define stbds_shdefaults(t, s) stbds_hmdefaults(t,s)
  649|       |
  650|       |#define stbds_shfree       stbds_hmfree
  651|       |#define stbds_shlenu       stbds_hmlenu
  652|       |
  653|       |#define stbds_shgets(t, k) (*stbds_shgetp(t,k))
  654|       |#define stbds_shget(t, k)  (stbds_shgetp(t,k)->value)
  655|       |#define stbds_shgetp_null(t,k)  (stbds_shgeti(t,k) == -1 ? NULL : &(t)[stbds_temp((t)-1)])
  656|       |#define stbds_shlen        stbds_hmlen
  657|       |
  658|       |typedef struct
  659|       |{
  660|       |  size_t      length;
  661|       |  size_t      capacity;
  662|       |  void      * hash_table;
  663|       |  ptrdiff_t   temp;
  664|       |} stbds_array_header;
  665|       |
  666|       |typedef struct stbds_string_block
  667|       |{
  668|       |  struct stbds_string_block *next;
  669|       |  char storage[8];
  670|       |} stbds_string_block;
  671|       |
  672|       |struct stbds_string_arena
  673|       |{
  674|       |  stbds_string_block *storage;
  675|       |  size_t remaining;
  676|       |  unsigned char block;
  677|       |  unsigned char mode;  // this isn't used by the string arena itself
  678|       |};
  679|       |
  680|       |#define STBDS_HM_BINARY         0
  681|      0|#define STBDS_HM_STRING         [0;41m1[0m
  682|       |
  683|       |enum
  684|       |{
  685|       |   STBDS_SH_NONE,
  686|       |   STBDS_SH_DEFAULT,
  687|       |   STBDS_SH_STRDUP,
  688|       |   STBDS_SH_ARENA
  689|       |};
  690|       |
  691|       |#ifdef __cplusplus
  692|       |// in C we use implicit assignment from these void*-returning functions to T*.
  693|       |// in C++ these templates make the same code work
  694|       |template<class T> static T * stbds_arrgrowf_wrapper(T *a, size_t elemsize, size_t addlen, size_t min_cap) {
  695|       |  return (T*)stbds_arrgrowf((void *)a, elemsize, addlen, min_cap);
  696|       |}
  697|       |template<class T> static T * stbds_hmget_key_wrapper(T *a, size_t elemsize, void *key, size_t keysize, int mode) {
  698|       |  return (T*)stbds_hmget_key((void*)a, elemsize, key, keysize, mode);
  699|       |}
  700|       |template<class T> static T * stbds_hmget_key_ts_wrapper(T *a, size_t elemsize, void *key, size_t keysize, ptrdiff_t *temp, int mode) {
  701|       |  return (T*)stbds_hmget_key_ts((void*)a, elemsize, key, keysize, temp, mode);
  702|       |}
  703|       |template<class T> static T * stbds_hmput_default_wrapper(T *a, size_t elemsize) {
  704|       |  return (T*)stbds_hmput_default((void *)a, elemsize);
  705|       |}
  706|       |template<class T> static T * stbds_hmput_key_wrapper(T *a, size_t elemsize, void *key, size_t keysize, int mode) {
  707|       |  return (T*)stbds_hmput_key((void*)a, elemsize, key, keysize, mode);
  708|       |}
  709|       |template<class T> static T * stbds_hmdel_key_wrapper(T *a, size_t elemsize, void *key, size_t keysize, size_t keyoffset, int mode){
  710|       |  return (T*)stbds_hmdel_key((void*)a, elemsize, key, keysize, keyoffset, mode);
  711|       |}
  712|       |template<class T> static T * stbds_shmode_func_wrapper(T *, size_t elemsize, int mode) {
  713|       |  return (T*)stbds_shmode_func(elemsize, mode);
  714|       |}
  715|       |#else
  716|  1.00M|#define stbds_arrgrowf_wrapper            stbds_arrgrowf
  717|       |#define stbds_hmget_key_wrapper           stbds_hmget_key
  718|       |#define stbds_hmget_key_ts_wrapper        stbds_hmget_key_ts
  719|       |#define stbds_hmput_default_wrapper       stbds_hmput_default
  720|       |#define stbds_hmput_key_wrapper           stbds_hmput_key
  721|       |#define stbds_hmdel_key_wrapper           stbds_hmdel_key
  722|       |#define stbds_shmode_func_wrapper(t,e,m)  stbds_shmode_func(e,m)
  723|       |#endif
  724|       |
  725|       |#endif // INCLUDE_STB_DS_H
  726|       |
  727|       |

[0;36m/home/davejwatson/myprojects/boom/types.c:
[0m    1|       |#include "types.h"
    2|       |#include <stdio.h>
    3|       |#include <string.h>
    4|       |
    5|       |#include "gc.h"
    6|       |#include "symbol_table.h"
    7|       |#include "defs.h"
    8|       |
    9|   231M|#define auto __auto_type
   10|   229M|#define nullptr NULL
   11|       |
   12|       |// Mostly for debugging.  Actual scheme display/write is done from scheme.
   13|   228M|void print_obj(long obj, FILE *file) {
   14|   [0;35m228M[0m|  if (file == nullptr) [0;41m{[0m
   15|      0|[0;41m    file = stdout;[0m
   16|      0|[0;41m  }[0m
   17|   [0;35m228M[0m|  auto type = obj & TAG_MASK;
   18|   228M|  switch (type) {
   19|    [0;35m152[0m|  case FIXNUM_TAG: {
   20|    152|    fprintf(file, "%li", obj >> 3);
   21|    152|    break;
   22|      0|  }
   23|  [0;35m2.56M[0m|  case PTR_TAG: {
   24|  2.56M|    long ptrtype = *(long *)(obj - PTR_TAG);
   25|  [0;35m2.56M[0m|    if (ptrtype == STRING_TAG) {
   26|  [0;35m2.56M[0m|      auto *str = (string_s *)(obj - PTR_TAG);
   27|  2.56M|      fputs(str->str, file);
   28|  [0;35m2.56M[0m|    } else [0;41mif ([0m[0;41mptrtype == [0m[0;41mPORT_TAG[0m[0;41m) [0m[0;41m{[0m
   29|      0|[0;41m      fputs("#<port>", file);[0m
   30|      [0;35m0[0m|[0;41m    }[0m[0;41m else [0m[0;41mif ([0m[0;41mptrtype == [0m[0;41mVECTOR_TAG[0m[0;41m) [0m[0;41m{[0m
   31|      [0;35m0[0m|[0;41m      [0m[0;41mauto[0m[0;41m *v = (vector_s *)(obj - [0m[0;41mPTR_TAG[0m[0;41m);[0m
   32|      0|[0;41m      fputs("#(", file);[0m
   33|      [0;35m0[0m|[0;41m      for (long i = 0; [0m[0;41mi < (v->len >> 3)[0m[0;41m; [0m[0;41mi++[0m[0;41m) [0m[0;41m{[0m
   34|      [0;35m0[0m|[0;41m        if ([0m[0;41mi != 0[0m[0;41m) [0m[0;41m{[0m
   35|      0|[0;41m          fputc(' ', file);[0m
   36|      0|[0;41m        }[0m[0;41m[0m
   37|      0|[0;41m        print_obj(v->v[i], file);[0m
   38|      0|[0;41m      }[0m
   39|      0|[0;41m      fputc(')', file);[0m
   40|      0|[0;41m    } else [0m[0;41m{[0m
   41|      0|[0;41m      fprintf(file, "PTR:%lx", ptrtype);[0m
   42|      0|[0;41m    }[0m
   43|  2.56M|    break;
   44|      0|  }
   45|   [0;35m500k[0m|  case FLONUM_TAG: {
   46|   [0;35m500k[0m|    auto *f = (flonum_s *)(obj - FLONUM_TAG);
   47|   500k|    char buffer[40];
   48|   500k|    sprintf(buffer, "%g", f->x);
   49|   [0;35m500k[0m|    if (strpbrk(buffer, ".eE") == nullptr) {
   50|   500k|      size_t len = strlen(buffer);
   51|   500k|      buffer[len] = '.';
   52|   500k|      buffer[len + 1] = '0';
   53|   500k|      buffer[len + 2] = '\0';
   54|   500k|    }
   55|   500k|    fputs(buffer, file);
   56|   500k|    break;
   57|      0|  }
   58|      [0;35m0[0m|  [0;41mcase [0m[0;41mCONS_TAG[0m[0;41m: {[0m
   59|      [0;35m0[0m|[0;41m    [0m[0;41mauto[0m[0;41m *c = (cons_s *)(obj - [0m[0;41mCONS_TAG[0m[0;41m);[0m
   60|      0|[0;41m    fputc('(', file);[0m
   61|      [0;35m0[0m|[0;41m    while ([0m[0;41m(c->b & [0m[0;41mTAG_MASK[0m[0;41m) == [0m[0;41mCONS_TAG[0m[0;41m) [0m[0;41m{[0m
   62|      0|[0;41m      print_obj(c->a, file);[0m
   63|      0|[0;41m      c = (cons_s *)(c->b - [0m[0;41mCONS_TAG[0m[0;41m);[0m
   64|      0|[0;41m      fputc(' ', file);[0m
   65|      0|[0;41m    }[0m
   66|      0|[0;41m    print_obj(c->a, file);[0m
   67|      [0;35m0[0m|[0;41m    if ([0m[0;41mc->b != [0m[0;41mNIL_TAG[0m[0;41m) [0m[0;41m{[0m
   68|      0|[0;41m      fputs(" . ", file);[0m
   69|      0|[0;41m      print_obj(c->b, file);[0m
   70|      0|[0;41m    }[0m[0;41m[0m
   71|      0|[0;41m    fputc(')', file);[0m
   72|      0|[0;41m    break;[0m
   73|      0|[0;41m  }[0m
   74|      [0;35m0[0m|[0;41m  [0m[0;41mcase [0m[0;41mSYMBOL_TAG[0m[0;41m: {[0m
   75|      [0;35m0[0m|[0;41m    [0m[0;41mauto[0m[0;41m *sym = (symbol *)(obj - [0m[0;41mSYMBOL_TAG[0m[0;41m);[0m
   76|      0|[0;41m    string_s* sym_name = (string_s*)(sym->name - [0m[0;41mPTR_TAG[0m[0;41m);[0m
   77|      0|[0;41m    fputs(sym_name->str, file);[0m
   78|      0|[0;41m    break;[0m
   79|      0|[0;41m  }[0m
   80|      [0;35m0[0m|[0;41m  [0m[0;41mcase [0m[0;41mCLOSURE_TAG[0m[0;41m: {[0m
   81|      0|[0;41m    fputs("<closure>", file);[0m
   82|      0|[0;41m    break;[0m
   83|      0|[0;41m  }[0m
   84|      [0;35m0[0m|[0;41m  [0m[0;41mcase [0m[0;41mFORWARD_TAG[0m[0;41m: {[0m
   85|      0|[0;41m    fputs("<forward tag>", file);[0m
   86|      0|[0;41m    break;[0m
   87|      0|[0;41m  }[0m
   88|   [0;35m225M[0m|[0;41m  [0mcase LITERAL_TAG: {
   89|   [0;35m225M[0m|    if (obj == TRUE_REP) [0;41m{[0m
   90|      0|[0;41m      fputs("#t", file);[0m
   91|   [0;35m225M[0m|[0;41m    }[0m else if (obj == FALSE_REP) [0;41m{[0m
   92|      0|[0;41m      fputs("#f", file);[0m
   93|   [0;35m225M[0m|[0;41m    }[0m else if (obj == NIL_TAG) [0;41m{[0m
   94|      0|[0;41m      fputs("()", file);[0m
   95|   [0;35m225M[0m|[0;41m    }[0m else if (obj == EOF_TAG) [0;41m{[0m
   96|      0|[0;41m      fputs("<eof>", file);[0m
   97|   [0;35m225M[0m|[0;41m    }[0m else if (obj == UNDEFINED_TAG) [0;41m{[0m
   98|      0|[0;41m      fputs("<undefined>", file);[0m
   99|   [0;35m225M[0m|[0;41m    }[0m else if ((obj & IMMEDIATE_MASK) == CHAR_TAG) {
  100|   225M|      fputc((char)(obj >> 8), file);
  101|   225M|    } else [0;41m{[0m
  102|      0|[0;41m      fprintf(file, "Unknown immediate: %lx\n", obj);[0m
  103|      0|[0;41m    }[0m
  104|   225M|    break;
  105|      0|  }
  106|   228M|  }
  107|   228M|}
  108|       |
  109|     56|EXPORT long from_c_str(const char *s) {
  110|     56|  unsigned long len = strlen(s);
  111|     56|  auto *str = (string_s *)GC_malloc(16 + len + 1);
  112|     56|  str->type = STRING_TAG;
  113|     56|  str->len = len << 3;
  114|     56|  memcpy(str->str, s, len);
  115|     56|  str->str[len] = '\0';
  116|     56|  return (long)str | PTR_TAG;
  117|     56|}
  118|       |
  119|      0|long get_symbol_val(const char *name) [0;41m{[0m
  120|      0|[0;41m  [0m[0;41mauto[0m[0;41m str = from_c_str(name);[0m
  121|      [0;35m0[0m|[0;41m  [0m[0;41mauto[0m[0;41m *strp = (string_s *)(str - [0m[0;41mPTR_TAG[0m[0;41m);[0m
  122|      0|[0;41m  [0m[0;41mauto[0m[0;41m *res = symbol_table_find(strp);[0m
  123|      [0;35m0[0m|[0;41m  if ([0m[0;41mres == [0m[0;41mnullptr[0m[0;41m) [0m[0;41m{[0m
  124|      0|[0;41m    return [0m[0;41mUNDEFINED_TAG[0m[0;41m;[0m
  125|      0|[0;41m  }[0m
  126|      0|[0;41m  [0m[0;41mreturn res->val[0m[0;41m;[0m
  127|      0|[0;41m}[0m

[0;36m/home/davejwatson/myprojects/boom/types.h:
[0m    1|       |#pragma once
    2|       |
    3|       |#include <stdio.h>
    4|       |
    5|       |// GC hack:
    6|       |
    7|       |// All types are 8-byte aligned, except the return PC, which is
    8|       |// 4-byte, and stored on the stack.  As long as it looks like an
    9|       |// immediate type, we're ok.  So make sure tags 0x0 and 0x4 are
   10|       |// immediate types.
   11|       |
   12|   171M|#define FIXNUM_TAG 0x0
   13|  3.16G|#define PTR_TAG 0x1
   14|  22.4G|#define FLONUM_TAG 0x2
   15|  1.36G|#define CONS_TAG 0x3
   16|   659M|#define LITERAL_TAG 0x4
   17|  7.21G|#define CLOSURE_TAG 0x5
   18|  1.96G|#define SYMBOL_TAG 0x6
   19|   322M|#define FORWARD_TAG 0x7
   20|       |
   21|  7.70G|#define TAG_MASK 0x7
   22|       |
   23|       |// Object tags, use PTR_TAG on ptr, and OBJ_TAG in object itself as first field.
   24|       |// Bottom three bits are '001' so it is also recognized as a PTR using the same
   25|       |// tag.
   26|  5.03M|#define STRING_TAG 0x9
   27|  24.1M|#define VECTOR_TAG 0x11
   28|  98.8k|#define PORT_TAG 0x19
   29|      0|#define BOX_TAG [0;41m0x21[0m
   30|  79.4M|#define CONT_TAG 0x29
   31|       |#define INPUT_PORT_TAG 0x0119
   32|       |
   33|       |// Immediates.  Bottom three bits must be LITERAL_TAG.
   34|       |// Uses bottom byte, and other 7 bytes used for storing literal.
   35|      0|#define BOOL_TAG [0;41m0x04[0m
   36|   503M|#define TRUE_REP 0x0104
   37|  1.04G|#define FALSE_REP 0x0004
   38|  1.10G|#define CHAR_TAG 0x0c
   39|   243M|#define NIL_TAG 0x14
   40|   225M|#define EOF_TAG 0x1c
   41|   226M|#define UNDEFINED_TAG 0x24
   42|       |
   43|   335M|#define IMMEDIATE_MASK 0xff
   44|       |
   45|       |typedef struct flonum_s {
   46|       |  long type; // TODO: perhaps could save this space by making a NAN-tagged
   47|       |             // forwarding pointer? otherwise unused.
   48|       |  double x;
   49|       |} flonum_s;
   50|       |
   51|       |typedef struct string_s {
   52|       |  long type;
   53|       |  unsigned long len;
   54|       |  char str[];
   55|       |} string_s;
   56|       |
   57|       |typedef struct symbol {
   58|       |  long type; // unused except by GC
   59|       |  long name; // string_s PTR_TAG'd value
   60|       |  long val;
   61|       |} symbol;
   62|       |
   63|       |typedef struct vector_s {
   64|       |  long type;
   65|       |  unsigned long len;
   66|       |  long v[];
   67|       |} vector_s;
   68|       |
   69|       |typedef struct cons_s {
   70|       |  long type; // unused except by GC
   71|       |  long a;
   72|       |  long b;
   73|       |} cons_s;
   74|       |
   75|       |typedef struct closure_s {
   76|       |  long type; // unused except by GC
   77|       |  unsigned long len;
   78|       |  long v[];
   79|       |} closure_s;
   80|       |
   81|       |typedef struct port_s {
   82|       |  long type; // TODO could merge input_port and type somehow.
   83|       |  long input_port;
   84|       |  long fd;
   85|       |  FILE *file;
   86|       |  long eof;
   87|       |} port_s;
   88|       |
   89|       |void print_obj(long obj, FILE *file);
   90|       |long from_c_str(const char *s);
   91|       |long get_symbol_val(const char *name);

[0;36m/home/davejwatson/myprojects/boom/vm.c:
[0m    1|       |#include "vm.h"
    2|       |
    3|       |#include <assert.h>  // for assert
    4|       |#include <fcntl.h>   // for open, O_CREAT, O_RDONLY, O_TRUNC
    5|       |#include <math.h>    // for remainder, acos, asin, atan, ceil, cos
    6|       |#include <stdbool.h> // for bool, false, true
    7|       |#include <stdio.h>   // for printf, fread, fwrite, fclose, fdopen
    8|       |#include <stdlib.h>  // for exit, realloc, free, malloc
    9|       |#include <string.h>  // for memcpy, NULL, memset
   10|       |#include <unistd.h>  // for access, close, unlink, F_OK
   11|       |
   12|       |#include "defs.h"
   13|       |#include "asm_x64.h"
   14|       |#include "bytecode.h"
   15|       |#include "gc.h"
   16|       |#include "opcodes.h"
   17|       |#include "record.h"
   18|       |#ifdef PROFILER
   19|       |#include "profiler.h"
   20|       |#endif
   21|       |#include "symbol_table.h"
   22|       |#include "types.h"
   23|       |
   24|       |#include "third-party/stb_ds.h"
   25|       |
   26|       |EXPORT bool verbose = false;
   27|       |//EXPORT size_t page_cnt = 1220;
   28|       |EXPORT size_t page_cnt = 122000;
   29|       |EXPORT unsigned TRACE_MAX = 65536;
   30|       |EXPORT int joff = 0;
   31|       |EXPORT int profile = 0;
   32|       |
   33|       |bcfunc **funcs = NULL;
   34|  48.2G|#define auto __auto_type
   35|       |
   36|  [0;35m14.4G[0m|#define likely(x) __builtin_expect(!!(x), 1)
   37|  18.5G|#define unlikely(x) __builtin_expect(!!(x), 0)
   38|       |long *frame_top;
   39|       |unsigned int stacksz = 100000000;
   40|       |long *stack = NULL;
   41|       |
   42|       |unsigned char hotmap[hotmap_sz];
   43|       |
   44|    167|static void vm_init() {
   45|    [0;35m167[0m|  if (stack == NULL) {
   46|     56|    stack = (long *)malloc(sizeof(long) * stacksz);
   47|     56|  }
   48|    167|}
   49|       |
   50|     55|EXPORT void free_vm() { free(stack); }
   51|       |
   52|       |/*
   53|       |This is a tail-calling interpreter that requires 'musttail' attribute, so
   54|       |currently limited to only clang.
   55|       |
   56|       |This ensures most things stay in registers, and any slowpaths are just jumps and
   57|       |don't affect register allocation.
   58|       |
   59|       |This could be improved by using a no-callee-saved register convention, like
   60|       |llvm's cc10, but this isn't currently exposed to clang.
   61|       |
   62|       |Currently this gives ~90% of the performance of a hand-coded assembly version,
   63|       |while being more portable and easier to change.
   64|       | */
   65|       |
   66|       |#define PARAMS                                                                 \
   67|       |  unsigned char ra, unsigned instr, unsigned *pc, long *frame,                 \
   68|       |      void **op_table_arg, long argcnt
   69|  39.5G|#define ARGS ra, instr, pc, frame, op_table_arg, argcnt
   70|  39.5G|#define MUSTTAIL __attribute((musttail))
   71|       |#define DEBUG_VM(name)
   72|       |//#define DEBUG_VM(name) printf("pc %p %s ra %i rd %i rb %i rc %i\n", pc, name, ra, instr, instr&0xff, (instr>>8)); fflush(stdout);
   73|       |typedef void (*op_func)(PARAMS);
   74|       |static op_func l_op_table[INS_MAX];
   75|       |static op_func l_op_table_record[INS_MAX];
   76|       |static op_func l_op_table_profile[INS_MAX];
   77|       |
   78|       |#define NEXT_INSTR                                                             \
   79|  20.5G|  {                                                                            \
   80|  20.5G|    instr = *pc;                                                               \
   81|  20.5G|    unsigned char op = instr & 0xff;                                           \
   82|  20.5G|    ra = (instr >> 8) & 0xff;                                                  \
   83|  20.5G|    instr >>= 16;                                                              \
   84|  20.5G|    op_func *op_table_arg_c = (op_func *)op_table_arg;                         \
   85|  [0;35m39.4G[0m|    MUSTTAIL return op_table_arg_c[op](ARGS);                                  \
   86|  39.4G|  }
   87|       |
   88|  30.3k|bcfunc *find_func_for_frame(const uint32_t *pc) {
   89|  [0;35m22.0M[0m|  for (unsigned long j = 0; j < arrlen(funcs); j++) {
   90|  22.0M|    auto fun = funcs[j];
   91|  [0;35m22.0M[0m|    if (pc >= &fun->code[0] && pc <= &fun->code[fun->codelen - 1]) {
   92|  30.3k|      return fun;
   93|  30.3k|    }
   94|  22.0M|  }
   95|      0|  [0;41mreturn NULL[0m;
   96|  30.3k|}
   97|       |
   98|      2|__attribute__((noinline)) void FAIL_SLOWPATH(PARAMS) {
   99|      2|  int i = 0;
  100|      2|  printf("FAIL PC: %p %s\n", pc, ins_names[INS_OP(*pc)]);
  101|      [0;35m8[0m|  while (&frame[-1] > stack) {
  102|      6|    auto res = find_func_for_frame(pc);
  103|      [0;35m6[0m|    if (res) {
  104|      6|      printf("FUNC: %s PC %li\n", res->name, pc - &res->code[0]);
  105|      6|    }
  106|      6|    pc = (unsigned int *)frame[-1];
  107|      6|    frame[-1] = frame[ra];
  108|      6|    frame -= (INS_A(*(pc - 1)) + 1);
  109|      6|    printf("%i PC: %p\n", i++, pc);
  110|      6|  }
  111|      2|  }
  112|       |
  113|      2|__attribute__((noinline)) void FAIL_SLOWPATH_ARGCNT(PARAMS) {
  114|      2|  printf("FAIL ARGCNT INVALID\n");
  115|       |
  116|      [0;35m2[0m|  MUSTTAIL return FAIL_SLOWPATH(ARGS);
  117|      2|}
  118|       |
  119|  1.56M|void RECORD_START(PARAMS) {
  120|  [0;35m1.56M[0m|  hotmap[(((long)pc) >> 2) & hotmap_mask] = hotmap_cnt;
  121|       |  // Extra check: we may have attempted to start recording *during*
  122|       |  // a recording.
  123|  [0;35m1.56M[0m|  if (joff || (op_table_arg == (void**)l_op_table_record)) {
  124|       |    // Tail call with original op table.
  125|  [0;35m1.54M[0m|    MUSTTAIL return l_op_table[INS_OP(*pc)](ARGS);
  126|  1.54M|  }
  127|  [0;35m1.56M[0m|  MUSTTAIL return l_op_table_record[INS_OP(*pc)](
  128|  14.6k|      ra, instr, pc, frame, (void **)l_op_table_record, argcnt);
  129|  1.56M|}
  130|       |
  131|  1.04M|void RECORD(PARAMS) {
  132|  1.04M|#ifdef JIT
  133|  [0;35m1.04M[0m|  if (record(pc, frame, argcnt)) {
  134|       |    // Back to interpreting.
  135|  26.8k|    op_table_arg = (void **)l_op_table;
  136|  26.8k|  }
  137|       |#else
  138|       |  op_table_arg = (void **)l_op_table;
  139|       |#endif
  140|       |  // record may have updated state.
  141|  1.04M|  instr = *pc;
  142|  1.04M|  ra = (instr >> 8) & 0xff;
  143|  1.04M|  instr >>= 16;
  144|       |  // Call interpret op table, but with record table.
  145|       |  // Interprets *this* instruction, then advances to next
  146|  [0;35m1.04M[0m|  MUSTTAIL return l_op_table[INS_OP(*pc)](ra, instr, pc, frame, op_table_arg,
  147|  1.04M|                                          argcnt);
  148|  1.04M|}
  149|       |
  150|  2.59M|long build_list(long start, long len, const long *frame) {
  151|  2.59M|  long lst = NIL_TAG;
  152|       |  // printf("Build list from %i len %i\n", start, len);
  153|  [0;35m14.0M[0m|  for (long pos = start + len - 1; pos >= start; pos--) {
  154|  11.4M|    GC_push_root(&lst); // TODO just save in POS instead?
  155|  11.4M|    auto c = (cons_s *)GC_malloc(sizeof(cons_s));
  156|  11.4M|    GC_pop_root(&lst); // TODO just save in POS instead?
  157|  11.4M|    c->type = CONS_TAG;
  158|  11.4M|    c->a = frame[pos];
  159|  11.4M|    c->b = lst;
  160|  11.4M|    lst = (long)c + CONS_TAG;
  161|  11.4M|  }
  162|       |  
  163|  2.59M|  return lst;
  164|  2.59M|}
  165|       |
  166|      2|__attribute__((noinline)) void UNDEFINED_SYMBOL_SLOWPATH(PARAMS) {
  167|      2|  auto rd = instr;
  168|       |
  169|      2|  symbol *gp = (symbol *)(const_table[rd] - SYMBOL_TAG);
  170|       |
  171|      2|  string_s* sym_name = (string_s*)(gp->name - PTR_TAG);
  172|      2|  printf("FAIL undefined symbol: %s\n", sym_name->str);
  173|      2|}
  174|       |
  175|      0|__attribute__((noinline)) void EXPAND_STACK_SLOWPATH(PARAMS) [0;41m{[0m
  176|      [0;35m0[0m|[0;41m  if ([0m[0;41mverbose[0m[0;41m) [0m[0;41m{[0m
  177|      0|[0;41m    printf("Expand stack from %i to %i\n", stacksz, stacksz * 2);[0m
  178|      0|[0;41m  }[0m[0;41m[0m
  179|      0|[0;41m    assert(false);[0m
  180|      [0;35m0[0m|[0;41m  [0m[0;41mauto[0m[0;41m pos = frame - stack;[0m
  181|      0|[0;41m  [0m[0;41mauto[0m[0;41m oldsz = stacksz;[0m
  182|      0|[0;41m  stacksz *= 2;[0m
  183|      0|[0;41m  stack = (long *)realloc(stack, stacksz * sizeof(long));[0m
  184|      0|[0;41m  memset(&stack[oldsz], 0, sizeof(long) * (stacksz - oldsz));[0m
  185|      0|[0;41m  frame = stack + pos;[0m
  186|      0|[0;41m  frame_top = stack + stacksz - 256;[0m
  187|       |[0;41m[0m[0;41m[0m
  188|      [0;35m0[0m|[0;41m  [0m[0;41mNEXT_INSTR[0m[0;41m;[0m
  189|      0|[0;41m}[0m
  190|       |
  191|      0|long *expand_stack_slowpath(long *frame) [0;41m{[0m
  192|      [0;35m0[0m|[0;41m  if ([0m[0;41mverbose[0m[0;41m) [0m[0;41m{[0m
  193|      0|[0;41m    printf("Expand stack from %i to %i in jit\n", stacksz, stacksz * 2);[0m
  194|      0|[0;41m  }[0m[0;41m[0m
  195|      0|[0;41m    assert(false);[0m
  196|      [0;35m0[0m|[0;41m  [0m[0;41mauto[0m[0;41m pos = frame - stack;[0m
  197|      0|[0;41m  [0m[0;41mauto[0m[0;41m oldsz = stacksz;[0m
  198|      0|[0;41m  stacksz *= 2;[0m
  199|      0|[0;41m  stack = (long *)realloc(stack, stacksz * sizeof(long));[0m
  200|      0|[0;41m  memset(&stack[oldsz], 0, sizeof(long) * (stacksz - oldsz));[0m
  201|      0|[0;41m  frame = stack + pos;[0m
  202|      0|[0;41m  frame_top = stack + stacksz - 256;[0m
  203|       |[0;41m[0m[0;41m[0m
  204|      0|[0;41m  return frame;[0m
  205|      0|[0;41m}[0m
  206|       |/* A whole pile of macros to make opcode generation easier.
  207|       | *
  208|       | * The B/BC/D refer to opcode type.  'NAME' refers to scm vs C name.
  209|       | *
  210|       | * Any line starting with "LIBRARY_FUNC" will auto-generate a
  211|       | * opcode number via opcode_gen.scm.  So macros generating
  212|       | * LIBRARY_FUNC are indented a space, to not generate numbers.
  213|       | *
  214|       | * Slow paths are split to their own tail-called functions,
  215|       | * to help out the register allocator.
  216|       | *
  217|       | * TODO: VN funcs don't have proper slowpath fallbacks for overflow.
  218|       | * TODO: most functions call FAIL_SLOWPATH without listing type
  219|       | *       of failure.  This is confusing and hard to debug.
  220|       | *       Maybe pass some info in argcnt param.
  221|       | */
  222|       |#define LIBRARY_FUNC_BC(name)                                                  \
  223|  14.3G|  void INS_##name(PARAMS) {                                                    \
  224|  14.3G|    DEBUG_VM(#name);                                                           \
  225|  14.3G|    unsigned char rb = instr & 0xff;                                           \
  226|  14.3G|    unsigned char rc = (instr >> 8) & 0xff;
  227|       |#define LIBRARY_FUNC_BC_LOAD(name)                                             \
  228|  [0;35m10.2G[0m|  LIBRARY_FUNC_BC(name)                                                        \
  229|  10.2G|  long fb = frame[rb];                                                         \
  230|  10.2G|  long fc = frame[rc];
  231|       |#define LIBRARY_FUNC_B(name)                                                   \
  232|  12.2G|  void INS_##name(PARAMS) {                                                    \
  233|  12.2G|    DEBUG_VM(#name);                                                           \
  234|  12.2G|    unsigned char rb = instr & 0xff;
  235|       |#define LIBRARY_FUNC_D(name)                                                   \
  236|  7.34G|  void INS_##name(PARAMS) {                                                    \
  237|  7.34G|    DEBUG_VM(#name);                                                           \
  238|  7.34G|    auto rd = (int16_t)instr;
  239|       |#define LIBRARY_FUNC(name)                                                     \
  240|  5.46G|  void INS_##name(PARAMS) {                                                    \
  241|  5.46G|    DEBUG_VM(#name);
  242|       |#define LIBRARY_FUNC_B_LOAD(name)                                              \
  243|  [0;35m7.86G[0m|  LIBRARY_FUNC_B(name)                                                         \
  244|  7.86G|  long fb = frame[rb];
  245|  64.7M|#define LIBRARY_FUNC_B_LOAD_NAME(str, name) LIBRARY_FUNC_B_LOAD(name)
  246|  2.33G|#define LIBRARY_FUNC_BC_LOAD_NAME(str, name) LIBRARY_FUNC_BC_LOAD(name)
  247|  3.82G|#define LIBRARY_FUNC_BC_NAME(str, name) LIBRARY_FUNC_BC(name)
  248|       |#define END_LIBRARY_FUNC                                                       \
  249|  12.0G|  pc++;                                                                        \
  250|  [0;35m26.7G[0m|  NEXT_INSTR[0;41m;                                                                  \[0m
  251|      0|[0;41m  }[0m
  252|       |
  253|       |#define TYPECHECK_TAG(val, tag)                                                \
  254|  [0;35m9.05G[0m|  if (unlikely(((val) & TAG_MASK) != (tag))) [0;41m{                                 \[0m
  255|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  256|      0|[0;41m  }[0m
  257|  2.21G|#define TYPECHECK_FIXNUM(val) TYPECHECK_TAG(val, FIXNUM_TAG)
  258|       |#define TYPECHECK_IMMEDIATE(val, tag)                                          \
  259|  [0;35m47.0M[0m|  if (unlikely(((val) & IMMEDIATE_MASK) != (tag))) [0;41m{                           \[0m
  260|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  261|      0|[0;41m  }[0m
  262|       |#define LOAD_TYPE_WITH_CHECK(name, type_s, val, tag)                           \
  263|  [0;35m2.23G[0m|  TYPECHECK_TAG(val, PTR_TAG);                                                 \
  264|  [0;35m2.23G[0m|  auto (name) = (type_s *)((val) - PTR_TAG);                                   \
  265|  [0;35m2.23G[0m|  if (unlikely((name)->type != (tag))) [0;41m{                                       \[0m
  266|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  267|      0|[0;41m  }[0m
  268|       |
  269|  [0;35m1.07G[0m|LIBRARY_FUNC(ILOOP)
  270|  1.07G|END_LIBRARY_FUNC
  271|   [0;35m118M[0m|LIBRARY_FUNC(LOOP)
  272|   [0;35m118M[0m|      if (unlikely((hotmap[(((long)pc) >> 2) & hotmap_mask]) <= hotmap_loop)) {
  273|  [0;35m1.18M[0m|	MUSTTAIL return RECORD_START(ARGS);
  274|  1.18M|      }
  275|   [0;35m117M[0m|      hotmap[(((long)pc) >> 2) & hotmap_mask] -= hotmap_loop;
  276|   117M|END_LIBRARY_FUNC
  277|       |
  278|  [0;35m1.58G[0m|LIBRARY_FUNC(IFUNC) 
  279|  [0;35m1.58G[0m|  if (argcnt != ra) [0;41m{[0m
  280|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH_ARGCNT([0m[0;41mARGS[0m[0;41m);[0m
  281|      0|[0;41m  }[0m
  282|  1.58G|END_LIBRARY_FUNC
  283|       |
  284|  [0;35m70.2M[0m|LIBRARY_FUNC(FUNC)
  285|  [0;35m70.2M[0m|  if (argcnt != ra) {
  286|      [0;35m2[0m|    MUSTTAIL return FAIL_SLOWPATH_ARGCNT(ARGS);
  287|      2|  }
  288|  [0;35m70.2M[0m|  if (unlikely((hotmap[(((long)pc) >> 2) & hotmap_mask] -= hotmap_rec) == 0)) {
  289|   [0;35m351k[0m|    MUSTTAIL return RECORD_START(ARGS);
  290|   351k|  }
  291|  69.8M|END_LIBRARY_FUNC
  292|       |
  293|      [0;35m0[0m|[0;41mLIBRARY_FUNC[0m[0;41m(IFUNCV)[0m
  294|      [0;35m0[0m|[0;41m    if ([0m[0;41margcnt < ra[0m[0;41m) [0m[0;41m{[0m
  295|      [0;35m0[0m|[0;41m      [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH_ARGCNT([0m[0;41mARGS[0m[0;41m);[0m
  296|      0|[0;41m    }[0m
  297|      0|[0;41m    [0m[0;41mframe[ra] = build_list(ra, argcnt - ra, frame);[0m
  298|      0|[0;41m[0m[0;41mEND_LIBRARY_FUNC[0m
  299|       |
  300|  [0;35m58.9k[0m|LIBRARY_FUNC(FUNCV)
  301|  [0;35m58.9k[0m|    if (argcnt < ra) [0;41m{[0m
  302|      [0;35m0[0m|[0;41m      [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH_ARGCNT([0m[0;41mARGS[0m[0;41m);[0m
  303|      0|[0;41m    }[0m
  304|  [0;35m58.9k[0m|if (unlikely((hotmap[(((long)pc) >> 2) & hotmap_mask] -= hotmap_rec) == 0)) {
  305|    [0;35m335[0m|  MUSTTAIL return RECORD_START(ARGS);
  306|    335| }
  307|  58.6k|    frame[ra] = build_list(ra, argcnt - ra, frame);
  308|  58.6k|END_LIBRARY_FUNC
  309|       |
  310|       |
  311|  [0;35m83.4M[0m|LIBRARY_FUNC(ICLFUNC)
  312|  [0;35m83.4M[0m|    if (argcnt != ra) [0;41m{[0m
  313|      0|[0;41m      pc += [0m[0;41mINS_D[0m[0;41m(*(pc+1)) + 1;[0m
  314|  83.4M|[0;41m    }[0m else {
  315|  83.4M|      pc+=2;
  316|  83.4M|    }
  317|  [0;35m83.4M[0m|  NEXT_INSTR[0;41m;[0m
  318|      0|[0;41m}[0m
  319|       |
  320|  [0;35m19.6M[0m|LIBRARY_FUNC(CLFUNC)
  321|  [0;35m19.6M[0m|    if (argcnt != ra) {
  322|  14.2M|      pc += INS_D(*(pc+1)) + 1;
  323|  14.2M|    } else {
  324|  [0;35m5.40M[0m|      if (unlikely((hotmap[(((long)pc) >> 2) & hotmap_mask] -= hotmap_rec) == 0)) {
  325|  [0;35m26.4k[0m|	MUSTTAIL return RECORD_START(ARGS);
  326|  26.4k|      }
  327|  5.37M|      pc+=2;
  328|  5.37M|    }
  329|  [0;35m19.6M[0m|  NEXT_INSTR[0;41m;[0m
  330|      0|[0;41m}[0m
  331|       |
  332|   [0;35m964k[0m|LIBRARY_FUNC(ICLFUNCV)
  333|   [0;35m964k[0m|    if (argcnt < ra) [0;41m{[0m
  334|      0|[0;41m      pc += [0m[0;41mINS_D[0m[0;41m(*(pc+1)) + 1;[0m
  335|   964k|[0;41m    }[0m else {
  336|   964k|      frame[ra] = build_list(ra, argcnt - ra, frame);
  337|   964k|      pc+=2;
  338|   964k|    }
  339|       |
  340|   [0;35m964k[0m|  NEXT_INSTR[0;41m;[0m
  341|      0|[0;41m}[0m
  342|       |
  343|   [0;35m236k[0m|LIBRARY_FUNC(CLFUNCV)
  344|   [0;35m236k[0m|    if (argcnt < ra) [0;41m{[0m
  345|      0|[0;41m      pc += [0m[0;41mINS_D[0m[0;41m(*(pc+1)) + 1;[0m
  346|   236k|[0;41m    }[0m else {
  347|   [0;35m236k[0m|      if (unlikely((hotmap[(((long)pc) >> 2) & hotmap_mask] -= hotmap_rec) == 0)) {
  348|    [0;35m877[0m|	MUSTTAIL return RECORD_START(ARGS);
  349|    877|      }
  350|   235k|      frame[ra] = build_list(ra, argcnt - ra, frame);
  351|   235k|      pc+=2;
  352|   235k|    }
  353|       |
  354|   [0;35m235k[0m|  NEXT_INSTR[0;41m;[0m
  355|      0|[0;41m}[0m
  356|       |
  357|   [0;35m651M[0m|LIBRARY_FUNC_D(KSHORT)
  358|   651M|  frame[ra] = rd << 3;
  359|   651M|END_LIBRARY_FUNC
  360|       |
  361|  [0;35m1.28G[0m|LIBRARY_FUNC_D(JMP)
  362|  1.28G|  pc += rd;
  363|  [0;35m1.28G[0m|  NEXT_INSTR[0;41m;[0m
  364|      0|[0;41m}[0m
  365|       |
  366|  [0;35m10.8k[0m|LIBRARY_FUNC(IRET1)
  367|  10.8k|  pc = (unsigned int *)frame[-1];
  368|  10.8k|  frame[-1] = frame[ra];
  369|  10.8k|  frame -= (INS_A(*(pc - 1)) + 1);
  370|  [0;35m10.8k[0m|  NEXT_INSTR[0;41m;[0m
  371|      0|[0;41m}[0m
  372|       |
  373|  [0;35m2.51G[0m|LIBRARY_FUNC(RET1)
  374|  2.51G|  pc = (unsigned int *)frame[-1];
  375|  2.51G|  frame[-1] = frame[ra];
  376|  2.51G|  frame -= (INS_A(*(pc - 1)) + 1);
  377|  [0;35m2.51G[0m|  NEXT_INSTR[0;41m;[0m
  378|      0|[0;41m}[0m
  379|       |
  380|    [0;35m163[0m|LIBRARY_FUNC(HALT)
  381|    163|  }
  382|       |
  383|       |// Note signed-ness of rc.
  384|       |#define LIBRARY_FUNC_MATH_VN(name, op)                                         \
  385|  [0;35m1.32G[0m|  LIBRARY_FUNC_B(name)                                                         \
  386|  1.32G|  char rc = (instr >> 8) & 0xff;                                               \
  387|  1.32G|  long fb = frame[rb];                                                         \
  388|  [0;35m1.32G[0m|  TYPECHECK_TAG(fb, FIXNUM_TAG);                                               \
  389|  [0;35m1.32G[0m|  if (unlikely(__builtin_##op##_overflow(fb, (rc << 3), &frame[ra]))) [0;41m{        \[0m
  390|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  391|      0|[0;41m  }[0m                                                                            \
  392|  1.32G|  END_LIBRARY_FUNC
  ------------------
  | [0;36mINS_SUBVN:
[0m  |  385|   [0;35m540M[0m|  LIBRARY_FUNC_B(name)                                                         \
  |  386|   540M|  char rc = (instr >> 8) & 0xff;                                               \
  |  387|   540M|  long fb = frame[rb];                                                         \
  |  388|   [0;35m540M[0m|  TYPECHECK_TAG(fb, FIXNUM_TAG);                                               \
  |  389|   [0;35m540M[0m|  if (unlikely(__builtin_##op##_overflow(fb, (rc << 3), &frame[ra]))) [0;41m{        \[0m
  |  390|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  |  391|      0|[0;41m  }[0m                                                                            \
  |  392|   540M|  END_LIBRARY_FUNC
  ------------------
  | [0;36mINS_ADDVN:
[0m  |  385|   [0;35m781M[0m|  LIBRARY_FUNC_B(name)                                                         \
  |  386|   781M|  char rc = (instr >> 8) & 0xff;                                               \
  |  387|   781M|  long fb = frame[rb];                                                         \
  |  388|   [0;35m781M[0m|  TYPECHECK_TAG(fb, FIXNUM_TAG);                                               \
  |  389|   [0;35m781M[0m|  if (unlikely(__builtin_##op##_overflow(fb, (rc << 3), &frame[ra]))) [0;41m{        \[0m
  |  390|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  |  391|      0|[0;41m  }[0m                                                                            \
  |  392|   781M|  END_LIBRARY_FUNC
  ------------------
  393|       |
  394|       |LIBRARY_FUNC_MATH_VN(SUBVN, sub);
  395|       |LIBRARY_FUNC_MATH_VN(ADDVN, add);
  396|       |
  397|       |// Note overflow may smash dest, so don't use frame[ra] directly.
  398|       |#define OVERFLOW_OP(op, name, shift)                                           \
  399|       |  long tmp;                                                                    \
  400|       |  if (unlikely(__builtin_##op##_overflow(fb, fc >> (shift), &tmp))) {          \
  401|       |    MUSTTAIL return INS_##name##_SLOWPATH(ARGS);                               \
  402|       |  }                                                                            \
  403|       |  frame[ra] = tmp;
  404|       |
  405|       |// Shift is necessary for adjusting the tag for mul.
  406|       |#define LIBRARY_FUNC_MATH_VV(name, op2, overflow)                              \
  407|  88.2M|  __attribute__((noinline)) void INS_##name##_SLOWPATH(PARAMS) {               \
  408|  88.2M|    DEBUG_VM(#name);                                                           \
  409|  88.2M|    unsigned char rb = instr & 0xff;                                           \
  410|  88.2M|    unsigned char rc = (instr >> 8) & 0xff;                                    \
  411|  88.2M|                                                                               \
  412|  88.2M|    auto fb = frame[rb];                                                       \
  413|  88.2M|    auto fc = frame[rc];                                                       \
  414|  88.2M|    double x_b;                                                                \
  415|  88.2M|    double x_c;                                                                \
  416|  [0;35m88.2M[0m|    if ((fb & TAG_MASK) == FLONUM_TAG) {                                       \
  417|  10.0M|      x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                                \
  418|  [0;35m78.1M[0m|    } else if ((fb & TAG_MASK) == FIXNUM_TAG) {                                \
  419|  78.1M|      x_b = fb >> 3;                                                           \
  420|  78.1M|    } else [0;41m{                                                                   \[0m
  421|      [0;35m0[0m|[0;41m      [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                     \[0m
  422|      0|[0;41m    }[0m                                                                          \
  423|  [0;35m88.2M[0m|    if ((fc & TAG_MASK) == FLONUM_TAG) {                                       \
  424|  78.1M|      x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                                \
  425|  [0;35m78.1M[0m|    } else if ((fc & TAG_MASK) == FIXNUM_TAG) {                                \
  426|  10.0M|      x_c = fc >> 3;                                                           \
  427|  10.0M|    } else [0;41m{                                                                   \[0m
  428|      [0;35m0[0m|[0;41m      [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                     \[0m
  429|      0|[0;41m    }[0m                                                                          \
  430|  88.2M|                                                                               \
  431|  [0;35m88.2M[0m|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));                          \
  432|  88.2M|    r->x = op2(x_b, x_c);                                                      \
  433|  88.2M|    r->type = FLONUM_TAG;                                                      \
  434|  88.2M|    frame[ra] = (long)r | FLONUM_TAG;                                          \
  435|  88.2M|    pc++;                                                                      \
  436|  88.2M|                                                                               \
  437|  [0;35m88.2M[0m|    NEXT_INSTR[0;41m;                                                                \[0m
  438|      0|[0;41m  }[0m                                                                            \
  ------------------
  | [0;36mINS_ADDVV_SLOWPATH:
[0m  |  407|  5.01M|  __attribute__((noinline)) void INS_##name##_SLOWPATH(PARAMS) {               \
  |  408|  5.01M|    DEBUG_VM(#name);                                                           \
  |  409|  5.01M|    unsigned char rb = instr & 0xff;                                           \
  |  410|  5.01M|    unsigned char rc = (instr >> 8) & 0xff;                                    \
  |  411|  5.01M|                                                                               \
  |  412|  5.01M|    auto fb = frame[rb];                                                       \
  |  413|  5.01M|    auto fc = frame[rc];                                                       \
  |  414|  5.01M|    double x_b;                                                                \
  |  415|  5.01M|    double x_c;                                                                \
  |  416|  [0;35m5.01M[0m|    if ((fb & TAG_MASK) == FLONUM_TAG) {                                       \
  |  417|  2.50M|      x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                                \
  |  418|  [0;35m2.51M[0m|    } else if ((fb & TAG_MASK) == FIXNUM_TAG) {                                \
  |  419|  2.51M|      x_b = fb >> 3;                                                           \
  |  420|  2.51M|    } else [0;41m{                                                                   \[0m
  |  421|      [0;35m0[0m|[0;41m      [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                     \[0m
  |  422|      0|[0;41m    }[0m                                                                          \
  |  423|  [0;35m5.01M[0m|    if ((fc & TAG_MASK) == FLONUM_TAG) {                                       \
  |  424|  2.51M|      x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                                \
  |  425|  [0;35m2.51M[0m|    } else if ((fc & TAG_MASK) == FIXNUM_TAG) {                                \
  |  426|  2.50M|      x_c = fc >> 3;                                                           \
  |  427|  2.50M|    } else [0;41m{                                                                   \[0m
  |  428|      [0;35m0[0m|[0;41m      [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                     \[0m
  |  429|      0|[0;41m    }[0m                                                                          \
  |  430|  5.01M|                                                                               \
  |  431|  [0;35m5.01M[0m|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));                          \
  |  432|  5.01M|    r->x = op2(x_b, x_c);                                                      \
  |  433|  5.01M|    r->type = FLONUM_TAG;                                                      \
  |  434|  5.01M|    frame[ra] = (long)r | FLONUM_TAG;                                          \
  |  435|  5.01M|    pc++;                                                                      \
  |  436|  5.01M|                                                                               \
  |  437|  [0;35m5.01M[0m|    NEXT_INSTR[0;41m;                                                                \[0m
  |  438|      0|[0;41m  }[0m                                                                            \
  ------------------
  | [0;31mUnexecuted instantiation: INS_SUBVV_SLOWPATH
[0m  ------------------
  | [0;36mINS_MULVV_SLOWPATH:
[0m  |  407|  72.6M|  __attribute__((noinline)) void INS_##name##_SLOWPATH(PARAMS) {               \
  |  408|  72.6M|    DEBUG_VM(#name);                                                           \
  |  409|  72.6M|    unsigned char rb = instr & 0xff;                                           \
  |  410|  72.6M|    unsigned char rc = (instr >> 8) & 0xff;                                    \
  |  411|  72.6M|                                                                               \
  |  412|  72.6M|    auto fb = frame[rb];                                                       \
  |  413|  72.6M|    auto fc = frame[rc];                                                       \
  |  414|  72.6M|    double x_b;                                                                \
  |  415|  72.6M|    double x_c;                                                                \
  |  416|  [0;35m72.6M[0m|    if ((fb & TAG_MASK) == FLONUM_TAG) {                                       \
  |  417|  5.14k|      x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                                \
  |  418|  [0;35m72.6M[0m|    } else if ((fb & TAG_MASK) == FIXNUM_TAG) {                                \
  |  419|  72.6M|      x_b = fb >> 3;                                                           \
  |  420|  72.6M|    } else [0;41m{                                                                   \[0m
  |  421|      [0;35m0[0m|[0;41m      [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                     \[0m
  |  422|      0|[0;41m    }[0m                                                                          \
  |  423|  [0;35m72.6M[0m|    if ((fc & TAG_MASK) == FLONUM_TAG) {                                       \
  |  424|  72.6M|      x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                                \
  |  425|  [0;35m72.6M[0m|    } else if ((fc & TAG_MASK) == FIXNUM_TAG) {                                \
  |  426|  5.17k|      x_c = fc >> 3;                                                           \
  |  427|  5.17k|    } else [0;41m{                                                                   \[0m
  |  428|      [0;35m0[0m|[0;41m      [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                     \[0m
  |  429|      0|[0;41m    }[0m                                                                          \
  |  430|  72.6M|                                                                               \
  |  431|  [0;35m72.6M[0m|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));                          \
  |  432|  72.6M|    r->x = op2(x_b, x_c);                                                      \
  |  433|  72.6M|    r->type = FLONUM_TAG;                                                      \
  |  434|  72.6M|    frame[ra] = (long)r | FLONUM_TAG;                                          \
  |  435|  72.6M|    pc++;                                                                      \
  |  436|  72.6M|                                                                               \
  |  437|  [0;35m72.6M[0m|    NEXT_INSTR[0;41m;                                                                \[0m
  |  438|      0|[0;41m  }[0m                                                                            \
  ------------------
  | [0;36mINS_DIV_SLOWPATH:
[0m  |  407|  10.5M|  __attribute__((noinline)) void INS_##name##_SLOWPATH(PARAMS) {               \
  |  408|  10.5M|    DEBUG_VM(#name);                                                           \
  |  409|  10.5M|    unsigned char rb = instr & 0xff;                                           \
  |  410|  10.5M|    unsigned char rc = (instr >> 8) & 0xff;                                    \
  |  411|  10.5M|                                                                               \
  |  412|  10.5M|    auto fb = frame[rb];                                                       \
  |  413|  10.5M|    auto fc = frame[rc];                                                       \
  |  414|  10.5M|    double x_b;                                                                \
  |  415|  10.5M|    double x_c;                                                                \
  |  416|  [0;35m10.5M[0m|    if ((fb & TAG_MASK) == FLONUM_TAG) {                                       \
  |  417|  7.52M|      x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                                \
  |  418|  [0;35m7.52M[0m|    } else if ((fb & TAG_MASK) == FIXNUM_TAG) {                                \
  |  419|  3.00M|      x_b = fb >> 3;                                                           \
  |  420|  3.00M|    } else [0;41m{                                                                   \[0m
  |  421|      [0;35m0[0m|[0;41m      [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                     \[0m
  |  422|      0|[0;41m    }[0m                                                                          \
  |  423|  [0;35m10.5M[0m|    if ((fc & TAG_MASK) == FLONUM_TAG) {                                       \
  |  424|  3.00M|      x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                                \
  |  425|  [0;35m7.52M[0m|    } else if ((fc & TAG_MASK) == FIXNUM_TAG) {                                \
  |  426|  7.52M|      x_c = fc >> 3;                                                           \
  |  427|  7.52M|    } else [0;41m{                                                                   \[0m
  |  428|      [0;35m0[0m|[0;41m      [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                     \[0m
  |  429|      0|[0;41m    }[0m                                                                          \
  |  430|  10.5M|                                                                               \
  |  431|  [0;35m10.5M[0m|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));                          \
  |  432|  10.5M|    r->x = op2(x_b, x_c);                                                      \
  |  433|  10.5M|    r->type = FLONUM_TAG;                                                      \
  |  434|  10.5M|    frame[ra] = (long)r | FLONUM_TAG;                                          \
  |  435|  10.5M|    pc++;                                                                      \
  |  436|  10.5M|                                                                               \
  |  437|  [0;35m10.5M[0m|    NEXT_INSTR[0;41m;                                                                \[0m
  |  438|      0|[0;41m  }[0m                                                                            \
  ------------------
  | [0;31mUnexecuted instantiation: INS_REM_SLOWPATH
[0m  ------------------
  439|       |                                                                               \
  440|  [0;35m4.48G[0m|  LIBRARY_FUNC_BC_LOAD(name)                                                   \
  441|  [0;35m4.48G[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  442|   142M|    overflow;                                                                  \
  443|  [0;35m4.34G[0m|  } else if (likely(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) {              \
  444|  [0;35m4.25G[0m|    auto x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                             \
  445|  [0;35m4.25G[0m|    auto x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                             \
  446|  4.25G|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));                          \
  447|  4.25G|    r->x = op2(x_b, x_c);                                                      \
  448|  4.25G|    r->type = FLONUM_TAG;                                                      \
  449|  4.25G|    frame[ra] = (long)r | FLONUM_TAG;                                          \
  450|  4.25G|  } else {                                                                     \
  451|  [0;35m88.2M[0m|    MUSTTAIL return INS_##name##_SLOWPATH(ARGS);                               \
  452|  88.2M|  }                                                                            \
  453|  4.48G|  END_LIBRARY_FUNC
  ------------------
  | [0;36mINS_ADDVV:
[0m  |  440|  [0;35m1.63G[0m|  LIBRARY_FUNC_BC_LOAD(name)                                                   \
  |  441|  [0;35m1.63G[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  |  442|  70.4M|    overflow;                                                                  \
  |  443|  [0;35m1.56G[0m|  } else if (likely(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) {              \
  |  444|  [0;35m1.55G[0m|    auto x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                             \
  |  445|  [0;35m1.55G[0m|    auto x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                             \
  |  446|  1.55G|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));                          \
  |  447|  1.55G|    r->x = op2(x_b, x_c);                                                      \
  |  448|  1.55G|    r->type = FLONUM_TAG;                                                      \
  |  449|  1.55G|    frame[ra] = (long)r | FLONUM_TAG;                                          \
  |  450|  1.55G|  } else {                                                                     \
  |  451|  [0;35m5.01M[0m|    MUSTTAIL return INS_##name##_SLOWPATH(ARGS);                               \
  |  452|  5.01M|  }                                                                            \
  |  453|  1.63G|  END_LIBRARY_FUNC
  ------------------
  | [0;36mINS_SUBVV:
[0m  |  440|  [0;35m1.38G[0m|  LIBRARY_FUNC_BC_LOAD(name)                                                   \
  |  441|  [0;35m1.38G[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  |  442|  50.8M|    overflow;                                                                  \
  |  443|  [0;35m1.33G[0m|  } else if (likely(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) {              \
  |  444|  [0;35m1.33G[0m|    auto x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                             \
  |  445|  [0;35m1.33G[0m|    auto x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                             \
  |  446|  1.33G|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));                          \
  |  447|  1.33G|    r->x = op2(x_b, x_c);                                                      \
  |  448|  1.33G|    r->type = FLONUM_TAG;                                                      \
  |  449|  1.33G|    frame[ra] = (long)r | FLONUM_TAG;                                          \
  |  450|  1.33G|  } else [0;41m{                                                                     \[0m
  |  451|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return INS_##name##_SLOWPATH([0m[0;41mARGS[0m[0;41m);                               \[0m
  |  452|      0|[0;41m  }[0m                                                                            \
  |  453|  1.38G|  END_LIBRARY_FUNC
  ------------------
  | [0;36mINS_MULVV:
[0m  |  440|  [0;35m1.41G[0m|  LIBRARY_FUNC_BC_LOAD(name)                                                   \
  |  441|  [0;35m1.41G[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  |  442|  20.1M|    overflow;                                                                  \
  |  443|  [0;35m1.39G[0m|  } else if (likely(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) {              \
  |  444|  [0;35m1.32G[0m|    auto x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                             \
  |  445|  [0;35m1.32G[0m|    auto x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                             \
  |  446|  1.32G|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));                          \
  |  447|  1.32G|    r->x = op2(x_b, x_c);                                                      \
  |  448|  1.32G|    r->type = FLONUM_TAG;                                                      \
  |  449|  1.32G|    frame[ra] = (long)r | FLONUM_TAG;                                          \
  |  450|  1.32G|  } else {                                                                     \
  |  451|  [0;35m72.6M[0m|    MUSTTAIL return INS_##name##_SLOWPATH(ARGS);                               \
  |  452|  72.6M|  }                                                                            \
  |  453|  1.41G|  END_LIBRARY_FUNC
  ------------------
  | [0;36mINS_DIV:
[0m  |  440|  [0;35m54.2M[0m|  LIBRARY_FUNC_BC_LOAD(name)                                                   \
  |  441|  [0;35m54.2M[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  |  442|   560k|    overflow;                                                                  \
  |  443|  [0;35m53.6M[0m|  } else if (likely(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) {              \
  |  444|  [0;35m43.1M[0m|    auto x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                             \
  |  445|  [0;35m43.1M[0m|    auto x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                             \
  |  446|  43.1M|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));                          \
  |  447|  43.1M|    r->x = op2(x_b, x_c);                                                      \
  |  448|  43.1M|    r->type = FLONUM_TAG;                                                      \
  |  449|  43.1M|    frame[ra] = (long)r | FLONUM_TAG;                                          \
  |  450|  43.1M|  } else {                                                                     \
  |  451|  [0;35m10.5M[0m|    MUSTTAIL return INS_##name##_SLOWPATH(ARGS);                               \
  |  452|  10.5M|  }                                                                            \
  |  453|  54.2M|  END_LIBRARY_FUNC
  ------------------
  | [0;36mINS_REM:
[0m  |  440|   [0;35m669k[0m|  LIBRARY_FUNC_BC_LOAD(name)                                                   \
  |  441|   [0;35m669k[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  |  442|   669k|    overflow;                                                                  \
  |  443|   [0;35m669k[0m|  } else [0;41mif ([0m[0;41mlikely[0m[0;41m(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) [0m[0;41m{              \[0m
  |  444|      [0;35m0[0m|[0;41m    [0m[0;41mauto[0m[0;41m x_b = ((flonum_s *)(fb - [0m[0;41mFLONUM_TAG[0m[0;41m))->x;                             \[0m
  |  445|      [0;35m0[0m|[0;41m    [0m[0;41mauto[0m[0;41m x_c = ((flonum_s *)(fc - [0m[0;41mFLONUM_TAG[0m[0;41m))->x;                             \[0m
  |  446|      0|[0;41m    [0m[0;41mauto[0m[0;41m r = (flonum_s *)GC_malloc(sizeof(flonum_s));                          \[0m
  |  447|      0|[0;41m    r->x = op2(x_b, x_c);                                                      \[0m
  |  448|      0|[0;41m    r->type = [0m[0;41mFLONUM_TAG[0m[0;41m;                                                      \[0m
  |  449|      0|[0;41m    frame[ra] = (long)r | [0m[0;41mFLONUM_TAG[0m[0;41m;                                          \[0m
  |  450|      0|[0;41m  } else [0m[0;41m{                                                                     \[0m
  |  451|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return INS_##name##_SLOWPATH([0m[0;41mARGS[0m[0;41m);                               \[0m
  |  452|      0|[0;41m  }[0m                                                                            \
  |  453|   669k|  END_LIBRARY_FUNC
  ------------------
  454|       |
  455|       |#define LIBRARY_FUNC_MATH_OVERFLOW_VV(name, op, op2, shift)                    \
  456|       |  LIBRARY_FUNC_MATH_VV(name, op2, OVERFLOW_OP(op, name, shift));
  457|       |
  458|  1.56G|#define MATH_ADD(a, b) ((a) + (b))
  459|  1.33G|#define MATH_SUB(a, b) ((a) - (b))
  460|  1.39G|#define MATH_MUL(a, b) ((a) * (b))
  461|  53.6M|#define MATH_DIV(a, b) ((a) / (b))
  462|       |
  463|  1.56G|LIBRARY_FUNC_MATH_OVERFLOW_VV(ADDVV, add, MATH_ADD, 0);
  464|  1.33G|LIBRARY_FUNC_MATH_OVERFLOW_VV(SUBVV, sub, MATH_SUB, 0);
  465|  1.39G|LIBRARY_FUNC_MATH_OVERFLOW_VV(MULVV, mul, MATH_MUL, 3);
  466|  53.6M|LIBRARY_FUNC_MATH_VV(DIV, MATH_DIV, frame[ra] = (fb / fc) << 3);
  467|       |LIBRARY_FUNC_MATH_VV(REM, remainder, frame[ra] = ((fb >> 3) % (fc >> 3)) << 3);
  468|       |
  469|       |#define LIBRARY_FUNC_EQ(name, iftrue, iffalse, finish) \
  470|  [0;35m21.1M[0m|  LIBRARY_FUNC_BC_LOAD(name)			\
  471|  [0;35m21.1M[0m|  if (fb == fc) {				\
  472|  6.47M|    iftrue;					\
  473|  14.6M|  } else {					\
  474|  14.6M|    iffalse;					\
  475|  14.6M|  }						\
  476|  21.1M|						\
  477|  21.1M|  pc += (finish);				\
  478|  [0;35m21.1M[0m|  NEXT_INSTR[0;41m;					\[0m
  479|      0|[0;41m}[0m
  ------------------
  | [0;36mINS_EQ:
[0m  |  470|  [0;35m3.75M[0m|  LIBRARY_FUNC_BC_LOAD(name)			\
  |  471|  [0;35m3.75M[0m|  if (fb == fc) {				\
  |  472|   935k|    iftrue;					\
  |  473|  2.81M|  } else {					\
  |  474|  2.81M|    iffalse;					\
  |  475|  2.81M|  }						\
  |  476|  3.75M|						\
  |  477|  3.75M|  pc += (finish);				\
  |  478|  [0;35m3.75M[0m|  NEXT_INSTR[0;41m;					\[0m
  |  479|      0|[0;41m}[0m
  ------------------
  | [0;36mINS_JEQ:
[0m  |  470|  [0;35m17.3M[0m|  LIBRARY_FUNC_BC_LOAD(name)			\
  |  471|  [0;35m17.3M[0m|  if (fb == fc) {				\
  |  472|  5.53M|    iftrue;					\
  |  473|  11.8M|  } else {					\
  |  474|  11.8M|    iffalse;					\
  |  475|  11.8M|  }						\
  |  476|  17.3M|						\
  |  477|  17.3M|  pc += (finish);				\
  |  478|  [0;35m17.3M[0m|  NEXT_INSTR[0;41m;					\[0m
  |  479|      0|[0;41m}[0m
  ------------------
  | [0;36mINS_JNEQ:
[0m  |  470|  [0;35m14.5k[0m|  LIBRARY_FUNC_BC_LOAD(name)			\
  |  471|  [0;35m14.5k[0m|  if (fb == fc) {				\
  |  472|  6.18k|    iftrue;					\
  |  473|  8.36k|  } else {					\
  |  474|  8.36k|    iffalse;					\
  |  475|  8.36k|  }						\
  |  476|  14.5k|						\
  |  477|  14.5k|  pc += (finish);				\
  |  478|  [0;35m14.5k[0m|  NEXT_INSTR[0;41m;					\[0m
  |  479|      0|[0;41m}[0m
  ------------------
  480|       |
  481|       |LIBRARY_FUNC_EQ(EQ, frame[ra] = TRUE_REP, frame[ra] = FALSE_REP, 1);
  482|       |LIBRARY_FUNC_EQ(JEQ, pc += 2, pc += INS_D(*(pc+1)) + 1, 0);
  483|       |LIBRARY_FUNC_EQ(JNEQ, pc += INS_D(*(pc+1)) + 1, pc += 2, 0);
  484|       |
  485|       |#define LIBRARY_FUNC_NUM_CMP(name, op, func)				      \
  486|  [0;35m51.0M[0m| LIBRARY_FUNC_BC_LOAD(name##_SLOWPATH)                                        \
  487|  51.0M|  double x_b;                                                                  \
  488|  51.0M|  double x_c;                                                                  \
  489|  [0;35m51.0M[0m|  if ((fb & TAG_MASK) == FLONUM_TAG) {                                         \
  490|  51.0M|    x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                                  \
  491|  [0;35m51.0M[0m|  } else [0;41mif ([0m[0;41m(fb & [0m[0;41mTAG_MASK[0m[0;41m) == [0m[0;41mFIXNUM_TAG[0m[0;41m) [0m[0;41m{                                  \[0m
  492|      0|[0;41m    x_b = fb >> 3;                                                             \[0m
  493|      0|[0;41m  }[0m[0;41m else [0m[0;41m{                                                                     \[0m
  494|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  495|      0|[0;41m  }[0m                                                                            \
  496|  [0;35m51.0M[0m|  if ((fc & TAG_MASK) == FLONUM_TAG) [0;41m{                                         \[0m
  497|      0|[0;41m    x_c = ((flonum_s *)(fc - [0m[0;41mFLONUM_TAG[0m[0;41m))->x;                                  \[0m
  498|  [0;35m51.0M[0m|[0;41m  }[0m else if ((fc & TAG_MASK) == FIXNUM_TAG) {                                  \
  499|  51.0M|    x_c = fc >> 3;                                                             \
  500|  51.0M|  } else [0;41m{                                                                     \[0m
  501|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  502|      0|[0;41m  }[0m                                                                            \
  503|  51.0M|                                                                               \
  504|  [0;35m51.0M[0m|  func(x_b, x_c, op);                                                          \
  505|  51.0M|                                                                               \
  506|  [0;35m51.0M[0m|  NEXT_INSTR[0;41m;                                                                  \[0m
  507|      0|[0;41m  }[0m                                                                            \
  ------------------
  | [0;31mUnexecuted instantiation: INS_JISLT_SLOWPATH
[0m  ------------------
  | [0;36mINS_JISEQ_SLOWPATH:
[0m  |  486|  [0;35m16.5M[0m| LIBRARY_FUNC_BC_LOAD(name##_SLOWPATH)                                        \
  |  487|  16.5M|  double x_b;                                                                  \
  |  488|  16.5M|  double x_c;                                                                  \
  |  489|  [0;35m16.5M[0m|  if ((fb & TAG_MASK) == FLONUM_TAG) {                                         \
  |  490|  16.5M|    x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                                  \
  |  491|  [0;35m16.5M[0m|  } else [0;41mif ([0m[0;41m(fb & [0m[0;41mTAG_MASK[0m[0;41m) == [0m[0;41mFIXNUM_TAG[0m[0;41m) [0m[0;41m{                                  \[0m
  |  492|      0|[0;41m    x_b = fb >> 3;                                                             \[0m
  |  493|      0|[0;41m  }[0m[0;41m else [0m[0;41m{                                                                     \[0m
  |  494|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  |  495|      0|[0;41m  }[0m                                                                            \
  |  496|  [0;35m16.5M[0m|  if ((fc & TAG_MASK) == FLONUM_TAG) [0;41m{                                         \[0m
  |  497|      0|[0;41m    x_c = ((flonum_s *)(fc - [0m[0;41mFLONUM_TAG[0m[0;41m))->x;                                  \[0m
  |  498|  [0;35m16.5M[0m|[0;41m  }[0m else if ((fc & TAG_MASK) == FIXNUM_TAG) {                                  \
  |  499|  16.5M|    x_c = fc >> 3;                                                             \
  |  500|  16.5M|  } else [0;41m{                                                                     \[0m
  |  501|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  |  502|      0|[0;41m  }[0m                                                                            \
  |  503|  16.5M|                                                                               \
  |  504|  [0;35m16.5M[0m|  func(x_b, x_c, op);                                                          \
  |  505|  16.5M|                                                                               \
  |  506|  [0;35m16.5M[0m|  NEXT_INSTR[0;41m;                                                                  \[0m
  |  507|      0|[0;41m  }[0m                                                                            \
  ------------------
  | [0;31mUnexecuted instantiation: INS_JISNEQ_SLOWPATH
[0m  ------------------
  | [0;36mINS_JISLTE_SLOWPATH:
[0m  |  486|      [0;35m1[0m| LIBRARY_FUNC_BC_LOAD(name##_SLOWPATH)                                        \
  |  487|      1|  double x_b;                                                                  \
  |  488|      1|  double x_c;                                                                  \
  |  489|      [0;35m1[0m|  if ((fb & TAG_MASK) == FLONUM_TAG) {                                         \
  |  490|      1|    x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                                  \
  |  491|      [0;35m1[0m|  } else [0;41mif ([0m[0;41m(fb & [0m[0;41mTAG_MASK[0m[0;41m) == [0m[0;41mFIXNUM_TAG[0m[0;41m) [0m[0;41m{                                  \[0m
  |  492|      0|[0;41m    x_b = fb >> 3;                                                             \[0m
  |  493|      0|[0;41m  }[0m[0;41m else [0m[0;41m{                                                                     \[0m
  |  494|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  |  495|      0|[0;41m  }[0m                                                                            \
  |  496|      [0;35m1[0m|  if ((fc & TAG_MASK) == FLONUM_TAG) [0;41m{                                         \[0m
  |  497|      0|[0;41m    x_c = ((flonum_s *)(fc - [0m[0;41mFLONUM_TAG[0m[0;41m))->x;                                  \[0m
  |  498|      [0;35m1[0m|[0;41m  }[0m else if ((fc & TAG_MASK) == FIXNUM_TAG) {                                  \
  |  499|      1|    x_c = fc >> 3;                                                             \
  |  500|      1|  } else [0;41m{                                                                     \[0m
  |  501|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  |  502|      0|[0;41m  }[0m                                                                            \
  |  503|      1|                                                                               \
  |  504|      [0;35m1[0m|  func(x_b, x_c, op);                                                          \
  |  505|      1|                                                                               \
  |  506|      [0;35m1[0m|  NEXT_INSTR[0;41m;                                                                  \[0m
  |  507|      0|[0;41m  }[0m                                                                            \
  ------------------
  | [0;31mUnexecuted instantiation: INS_JISGT_SLOWPATH
[0m  ------------------
  | [0;31mUnexecuted instantiation: INS_JISGTE_SLOWPATH
[0m  ------------------
  | [0;36mINS_ISLT_SLOWPATH:
[0m  |  486|  [0;35m20.5M[0m| LIBRARY_FUNC_BC_LOAD(name##_SLOWPATH)                                        \
  |  487|  20.5M|  double x_b;                                                                  \
  |  488|  20.5M|  double x_c;                                                                  \
  |  489|  [0;35m20.5M[0m|  if ((fb & TAG_MASK) == FLONUM_TAG) {                                         \
  |  490|  20.5M|    x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                                  \
  |  491|  [0;35m20.5M[0m|  } else [0;41mif ([0m[0;41m(fb & [0m[0;41mTAG_MASK[0m[0;41m) == [0m[0;41mFIXNUM_TAG[0m[0;41m) [0m[0;41m{                                  \[0m
  |  492|      0|[0;41m    x_b = fb >> 3;                                                             \[0m
  |  493|      0|[0;41m  }[0m[0;41m else [0m[0;41m{                                                                     \[0m
  |  494|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  |  495|      0|[0;41m  }[0m                                                                            \
  |  496|  [0;35m20.5M[0m|  if ((fc & TAG_MASK) == FLONUM_TAG) [0;41m{                                         \[0m
  |  497|      0|[0;41m    x_c = ((flonum_s *)(fc - [0m[0;41mFLONUM_TAG[0m[0;41m))->x;                                  \[0m
  |  498|  [0;35m20.5M[0m|[0;41m  }[0m else if ((fc & TAG_MASK) == FIXNUM_TAG) {                                  \
  |  499|  20.5M|    x_c = fc >> 3;                                                             \
  |  500|  20.5M|  } else [0;41m{                                                                     \[0m
  |  501|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  |  502|      0|[0;41m  }[0m                                                                            \
  |  503|  20.5M|                                                                               \
  |  504|  [0;35m20.5M[0m|  func(x_b, x_c, op);                                                          \
  |  505|  20.5M|                                                                               \
  |  506|  [0;35m20.5M[0m|  NEXT_INSTR[0;41m;                                                                  \[0m
  |  507|      0|[0;41m  }[0m                                                                            \
  ------------------
  | [0;36mINS_ISGT_SLOWPATH:
[0m  |  486|  [0;35m14.0M[0m| LIBRARY_FUNC_BC_LOAD(name##_SLOWPATH)                                        \
  |  487|  14.0M|  double x_b;                                                                  \
  |  488|  14.0M|  double x_c;                                                                  \
  |  489|  [0;35m14.0M[0m|  if ((fb & TAG_MASK) == FLONUM_TAG) {                                         \
  |  490|  14.0M|    x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                                  \
  |  491|  [0;35m14.0M[0m|  } else [0;41mif ([0m[0;41m(fb & [0m[0;41mTAG_MASK[0m[0;41m) == [0m[0;41mFIXNUM_TAG[0m[0;41m) [0m[0;41m{                                  \[0m
  |  492|      0|[0;41m    x_b = fb >> 3;                                                             \[0m
  |  493|      0|[0;41m  }[0m[0;41m else [0m[0;41m{                                                                     \[0m
  |  494|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  |  495|      0|[0;41m  }[0m                                                                            \
  |  496|  [0;35m14.0M[0m|  if ((fc & TAG_MASK) == FLONUM_TAG) [0;41m{                                         \[0m
  |  497|      0|[0;41m    x_c = ((flonum_s *)(fc - [0m[0;41mFLONUM_TAG[0m[0;41m))->x;                                  \[0m
  |  498|  [0;35m14.0M[0m|[0;41m  }[0m else if ((fc & TAG_MASK) == FIXNUM_TAG) {                                  \
  |  499|  14.0M|    x_c = fc >> 3;                                                             \
  |  500|  14.0M|  } else [0;41m{                                                                     \[0m
  |  501|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  |  502|      0|[0;41m  }[0m                                                                            \
  |  503|  14.0M|                                                                               \
  |  504|  [0;35m14.0M[0m|  func(x_b, x_c, op);                                                          \
  |  505|  14.0M|                                                                               \
  |  506|  [0;35m14.0M[0m|  NEXT_INSTR[0;41m;                                                                  \[0m
  |  507|      0|[0;41m  }[0m                                                                            \
  ------------------
  | [0;31mUnexecuted instantiation: INS_ISLTE_SLOWPATH
[0m  ------------------
  | [0;31mUnexecuted instantiation: INS_ISGTE_SLOWPATH
[0m  ------------------
  | [0;31mUnexecuted instantiation: INS_ISEQ_SLOWPATH
[0m  ------------------
  508|  [0;35m3.38G[0m| LIBRARY_FUNC_BC_LOAD(name)                                                   \
  509|  [0;35m3.38G[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  510|  [0;35m1.14G[0m|    func(fb, fc, op);                                                          \
  511|  [0;35m2.24G[0m|  } else if (likely(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) {              \
  512|  [0;35m2.19G[0m|    auto x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                             \
  513|  [0;35m2.19G[0m|    auto x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                             \
  514|  [0;35m2.19G[0m|    func(x_b, x_c, op);                                                        \
  515|  1.79G|  } else {                                                                     \
  516|  [0;35m51.0M[0m|    MUSTTAIL return INS_##name##_SLOWPATH(ARGS);                               \
  517|  51.0M|  }                                                                            \
  518|  3.38G|                                                                               \
  519|  [0;35m3.38G[0m|  NEXT_INSTR[0;41m;                                                                  \[0m
  520|      0|[0;41m  }[0m
  ------------------
  | [0;36mINS_JISLT:
[0m  |  508|  [0;35m1.57G[0m| LIBRARY_FUNC_BC_LOAD(name)                                                   \
  |  509|  [0;35m1.57G[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  |  510|   [0;35m610M[0m|    func(fb, fc, op);                                                          \
  |  511|   [0;35m965M[0m|  } else if (likely(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) {              \
  |  512|   [0;35m965M[0m|    auto x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                             \
  |  513|   [0;35m965M[0m|    auto x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                             \
  |  514|   [0;35m965M[0m|    func(x_b, x_c, op);                                                        \
  |  515|   965M|  } else [0;41m{                                                                     \[0m
  |  516|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return INS_##name##_SLOWPATH([0m[0;41mARGS[0m[0;41m);                               \[0m
  |  517|      0|[0;41m  }[0m                                                                            \
  |  518|  1.57G|                                                                               \
  |  519|  1.57G|  NEXT_INSTR[0;41m;                                                                  \[0m
  |  520|      0|[0;41m  }[0m
  ------------------
  | [0;36mINS_JISEQ:
[0m  |  508|   [0;35m295M[0m| LIBRARY_FUNC_BC_LOAD(name)                                                   \
  |  509|   [0;35m295M[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  |  510|   [0;35m275M[0m|    func(fb, fc, op);                                                          \
  |  511|   [0;35m275M[0m|  } else if (likely(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) {              \
  |  512|  [0;35m3.99M[0m|    auto x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                             \
  |  513|  [0;35m3.99M[0m|    auto x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                             \
  |  514|  [0;35m3.99M[0m|    func(x_b, x_c, op);                                                        \
  |  515|  16.5M|  } else {                                                                     \
  |  516|  [0;35m16.5M[0m|    MUSTTAIL return INS_##name##_SLOWPATH(ARGS);                               \
  |  517|  16.5M|  }                                                                            \
  |  518|   295M|                                                                               \
  |  519|   295M|  NEXT_INSTR[0;41m;                                                                  \[0m
  |  520|      0|[0;41m  }[0m
  ------------------
  | [0;36mINS_JISNEQ:
[0m  |  508|  [0;35m3.01M[0m| LIBRARY_FUNC_BC_LOAD(name)                                                   \
  |  509|  [0;35m3.01M[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  |  510|  [0;35m3.01M[0m|    func(fb, fc, op);                                                          \
  |  511|  [0;35m3.01M[0m|  } else [0;41mif ([0m[0;41mlikely[0m[0;41m(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) [0m[0;41m{              \[0m
  |  512|      [0;35m0[0m|[0;41m    [0m[0;41mauto[0m[0;41m x_b = ((flonum_s *)(fb - [0m[0;41mFLONUM_TAG[0m[0;41m))->x;                             \[0m
  |  513|      [0;35m0[0m|[0;41m    [0m[0;41mauto[0m[0;41m x_c = ((flonum_s *)(fc - [0m[0;41mFLONUM_TAG[0m[0;41m))->x;                             \[0m
  |  514|      [0;35m0[0m|[0;41m    [0m[0;41mfunc[0m[0;41m(x_b, x_c, op);                                                        \[0m
  |  515|      0|[0;41m  }[0m[0;41m else [0m[0;41m{                                                                     \[0m
  |  516|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return INS_##name##_SLOWPATH([0m[0;41mARGS[0m[0;41m);                               \[0m
  |  517|      0|[0;41m  }[0m                                                                            \
  |  518|  3.01M|                                                                               \
  |  519|  3.01M|  NEXT_INSTR[0;41m;                                                                  \[0m
  |  520|      0|[0;41m  }[0m
  ------------------
  | [0;36mINS_JISLTE:
[0m  |  508|   [0;35m469M[0m| LIBRARY_FUNC_BC_LOAD(name)                                                   \
  |  509|   [0;35m469M[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  |  510|  [0;35m9.91k[0m|    func(fb, fc, op);                                                          \
  |  511|   [0;35m469M[0m|  } else if (likely(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) {              \
  |  512|   [0;35m469M[0m|    auto x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                             \
  |  513|   [0;35m469M[0m|    auto x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                             \
  |  514|   [0;35m469M[0m|    func(x_b, x_c, op);                                                        \
  |  515|   469M|  } else {                                                                     \
  |  516|      [0;35m1[0m|    MUSTTAIL return INS_##name##_SLOWPATH(ARGS);                               \
  |  517|      1|  }                                                                            \
  |  518|   469M|                                                                               \
  |  519|   469M|  NEXT_INSTR[0;41m;                                                                  \[0m
  |  520|      0|[0;41m  }[0m
  ------------------
  | [0;36mINS_JISGT:
[0m  |  508|   [0;35m397M[0m| LIBRARY_FUNC_BC_LOAD(name)                                                   \
  |  509|   [0;35m397M[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  |  510|   [0;35m222M[0m|    func(fb, fc, op);                                                          \
  |  511|   [0;35m222M[0m|  } else if (likely(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) {              \
  |  512|   [0;35m174M[0m|    auto x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                             \
  |  513|   [0;35m174M[0m|    auto x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                             \
  |  514|   [0;35m174M[0m|    func(x_b, x_c, op);                                                        \
  |  515|   174M|  } else [0;41m{                                                                     \[0m
  |  516|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return INS_##name##_SLOWPATH([0m[0;41mARGS[0m[0;41m);                               \[0m
  |  517|      0|[0;41m  }[0m                                                                            \
  |  518|   397M|                                                                               \
  |  519|   397M|  NEXT_INSTR[0;41m;                                                                  \[0m
  |  520|      0|[0;41m  }[0m
  ------------------
  | [0;36mINS_JISGTE:
[0m  |  508|   [0;35m199M[0m| LIBRARY_FUNC_BC_LOAD(name)                                                   \
  |  509|   [0;35m199M[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  |  510|  [0;35m21.7M[0m|    func(fb, fc, op);                                                          \
  |  511|   [0;35m178M[0m|  } else if (likely(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) {              \
  |  512|   [0;35m178M[0m|    auto x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                             \
  |  513|   [0;35m178M[0m|    auto x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                             \
  |  514|   [0;35m178M[0m|    func(x_b, x_c, op);                                                        \
  |  515|   178M|  } else [0;41m{                                                                     \[0m
  |  516|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return INS_##name##_SLOWPATH([0m[0;41mARGS[0m[0;41m);                               \[0m
  |  517|      0|[0;41m  }[0m                                                                            \
  |  518|   199M|                                                                               \
  |  519|   199M|  NEXT_INSTR[0;41m;                                                                  \[0m
  |  520|      0|[0;41m  }[0m
  ------------------
  | [0;36mINS_ISLT:
[0m  |  508|   [0;35m427M[0m| LIBRARY_FUNC_BC_LOAD(name)                                                   \
  |  509|   [0;35m427M[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  |  510|  7.14M|    func(fb, fc, op);                                                          \
  |  511|   [0;35m420M[0m|  } else if (likely(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) {              \
  |  512|   [0;35m399M[0m|    auto x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                             \
  |  513|   [0;35m399M[0m|    auto x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                             \
  |  514|   399M|    func(x_b, x_c, op);                                                        \
  |  515|   399M|  } else {                                                                     \
  |  516|  [0;35m20.5M[0m|    MUSTTAIL return INS_##name##_SLOWPATH(ARGS);                               \
  |  517|  20.5M|  }                                                                            \
  |  518|   427M|                                                                               \
  |  519|   427M|  NEXT_INSTR[0;41m;                                                                  \[0m
  |  520|      0|[0;41m  }[0m
  ------------------
  | [0;36mINS_ISGT:
[0m  |  508|  [0;35m14.0M[0m| LIBRARY_FUNC_BC_LOAD(name)                                                   \
  |  509|  [0;35m14.0M[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  |  510|  45.1k|    func(fb, fc, op);                                                          \
  |  511|  [0;35m14.0M[0m|  } else if (likely(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) [0;41m{              \[0m
  |  512|      [0;35m0[0m|[0;41m    [0m[0;41mauto[0m[0;41m x_b = ((flonum_s *)(fb - [0m[0;41mFLONUM_TAG[0m[0;41m))->x;                             \[0m
  |  513|      [0;35m0[0m|[0;41m    [0m[0;41mauto[0m[0;41m x_c = ((flonum_s *)(fc - [0m[0;41mFLONUM_TAG[0m[0;41m))->x;                             \[0m
  |  514|      0|[0;41m    [0m[0;41mfunc[0m[0;41m(x_b, x_c, op);                                                        \[0m
  |  515|  14.0M|[0;41m  }[0m else {                                                                     \
  |  516|  [0;35m14.0M[0m|    MUSTTAIL return INS_##name##_SLOWPATH(ARGS);                               \
  |  517|  14.0M|  }                                                                            \
  |  518|  14.0M|                                                                               \
  |  519|  14.0M|  NEXT_INSTR[0;41m;                                                                  \[0m
  |  520|      0|[0;41m  }[0m
  ------------------
  | [0;36mINS_ISLTE:
[0m  |  508|  [0;35m2.23M[0m| LIBRARY_FUNC_BC_LOAD(name)                                                   \
  |  509|  [0;35m2.23M[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  |  510|   587k|    func(fb, fc, op);                                                          \
  |  511|  [0;35m1.65M[0m|  } else if (likely(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) {              \
  |  512|  [0;35m1.65M[0m|    auto x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                             \
  |  513|  [0;35m1.65M[0m|    auto x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                             \
  |  514|  1.65M|    func(x_b, x_c, op);                                                        \
  |  515|  1.65M|  } else [0;41m{                                                                     \[0m
  |  516|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return INS_##name##_SLOWPATH([0m[0;41mARGS[0m[0;41m);                               \[0m
  |  517|      0|[0;41m  }[0m                                                                            \
  |  518|  2.23M|                                                                               \
  |  519|  2.23M|  NEXT_INSTR[0;41m;                                                                  \[0m
  |  520|      0|[0;41m  }[0m
  ------------------
  | [0;36mINS_ISGTE:
[0m  |  508|    [0;35m193[0m| LIBRARY_FUNC_BC_LOAD(name)                                                   \
  |  509|    [0;35m193[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  |  510|    193|    func(fb, fc, op);                                                          \
  |  511|    [0;35m193[0m|  } else [0;41mif ([0m[0;41mlikely[0m[0;41m(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) [0m[0;41m{              \[0m
  |  512|      [0;35m0[0m|[0;41m    [0m[0;41mauto[0m[0;41m x_b = ((flonum_s *)(fb - [0m[0;41mFLONUM_TAG[0m[0;41m))->x;                             \[0m
  |  513|      [0;35m0[0m|[0;41m    [0m[0;41mauto[0m[0;41m x_c = ((flonum_s *)(fc - [0m[0;41mFLONUM_TAG[0m[0;41m))->x;                             \[0m
  |  514|      0|[0;41m    [0m[0;41mfunc[0m[0;41m(x_b, x_c, op);                                                        \[0m
  |  515|      0|[0;41m  } else [0m[0;41m{                                                                     \[0m
  |  516|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return INS_##name##_SLOWPATH([0m[0;41mARGS[0m[0;41m);                               \[0m
  |  517|      0|[0;41m  }[0m                                                                            \
  |  518|    193|                                                                               \
  |  519|    193|  NEXT_INSTR[0;41m;                                                                  \[0m
  |  520|      0|[0;41m  }[0m
  ------------------
  | [0;36mINS_ISEQ:
[0m  |  508|  [0;35m34.7k[0m| LIBRARY_FUNC_BC_LOAD(name)                                                   \
  |  509|  [0;35m34.7k[0m|  if (likely((7 & (fb | fc)) == 0)) {                                          \
  |  510|  34.7k|    func(fb, fc, op);                                                          \
  |  511|  [0;35m34.7k[0m|  } else if (likely(((7 & fb) == (7 & fc)) && ((7 & fc) == 2))) {              \
  |  512|      [0;35m1[0m|    auto x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;                             \
  |  513|      [0;35m1[0m|    auto x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;                             \
  |  514|      1|    func(x_b, x_c, op);                                                        \
  |  515|      1|  } else [0;41m{                                                                     \[0m
  |  516|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return INS_##name##_SLOWPATH([0m[0;41mARGS[0m[0;41m);                               \[0m
  |  517|      0|[0;41m  }[0m                                                                            \
  |  518|  34.7k|                                                                               \
  |  519|  34.7k|  NEXT_INSTR[0;41m;                                                                  \[0m
  |  520|      0|[0;41m  }[0m
  ------------------
  521|       |
  522|       |#define MOVE_PC(a, b, op)                                                      \
  523|  [0;35m2.94G[0m|  assert(INS_OP(*(pc + 1)) == JMP);                                            \
  524|  [0;35m2.94G[0m|  if (a op b) {                                                                \
  525|  1.19G|    pc += 2;                                                                   \
  526|  1.74G|  } else {                                                                     \
  527|  1.74G|    pc += INS_D(*(pc + 1)) + 1;                                                \
  528|  1.74G|  }
  529|       |
  530|       |#define SET_RES(a, b, op)                                                      \
  531|   [0;35m443M[0m|  if (a op b) {                                                                \
  532|   276M|    frame[ra] = TRUE_REP;                                                      \
  533|   276M|  } else {                                                                     \
  534|   166M|    frame[ra] = FALSE_REP;                                                     \
  535|   166M|  }                                                                            \
  536|   443M|  pc++;
  537|       |
  538|  1.57G|LIBRARY_FUNC_NUM_CMP(JISLT, <, MOVE_PC);
  539|   295M|LIBRARY_FUNC_NUM_CMP(JISEQ, ==, MOVE_PC);
  540|  3.01M|LIBRARY_FUNC_NUM_CMP(JISNEQ, !=, MOVE_PC);
  541|   469M|LIBRARY_FUNC_NUM_CMP(JISLTE, <=, MOVE_PC);
  542|   397M|LIBRARY_FUNC_NUM_CMP(JISGT, >, MOVE_PC);
  543|   199M|LIBRARY_FUNC_NUM_CMP(JISGTE, >=, MOVE_PC);
  544|   427M|LIBRARY_FUNC_NUM_CMP(ISLT, <, SET_RES);
  545|  14.0M|LIBRARY_FUNC_NUM_CMP(ISGT, >, SET_RES);
  546|  2.23M|LIBRARY_FUNC_NUM_CMP(ISLTE, <=, SET_RES);
  547|    193|LIBRARY_FUNC_NUM_CMP(ISGTE, >=, SET_RES);
  548|  34.7k|LIBRARY_FUNC_NUM_CMP(ISEQ, ==, SET_RES);
  549|       |
  550|       |#define LIBRARY_FUNC_JISF(name, iftrue, iffalse)	\
  551|   [0;35m647M[0m|  LIBRARY_FUNC_B_LOAD(name)				\
  552|   647M|  assert(INS_OP(*(pc+1)) == JMP);			\
  553|   [0;35m647M[0m|  if (fb == FALSE_REP) {				\
  554|   285M|    pc += (iftrue);					\
  555|   361M|  } else {						\
  556|   361M|    pc += (iffalse);					\
  557|   361M|  }							\
  558|   647M|							\
  559|   [0;35m647M[0m|  NEXT_INSTR[0;41m;						\[0m
  560|      0|[0;41m}[0m
  ------------------
  | [0;36mINS_JISF:
[0m  |  551|   [0;35m647M[0m|  LIBRARY_FUNC_B_LOAD(name)				\
  |  552|   647M|  assert(INS_OP(*(pc+1)) == JMP);			\
  |  553|   [0;35m647M[0m|  if (fb == FALSE_REP) {				\
  |  554|   285M|    pc += (iftrue);					\
  |  555|   361M|  } else {						\
  |  556|   361M|    pc += (iffalse);					\
  |  557|   361M|  }							\
  |  558|   647M|							\
  |  559|   [0;35m647M[0m|  NEXT_INSTR[0;41m;						\[0m
  |  560|      0|[0;41m}[0m
  ------------------
  | [0;36mINS_JIST:
[0m  |  551|   [0;35m262k[0m|  LIBRARY_FUNC_B_LOAD(name)				\
  |  552|   262k|  assert(INS_OP(*(pc+1)) == JMP);			\
  |  553|   [0;35m262k[0m|  if (fb == FALSE_REP) {				\
  |  554|   101k|    pc += (iftrue);					\
  |  555|   160k|  } else {						\
  |  556|   160k|    pc += (iffalse);					\
  |  557|   160k|  }							\
  |  558|   262k|							\
  |  559|   [0;35m262k[0m|  NEXT_INSTR[0;41m;						\[0m
  |  560|      0|[0;41m}[0m
  ------------------
  561|       |LIBRARY_FUNC_JISF(JISF, INS_D(*(pc+1)) + 1, 2);
  562|       |LIBRARY_FUNC_JISF(JIST, 2, INS_D(*(pc+1)) + 1);
  563|       |
  564|  [0;35m1.90G[0m|LIBRARY_FUNC_D(GGET)
  565|  1.90G|  symbol *gp = (symbol *)(const_table[rd] - SYMBOL_TAG);
  566|  [0;35m1.90G[0m|  if (unlikely(gp->val == UNDEFINED_TAG)) {
  567|      [0;35m2[0m|    MUSTTAIL return UNDEFINED_SYMBOL_SLOWPATH(ARGS);
  568|      2|  }
  569|       |
  570|  1.90G|  frame[ra] = gp->val;
  571|  1.90G|END_LIBRARY_FUNC
  572|       |
  573|   [0;35m368k[0m|LIBRARY_FUNC_D(GSET)
  574|   368k|  symbol *gp = (symbol *)(const_table[rd] - SYMBOL_TAG);
  575|   368k|  gp->val = frame[ra];
  576|   368k|END_LIBRARY_FUNC
  577|       |
  578|  [0;35m92.9M[0m|LIBRARY_FUNC_D(KFUNC)
  579|  92.9M|  frame[ra] = (long)funcs[rd];
  580|  92.9M|END_LIBRARY_FUNC
  581|       |
  582|  [0;35m2.04G[0m|LIBRARY_FUNC_D(KONST)
  583|  2.04G|  frame[ra] = const_table[rd];
  584|  2.04G|END_LIBRARY_FUNC
  585|       |
  586|  [0;35m6.46G[0m|LIBRARY_FUNC_B_LOAD(MOV)
  587|  6.46G|  frame[ra] = fb;
  588|  6.46G|END_LIBRARY_FUNC
  589|       |
  590|  [0;35m15.2M[0m|LIBRARY_FUNC_B(BOX)
  591|  15.2M|  auto box = (cons_s *)GC_malloc(sizeof(cons_s));
  592|       |  
  593|  15.2M|  box->type = CONS_TAG;
  594|  15.2M|  box->a = frame[rb];
  595|  15.2M|  box->b = NIL_TAG;
  596|  15.2M|  frame[ra] = (long)box | CONS_TAG;
  597|  15.2M|END_LIBRARY_FUNC
  598|       |
  599|   [0;35m352M[0m|LIBRARY_FUNC_B_LOAD(UNBOX)
  600|   [0;35m352M[0m|  auto box = (cons_s *)(fb - CONS_TAG);
  601|   352M|  frame[ra] = box->a;
  602|   352M|END_LIBRARY_FUNC
  603|       |
  604|  [0;35m53.0M[0m|LIBRARY_FUNC_BC_LOAD_NAME(SET-BOX!, SET_BOX)
  605|  [0;35m53.0M[0m|  auto box = (cons_s *)(fb - CONS_TAG);
  606|  53.0M|  box->a = fc;
  607|  53.0M|END_LIBRARY_FUNC
  608|       |
  609|       |#define LIBRARY_FUNC_GUARD(name, iftrue, iffalse, finish)	             \
  610|   [0;35m227M[0m|  LIBRARY_FUNC_BC(name)				                             \
  611|   227M|  long fb = frame[rb];					                     \
  612|   227M|  								             \
  613|   [0;35m227M[0m|  if ((((TAG_MASK & rc) == LITERAL_TAG) && (rc == (fb & IMMEDIATE_MASK))) || \
  614|   [0;35m227M[0m|      (((fb & TAG_MASK) == PTR_TAG) && (*(long *)(fb - PTR_TAG) == rc)) || \
  615|   [0;35m227M[0m|      (((TAG_MASK & rc) != LITERAL_TAG) && ((fb & TAG_MASK) == rc))) {	\
  616|  77.4M|    iftrue;								     \
  617|   150M|  } else {								     \
  618|   150M|    iffalse;								     \
  619|   150M|  }									     \
  620|   227M|									     \
  621|   227M|  pc += (finish);							     \
  622|   [0;35m227M[0m|  NEXT_INSTR[0;41m;								     \[0m
  623|      0|[0;41m}[0m
  ------------------
  | [0;36mINS_GUARD:
[0m  |  610|  [0;35m4.63M[0m|  LIBRARY_FUNC_BC(name)				                             \
  |  611|  4.63M|  long fb = frame[rb];					                     \
  |  612|  4.63M|  								             \
  |  613|  [0;35m4.63M[0m|  if ((((TAG_MASK & rc) == LITERAL_TAG) && (rc == (fb & IMMEDIATE_MASK))) || \
  |  614|  [0;35m4.63M[0m|      (((fb & TAG_MASK) == PTR_TAG) && (*(long *)(fb - PTR_TAG) == rc)) || \
  |  615|  [0;35m4.63M[0m|      (((TAG_MASK & rc) != LITERAL_TAG) && ((fb & TAG_MASK) == rc))) {	\
  |  616|  1.69M|    iftrue;								     \
  |  617|  2.94M|  } else {								     \
  |  618|  2.94M|    iffalse;								     \
  |  619|  2.94M|  }									     \
  |  620|  4.63M|									     \
  |  621|  4.63M|  pc += (finish);							     \
  |  622|  [0;35m4.63M[0m|  NEXT_INSTR[0;41m;								     \[0m
  |  623|      0|[0;41m}[0m
  ------------------
  | [0;36mINS_JGUARD:
[0m  |  610|   [0;35m222M[0m|  LIBRARY_FUNC_BC(name)				                             \
  |  611|   222M|  long fb = frame[rb];					                     \
  |  612|   222M|  								             \
  |  613|   [0;35m222M[0m|  if ((((TAG_MASK & rc) == LITERAL_TAG) && (rc == (fb & IMMEDIATE_MASK))) || \
  |  614|   [0;35m222M[0m|      (((fb & TAG_MASK) == PTR_TAG) && (*(long *)(fb - PTR_TAG) == rc)) || \
  |  615|   [0;35m222M[0m|      (((TAG_MASK & rc) != LITERAL_TAG) && ((fb & TAG_MASK) == rc))) {	\
  |  616|  75.0M|    iftrue;								     \
  |  617|   147M|  } else {								     \
  |  618|   147M|    iffalse;								     \
  |  619|   147M|  }									     \
  |  620|   222M|									     \
  |  621|   222M|  pc += (finish);							     \
  |  622|   [0;35m222M[0m|  NEXT_INSTR[0;41m;								     \[0m
  |  623|      0|[0;41m}[0m
  ------------------
  | [0;36mINS_JNGUARD:
[0m  |  610|   [0;35m972k[0m|  LIBRARY_FUNC_BC(name)				                             \
  |  611|   972k|  long fb = frame[rb];					                     \
  |  612|   972k|  								             \
  |  613|   [0;35m972k[0m|  if ((((TAG_MASK & rc) == LITERAL_TAG) && (rc == (fb & IMMEDIATE_MASK))) || \
  |  614|   [0;35m972k[0m|      (((fb & TAG_MASK) == PTR_TAG) && (*(long *)(fb - PTR_TAG) == rc)) || \
  |  615|   [0;35m972k[0m|      (((TAG_MASK & rc) != LITERAL_TAG) && ((fb & TAG_MASK) == rc))) {	\
  |  616|   746k|    iftrue;								     \
  |  617|   746k|  } else {								     \
  |  618|   226k|    iffalse;								     \
  |  619|   226k|  }									     \
  |  620|   972k|									     \
  |  621|   972k|  pc += (finish);							     \
  |  622|   [0;35m972k[0m|  NEXT_INSTR[0;41m;								     \[0m
  |  623|      0|[0;41m}[0m
  ------------------
  624|       |
  625|       |LIBRARY_FUNC_GUARD(GUARD, frame[ra] = TRUE_REP, frame[ra] = FALSE_REP, 1);
  626|       |LIBRARY_FUNC_GUARD(JGUARD, pc += 2, pc += INS_D(*(pc+1)) + 1, 0);
  627|       |LIBRARY_FUNC_GUARD(JNGUARD, pc += INS_D(*(pc+1)) + 1, pc += 2, 0);
  628|       |
  629|  [0;35m6.40M[0m|LIBRARY_FUNC_B(VECTOR)
  630|  6.40M|  auto closure = (closure_s *)GC_malloc(sizeof(long) * (rb + 2));
  631|  6.40M|  closure->type = VECTOR_TAG;
  632|  6.40M|  closure->len = rb << 3;
  633|  [0;35m30.8M[0m|  for (int i = 0; i < rb; i++) {
  634|  24.4M|    closure->v[i] = frame[ra + i];
  635|  24.4M|  }
  636|  6.40M|  frame[ra] = (long)closure | PTR_TAG;
  637|  6.40M|END_LIBRARY_FUNC
  638|       |
  639|  [0;35m92.9M[0m|LIBRARY_FUNC_B(CLOSURE)
  640|  92.9M|  auto cnt = (frame[ra+1] >> 3)+1; // TODO make this inline
  641|       |  // free vars + type + len + function ptr
  642|  92.9M|  auto closure = (closure_s *)GC_malloc(sizeof(long) * (cnt + 2));
  643|  92.9M|  closure->type = CLOSURE_TAG;
  644|  92.9M|  closure->len = cnt << 3;
  645|   [0;35m519M[0m|  for (int i = 0; i < cnt; i++) {
  646|   426M|    closure->v[i] = 0;//frame[ra + i];
  647|   426M|  }
  648|  92.9M|closure->v[0] = frame[ra];
  649|       |  // Record polymorphic
  650|  92.9M|  auto fun = (bcfunc*)frame[ra];
  651|  [0;35m92.9M[0m|  if(fun->poly_cnt < 50) {
  652|   381k|    fun->poly_cnt++;
  653|       |    /* if (fun->poly_cnt == 50) { */
  654|       |    /*   printf("Polymorphic func: %s\n", fun->name); */
  655|       |    /* } */
  656|   381k|  }
  657|  92.9M|  frame[ra] = (long)closure | CLOSURE_TAG;
  658|  92.9M|END_LIBRARY_FUNC
  659|       |
  660|  [0;35m3.49G[0m|LIBRARY_FUNC_BC_NAME(CLOSURE-GET, CLOSURE_GET)
  661|  3.49G|  auto fb = frame[rb];
  662|       |//TYPECHECK_TAG(fb, CLOSURE_TAG);
  663|  [0;35m3.49G[0m|  auto closure = (closure_s *)(fb - CLOSURE_TAG);
  664|  3.49G|  frame[ra] = closure->v[1 + rc];
  665|  3.49G|END_LIBRARY_FUNC
  666|       |
  667|   [0;35m327M[0m|LIBRARY_FUNC_BC_NAME(CLOSURE-SET, CLOSURE_SET)
  668|   327M|  auto fa = frame[ra];
  669|       |  // No need to typecheck, that would be bad bytecode.
  670|   [0;35m327M[0m|  auto closure = (closure_s *)(fa - CLOSURE_TAG);
  671|   327M|  closure->v[1 + rc] = frame[rb];
  672|   327M|END_LIBRARY_FUNC
  673|       |
  674|      [0;35m0[0m|[0;41mLIBRARY_FUNC_B_LOAD_NAME[0m[0;41m(CLOSURE-PTR, CLOSURE_PTR)[0m
  675|      [0;35m0[0m|[0;41m  [0m[0;41mTYPECHECK_TAG[0m[0;41m(fb, CLOSURE_TAG)[0m[0;41m;[0m
  676|      [0;35m0[0m|[0;41m  [0m[0;41mauto[0m[0;41m closure = (closure_s *)(fb - [0m[0;41mCLOSURE_TAG[0m[0;41m);[0m
  677|      0|[0;41m  frame[ra] = closure->v[0];[0m
  678|      0|[0;41m[0m[0;41mEND_LIBRARY_FUNC[0m
  679|       |
  680|  [0;35m1.72M[0m|LIBRARY_FUNC_BC_LOAD(APPLY)
  681|  [0;35m1.72M[0m|  if (unlikely((fb & 0x7) != CLOSURE_TAG)) [0;41m{[0m
  682|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);[0m
  683|      0|[0;41m  }[0m
  684|       |  // TODO check type NIL
  685|       |  
  686|  1.72M|  long a = 0;
  687|  [0;35m12.0M[0m|  for (; (fc & TAG_MASK) == CONS_TAG; a++) {
  688|  [0;35m10.2M[0m|    auto cons = (cons_s *)(fc - CONS_TAG);
  689|  10.2M|    frame[a + 1] = cons->a;
  690|  10.2M|    fc = cons->b;
  691|  10.2M|  }
  692|  1.72M|  frame[0] = fb;
  693|  [0;35m1.72M[0m|  auto clo = (closure_s *)(fb - CLOSURE_TAG);
  694|  1.72M|  auto func = (bcfunc *)clo->v[0];
  695|  1.72M|  pc = &func->code[0];
  696|  1.72M|  argcnt = a + 1;
  697|       |  
  698|  [0;35m1.72M[0m|  NEXT_INSTR[0;41m;[0m
  699|      0|[0;41m}[0m
  700|       |
  701|       |#ifdef PROFILER
  702|       |bool in_jit = false;
  703|       |#endif
  704|       |
  705|  [0;35m1.36G[0m|LIBRARY_FUNC_D(JFUNC)
  706|       |  // auto tnum = instr;
  707|       |  //  printf("JFUNC/JLOOP run %i\n", rd);
  708|       |//  printf("frame before %i %li %li \n", frame-stack, frame[0], frame[1]);
  709|  1.36G|#if defined(JIT)
  710|  1.36G|auto trace = trace_cache_get(rd);
  711|  [0;35m1.36G[0m|if (INS_OP(trace->startpc) == CLFUNC) {
  712|  [0;35m4.66M[0m|  if (argcnt != INS_A(trace->startpc)) {
  713|   747k|    pc += INS_D(*(pc + 1)) + 1;
  714|   747k|    goto out;
  715|   747k|  }
  716|  4.66M| }
  717|  [0;35m1.36G[0m|if (INS_OP(trace->startpc) == CLFUNCV) {
  718|   [0;35m715k[0m|  if (argcnt < INS_A(trace->startpc)) [0;41m{[0m
  719|      0|[0;41m    pc += [0m[0;41mINS_D[0m[0;41m(*(pc + 1)) + 1;[0m
  720|      0|[0;41m    goto out;[0m
  721|      0|[0;41m  }[0m
  722|   715k| }
  723|  [0;35m1.36G[0m|if (INS_OP(trace->startpc) == FUNCV) {
  724|   617k|    frame[ra] = build_list(ra, argcnt - ra, frame);
  725|   617k|}
  726|  [0;35m1.36G[0m|if (INS_OP(trace->startpc) == CLFUNCV) {
  727|   715k|    frame[ra] = build_list(ra, argcnt - ra, frame);
  728|   715k|}
  729|  1.36G|#ifdef PROFILER
  730|  1.36G|in_jit = true;
  731|  1.36G|#endif
  732|  1.36G|auto res = jit_run(rd, &pc, &frame, &argcnt);
  733|  1.36G|#ifdef PROFILER
  734|  1.36G|in_jit = false;
  735|  1.36G|#endif
  736|       |#else
  737|       |auto res = 0;
  738|       |#endif
  739|       |
  740|  1.36G|  frame_top = stack + stacksz - 256;
  741|       |  // printf("frame after %i %li %li \n", frame-stack, frame[0], frame[1]);
  742|  [0;35m1.36G[0m|  if (unlikely(res)) {
  743|       |    // Turn on recording again
  744|  12.2k|    op_table_arg = (void **)l_op_table_record;
  745|  12.2k|  }
  746|  1.36G|out:
  747|  [0;35m1.36G[0m|  NEXT_INSTR[0;41m;[0m
  748|      0|[0;41m}[0m
  749|       |
  750|       |#define LIBRARY_FUNC_COPY(name, copied)
  751|       |LIBRARY_FUNC_COPY(JLOOP, JFUNC);
  752|    167|#define INS_JLOOP INS_JFUNC
  753|       |
  754|  [0;35m2.47G[0m|LIBRARY_FUNC_B(CALL)
  755|  2.47G|  auto cl = frame[ra+1];
  756|  [0;35m2.47G[0m|  TYPECHECK_TAG(cl, CLOSURE_TAG);
  757|  [0;35m2.47G[0m|  auto closure = (closure_s *)(cl - CLOSURE_TAG);
  758|       |
  759|  2.47G|  bcfunc *func = (bcfunc *)closure->v[0];
  760|  2.47G|  auto old_pc = pc;
  761|  2.47G|  pc = &func->code[0];
  762|  2.47G|  frame[ra] = (long)(old_pc + 1);
  763|  2.47G|  frame += ra + 1;
  764|  2.47G|  argcnt = rb - 1;
  765|  [0;35m2.47G[0m|  if (unlikely((frame + 256) > frame_top)) [0;41m{[0m
  766|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return EXPAND_STACK_SLOWPATH([0m[0;41mARGS[0m[0;41m);[0m
  767|      0|[0;41m  }[0m
  768|  [0;35m2.47G[0m|  NEXT_INSTR[0;41m;[0m
  769|      0|[0;41m}[0m
  770|       |
  771|   [0;35m522M[0m|LIBRARY_FUNC_B(CALLT)
  772|   522M|  auto cl = frame[ra+1];
  773|   [0;35m522M[0m|  TYPECHECK_TAG(cl, CLOSURE_TAG);
  774|   [0;35m522M[0m|  auto closure = (closure_s *)(cl - CLOSURE_TAG);
  775|       |
  776|   522M|  bcfunc *func = (bcfunc *)closure->v[0];
  777|   522M|  pc = &func->code[0];
  778|       |  
  779|   522M|  long start = ra + 1;
  780|   522M|  argcnt = rb - 1;
  781|  [0;35m1.90G[0m|  for (auto i = 0; i < argcnt; i++) {
  782|  1.37G|    frame[i] = frame[start + i];
  783|  1.37G|  }
  784|       |  // No need to stack size check for tailcalls since we reuse the frame.
  785|       |  
  786|   [0;35m522M[0m|  NEXT_INSTR[0;41m;[0m
  787|      0|[0;41m}[0m
  788|       |
  789|       |#define LIBRARY_FUNC_EQV(name, name2, iftrue, iffalse, finish)	\
  790|  [0;35m76.0M[0m|  LIBRARY_FUNC_BC_LOAD_NAME(name, name2)					\
  791|  [0;35m76.0M[0m|  if (fb == fc) {					\
  792|  2.53M|    iftrue;							 \
  793|  [0;35m73.5M[0m|  } else if (((7 & fb) == (7 & fc)) && ((7 & fc) == 2)) {        \
  794|  [0;35m1.05k[0m|  auto x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;	\
  795|  [0;35m1.05k[0m|  auto x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;	\
  796|  [0;35m1.05k[0m|  if (x_b == x_c) {					\
  797|     80|    iftrue;						\
  798|    975|   } else {						\
  799|    975|    iffalse;						\
  800|    975|   }							\
  801|  73.4M|  } else {						\
  802|  73.4M|    iffalse;						\
  803|  73.4M|  }							\
  804|  76.0M|							\
  805|  76.0M|  pc += (finish);						\
  806|  [0;35m76.0M[0m|  NEXT_INSTR[0;41m;						\[0m
  807|      0|[0;41m}[0m
  ------------------
  | [0;36mINS_EQV:
[0m  |  790|  [0;35m1.60k[0m|  LIBRARY_FUNC_BC_LOAD_NAME(name, name2)					\
  |  791|  [0;35m1.60k[0m|  if (fb == fc) {					\
  |  792|  1.22k|    iftrue;							 \
  |  793|  [0;35m1.22k[0m|  } else if (((7 & fb) == (7 & fc)) && ((7 & fc) == 2)) [0;41m{        \[0m
  |  794|      [0;35m0[0m|[0;41m  [0m[0;41mauto[0m[0;41m x_b = ((flonum_s *)(fb - [0m[0;41mFLONUM_TAG[0m[0;41m))->x;	\[0m
  |  795|      [0;35m0[0m|[0;41m  [0m[0;41mauto[0m[0;41m x_c = ((flonum_s *)(fc - [0m[0;41mFLONUM_TAG[0m[0;41m))->x;	\[0m
  |  796|      [0;35m0[0m|[0;41m  if ([0m[0;41mx_b == x_c[0m[0;41m) [0m[0;41m{					\[0m
  |  797|      0|[0;41m    iftrue;						\[0m
  |  798|      0|[0;41m   }[0m[0;41m else [0m[0;41m{						\[0m
  |  799|      0|[0;41m    iffalse;						\[0m
  |  800|      0|[0;41m   }[0m[0;41m							\[0m
  |  801|    378|[0;41m  }[0m else {						\
  |  802|    378|    iffalse;						\
  |  803|    378|  }							\
  |  804|  1.60k|							\
  |  805|  1.60k|  pc += (finish);						\
  |  806|  [0;35m1.60k[0m|  NEXT_INSTR[0;41m;						\[0m
  |  807|      0|[0;41m}[0m
  ------------------
  | [0;36mINS_JEQV:
[0m  |  790|  [0;35m74.1M[0m|  LIBRARY_FUNC_BC_LOAD_NAME(name, name2)					\
  |  791|  [0;35m74.1M[0m|  if (fb == fc) {					\
  |  792|  2.49M|    iftrue;							 \
  |  793|  [0;35m71.6M[0m|  } else if (((7 & fb) == (7 & fc)) && ((7 & fc) == 2)) {        \
  |  794|  [0;35m1.05k[0m|  auto x_b = ((flonum_s *)(fb - FLONUM_TAG))->x;	\
  |  795|  [0;35m1.05k[0m|  auto x_c = ((flonum_s *)(fc - FLONUM_TAG))->x;	\
  |  796|  [0;35m1.05k[0m|  if (x_b == x_c) {					\
  |  797|     80|    iftrue;						\
  |  798|    975|   } else {						\
  |  799|    975|    iffalse;						\
  |  800|    975|   }							\
  |  801|  71.6M|  } else {						\
  |  802|  71.6M|    iffalse;						\
  |  803|  71.6M|  }							\
  |  804|  74.1M|							\
  |  805|  74.1M|  pc += (finish);						\
  |  806|  [0;35m74.1M[0m|  NEXT_INSTR[0;41m;						\[0m
  |  807|      0|[0;41m}[0m
  ------------------
  | [0;36mINS_JNEQV:
[0m  |  790|  [0;35m1.92M[0m|  LIBRARY_FUNC_BC_LOAD_NAME(name, name2)					\
  |  791|  [0;35m1.92M[0m|  if (fb == fc) {					\
  |  792|  33.0k|    iftrue;							 \
  |  793|  [0;35m1.89M[0m|  } else if (((7 & fb) == (7 & fc)) && ((7 & fc) == 2)) [0;41m{        \[0m
  |  794|      [0;35m0[0m|[0;41m  [0m[0;41mauto[0m[0;41m x_b = ((flonum_s *)(fb - [0m[0;41mFLONUM_TAG[0m[0;41m))->x;	\[0m
  |  795|      [0;35m0[0m|[0;41m  [0m[0;41mauto[0m[0;41m x_c = ((flonum_s *)(fc - [0m[0;41mFLONUM_TAG[0m[0;41m))->x;	\[0m
  |  796|      [0;35m0[0m|[0;41m  if ([0m[0;41mx_b == x_c[0m[0;41m) [0m[0;41m{					\[0m
  |  797|      0|[0;41m    iftrue;						\[0m
  |  798|      0|[0;41m   }[0m[0;41m else [0m[0;41m{						\[0m
  |  799|      0|[0;41m    iffalse;						\[0m
  |  800|      0|[0;41m   }[0m[0;41m							\[0m
  |  801|  1.89M|[0;41m  }[0m else {						\
  |  802|  1.89M|    iffalse;						\
  |  803|  1.89M|  }							\
  |  804|  1.92M|							\
  |  805|  1.92M|  pc += (finish);						\
  |  806|  [0;35m1.92M[0m|  NEXT_INSTR[0;41m;						\[0m
  |  807|      0|[0;41m}[0m
  ------------------
  808|       |
  809|       |LIBRARY_FUNC_EQV(EQV?, EQV, frame[ra] = TRUE_REP, frame[ra] = FALSE_REP, 1);
  810|       |LIBRARY_FUNC_EQV(JEQV, JEQV, pc += 2, pc += INS_D(*(pc+1)) + 1, 0);
  811|       |LIBRARY_FUNC_EQV(JNEQV, JNEQV, pc += INS_D(*(pc+1)) + 1, pc += 2, 0);
  812|       |
  813|  [0;35m58.1M[0m|LIBRARY_FUNC_BC(CONS)
  814|  58.1M|  auto c = (cons_s *)GC_malloc(sizeof(cons_s));
  815|       |  
  816|  58.1M|  c->type = CONS_TAG;
  817|  58.1M|  c->a = frame[rb];
  818|  58.1M|  c->b = frame[rc];
  819|       |  
  820|  58.1M|  frame[ra] = (long)c | CONS_TAG;
  821|  58.1M|END_LIBRARY_FUNC
  822|       |
  823|       |#define LIBRARY_FUNC_CONS_OP(name, field)                                      \
  824|   [0;35m284M[0m|  LIBRARY_FUNC_B_LOAD(name)                                                    \
  825|   [0;35m284M[0m|  TYPECHECK_TAG(fb, CONS_TAG);                                                 \
  826|   [0;35m284M[0m|  auto c = (cons_s *)(fb - CONS_TAG);                                          \
  827|   284M|  frame[ra] = c->field;                                                        \
  828|   284M|  END_LIBRARY_FUNC
  ------------------
  | [0;36mINS_CAR:
[0m  |  824|   [0;35m143M[0m|  LIBRARY_FUNC_B_LOAD(name)                                                    \
  |  825|   [0;35m143M[0m|  TYPECHECK_TAG(fb, CONS_TAG);                                                 \
  |  826|   [0;35m143M[0m|  auto c = (cons_s *)(fb - CONS_TAG);                                          \
  |  827|   143M|  frame[ra] = c->field;                                                        \
  |  828|   143M|  END_LIBRARY_FUNC
  ------------------
  | [0;36mINS_CDR:
[0m  |  824|   [0;35m141M[0m|  LIBRARY_FUNC_B_LOAD(name)                                                    \
  |  825|   [0;35m141M[0m|  TYPECHECK_TAG(fb, CONS_TAG);                                                 \
  |  826|   [0;35m141M[0m|  auto c = (cons_s *)(fb - CONS_TAG);                                          \
  |  827|   141M|  frame[ra] = c->field;                                                        \
  |  828|   141M|  END_LIBRARY_FUNC
  ------------------
  829|       |
  830|       |LIBRARY_FUNC_CONS_OP(CAR, a);
  831|       |LIBRARY_FUNC_CONS_OP(CDR, b);
  832|       |
  833|  20.3M|void vm_make_vector(long vec, long val) {
  834|  20.3M|  vector_s*v = (vector_s*)(vec & ~TAG_MASK);
  835|       |
  836|  20.3M|  long len = v->len >> 3;
  837|  20.3M|  long *p = &v->v[0];
  838|  20.3M|  long *end = &v->v[len];
  839|  [0;35m1.17G[0m|  for(; p < end; p++) {
  840|  1.15G|    *p = val;
  841|  1.15G|  }
  842|  20.3M|}
  843|       |
  844|  [0;35m5.19k[0m|LIBRARY_FUNC_BC_NAME(MAKE-VECTOR, MAKE_VECTOR)
  845|  5.19k|  long fb = frame[rb];
  846|  [0;35m5.19k[0m|  TYPECHECK_FIXNUM(fb);
  847|       |  
  848|  5.19k|  auto len = fb >> 3;
  849|  5.19k|  auto vec = (vector_s *)GC_malloc(sizeof(long) * (len + 2));
  850|       |  // Load frame[rc] *after* GC
  851|  5.19k|  long fc = frame[rc];
  852|  5.19k|  vec->type = VECTOR_TAG;
  853|  5.19k|  vec->len = fb;
  854|  [0;35m33.1M[0m|  for (long i = 0; i < len; i++) {
  855|  33.1M|    vec->v[i] = fc;
  856|  33.1M|  }
  857|       |  
  858|  5.19k|  frame[ra] = (long)vec | PTR_TAG;
  859|  5.19k|END_LIBRARY_FUNC
  860|       |
  861|  29.3M|void vm_make_string(long str, long ch) {
  862|  29.3M|  string_s*s = (string_s*)(str & ~TAG_MASK);
  863|  29.3M|  char c = ch >> 8;
  864|       |
  865|  29.3M|  long len = s->len >> 3;
  866|  29.3M|  memset(&s->str[0], c, len);
  867|  29.3M|  s->str[len] = '\0';
  868|  29.3M|}
  869|       |
  870|       |// TODO could be BC_LOAD_NAME?
  871|   [0;35m486k[0m|LIBRARY_FUNC_BC_NAME(MAKE-STRING, MAKE_STRING)
  872|   486k|  long fb = frame[rb];
  873|   [0;35m486k[0m|  TYPECHECK_FIXNUM(fb);
  874|   486k|  auto len = fb >> 3;
  875|   486k|  auto str = (string_s *)GC_malloc((sizeof(long) * 2) + len + 1);
  876|       |  
  877|   486k|  long fc = frame[rc]; // Load fc after GC
  878|   [0;35m486k[0m|  TYPECHECK_IMMEDIATE(fc, CHAR_TAG);
  879|       |  
  880|   486k|  str->type = STRING_TAG;
  881|   486k|  str->len = fb;
  882|  [0;35m10.7M[0m|  for (long i = 0; i < len; i++) {
  883|  10.2M|    str->str[i] = (char)((fc >> 8) & 0xff);
  884|  10.2M|  }
  885|   486k|  str->str[len] = '\0';
  886|       |  
  887|   486k|  frame[ra] = (long)str | PTR_TAG;
  888|   486k|END_LIBRARY_FUNC
  889|       |
  890|  [0;35m1.82G[0m|LIBRARY_FUNC_BC_LOAD_NAME(VECTOR-REF, VECTOR_REF)
  891|  [0;35m1.82G[0m|  TYPECHECK_FIXNUM(fc);
  892|  [0;35m1.82G[0m|  LOAD_TYPE_WITH_CHECK(vec, vector_s, fb, VECTOR_TAG);
  893|  1.82G|  long pos = fc >> 3;
  894|  [0;35m1.82G[0m|  if ((long)(vec->len >> 3) - pos < 0) [0;41m{[0m
  895|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);[0m
  896|      0|[0;41m  }[0m
  897|  1.82G|  frame[ra] = vec->v[pos];
  898|  1.82G|END_LIBRARY_FUNC
  899|       |
  900|  [0;35m53.3M[0m|LIBRARY_FUNC_BC_LOAD_NAME(STRING-REF, STRING_REF)
  901|  [0;35m53.3M[0m|  TYPECHECK_FIXNUM(fc);
  902|  [0;35m53.3M[0m|  LOAD_TYPE_WITH_CHECK(str, string_s, fb, STRING_TAG);
  903|  53.3M|  long pos = fc >> 3;
  904|  [0;35m53.3M[0m|  if ((long)(str->len >> 3) - pos < 0) [0;41m{[0m
  905|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);[0m
  906|      0|[0;41m  }[0m
  907|  [0;35m53.3M[0m|  frame[ra] = (str->str[pos] << 8) | CHAR_TAG;
  908|  53.3M|END_LIBRARY_FUNC
  909|       |
  910|  [0;35m13.2M[0m|LIBRARY_FUNC_B_LOAD_NAME(VECTOR-LENGTH, VECTOR_LENGTH)
  911|  [0;35m13.2M[0m|  LOAD_TYPE_WITH_CHECK(vec, vector_s, fb, VECTOR_TAG);
  912|  13.2M|  frame[ra] = (long)(vec->len);
  913|  13.2M|END_LIBRARY_FUNC
  914|       |
  915|  [0;35m1.59M[0m|LIBRARY_FUNC_B_LOAD_NAME(STRING-LENGTH, STRING_LENGTH)
  916|  [0;35m1.59M[0m|  LOAD_TYPE_WITH_CHECK(str, string_s, fb, STRING_TAG);
  917|  1.59M|  frame[ra] = (long)(str->len);
  918|  1.59M|END_LIBRARY_FUNC
  919|       |
  920|   [0;35m327M[0m|LIBRARY_FUNC_BC_LOAD_NAME(VECTOR-SET!, VECTOR_SET)
  921|   327M|  auto fa = frame[ra];
  922|   [0;35m327M[0m|  TYPECHECK_FIXNUM(fb);
  923|   [0;35m327M[0m|  LOAD_TYPE_WITH_CHECK(vec, vector_s, fa, VECTOR_TAG);
  924|   327M|  long pos = fb >> 3;
  925|   [0;35m327M[0m|  if ((long)(vec->len >> 3) - pos <= 0) [0;41m{[0m
  926|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);[0m
  927|      0|[0;41m  }[0m
  928|   327M|  vec->v[pos] = fc;
  929|   327M|END_LIBRARY_FUNC
  930|       |
  931|  [0;35m2.95M[0m|LIBRARY_FUNC_BC_LOAD_NAME(STRING-SET!, STRING_SET)
  932|  2.95M|  auto fa = frame[ra];
  933|  [0;35m2.95M[0m|  TYPECHECK_FIXNUM(fb);
  934|  [0;35m2.95M[0m|  TYPECHECK_IMMEDIATE(fc, CHAR_TAG);
  935|  [0;35m2.95M[0m|  LOAD_TYPE_WITH_CHECK(str, string_s, fa, STRING_TAG);
  936|  2.95M|  long pos = fb >> 3;
  937|  [0;35m2.95M[0m|  if ((long)(str->len >> 3) - pos <= 0) [0;41m{[0m
  938|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);[0m
  939|      0|[0;41m  }[0m
  940|  2.95M|  str->str[pos] = (char)((fc >> 8) & 0xff);
  941|  2.95M|END_LIBRARY_FUNC
  942|       |
  943|       |#define LIBRARY_FUNC_CONS_SET_OP(str, name, field)                             \
  944|  [0;35m22.2k[0m|  LIBRARY_FUNC_B_LOAD_NAME(str, name)                                          \
  945|  22.2k|  auto fa = frame[ra];                                                         \
  946|  [0;35m22.2k[0m|  TYPECHECK_TAG(fa, CONS_TAG);                                                 \
  947|  [0;35m22.2k[0m|  auto cons = (cons_s *)(fa - CONS_TAG);                                       \
  948|  22.2k|  cons->field = fb;                                                            \
  949|  22.2k|  END_LIBRARY_FUNC
  ------------------
  | [0;36mINS_SET_CAR:
[0m  |  944|  [0;35m4.47k[0m|  LIBRARY_FUNC_B_LOAD_NAME(str, name)                                          \
  |  945|  4.47k|  auto fa = frame[ra];                                                         \
  |  946|  [0;35m4.47k[0m|  TYPECHECK_TAG(fa, CONS_TAG);                                                 \
  |  947|  [0;35m4.47k[0m|  auto cons = (cons_s *)(fa - CONS_TAG);                                       \
  |  948|  4.47k|  cons->field = fb;                                                            \
  |  949|  4.47k|  END_LIBRARY_FUNC
  ------------------
  | [0;36mINS_SET_CDR:
[0m  |  944|  [0;35m17.7k[0m|  LIBRARY_FUNC_B_LOAD_NAME(str, name)                                          \
  |  945|  17.7k|  auto fa = frame[ra];                                                         \
  |  946|  [0;35m17.7k[0m|  TYPECHECK_TAG(fa, CONS_TAG);                                                 \
  |  947|  [0;35m17.7k[0m|  auto cons = (cons_s *)(fa - CONS_TAG);                                       \
  |  948|  17.7k|  cons->field = fb;                                                            \
  |  949|  17.7k|  END_LIBRARY_FUNC
  ------------------
  950|       |
  951|       |LIBRARY_FUNC_CONS_SET_OP(SET-CAR!, SET_CAR, a);
  952|       |LIBRARY_FUNC_CONS_SET_OP(SET-CDR!, SET_CDR, b);
  953|       |
  954|       |// Called from jit. TODO could inline in jit.
  955|   228M|void vm_write(long obj, long port_obj) {
  956|   [0;35m228M[0m|  auto port = (port_s*)(port_obj - PTR_TAG);
  957|   228M|  print_obj(obj, port->file);
  958|   228M|}
  959|       |
  960|  [0;35m2.85k[0m|LIBRARY_FUNC_BC_LOAD(WRITE)
  961|  [0;35m2.85k[0m|  LOAD_TYPE_WITH_CHECK(port, port_s, fc, PORT_TAG);
  962|  2.85k|  print_obj(fb, port->file);
  963|  2.85k|END_LIBRARY_FUNC
  964|       |
  965|  [0;35m1.01M[0m|LIBRARY_FUNC_BC_LOAD_NAME(WRITE-U8, WRITE_U8)
  966|  [0;35m1.01M[0m|  LOAD_TYPE_WITH_CHECK(port, port_s, fc, PORT_TAG);
  967|  [0;35m1.01M[0m|  TYPECHECK_FIXNUM(fb);
  968|  1.01M|  long byte = fb >> 3;
  969|  1.01M|  unsigned char b = byte;
  970|  [0;35m1.01M[0m|  if (unlikely(byte >= 256)) [0;41m{[0m
  971|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);[0m
  972|      0|[0;41m  }[0m
  973|       |
  974|  1.01M|  fputc(b, port->file);
  975|  1.01M|END_LIBRARY_FUNC
  976|       |
  977|  [0;35m6.84k[0m|LIBRARY_FUNC_BC_LOAD_NAME(WRITE-DOUBLE, WRITE_DOUBLE)
  978|  [0;35m6.84k[0m|  LOAD_TYPE_WITH_CHECK(port, port_s, fc, PORT_TAG);
  979|  [0;35m6.84k[0m|  TYPECHECK_TAG(fb, FLONUM_TAG);
  980|  [0;35m6.84k[0m|  auto flo = (flonum_s *)(fb - FLONUM_TAG);
  981|       |  
  982|  6.84k|  fwrite(&flo->x, sizeof(flo->x), 1, port->file);
  983|  6.84k|END_LIBRARY_FUNC
  984|       |
  985|   [0;35m244k[0m|LIBRARY_FUNC_B_LOAD_NAME(SYMBOL->STRING, SYMBOL_STRING)
  986|   [0;35m244k[0m|  TYPECHECK_TAG(fb, SYMBOL_TAG);
  987|   [0;35m244k[0m|  auto sym = (symbol *)(fb - SYMBOL_TAG);
  988|   244k|  frame[ra] = sym->name;
  989|   244k|END_LIBRARY_FUNC
  990|       |
  991|  12.4M|long vm_string_symbol(string_s* str) {
  992|       |  // TODO jit still as the ptr tag.
  993|  12.4M|  str = (string_s*)((long)str & ~TAG_MASK);
  994|       |
  995|  12.4M|  auto res = symbol_table_find(str);
  996|  [0;35m12.4M[0m|  if (!res) {
  997|       |    // Build a new symbol.
  998|       |    // Must dup the string, since strings are not immutable.
  999|  1.68k|    auto strlen = str->len >> 3;
 1000|  1.68k|    auto sym = (symbol *)GC_malloc_no_collect(sizeof(symbol));
 1001|  [0;35m1.68k[0m|    if (!sym) [0;41m{[0m
 1002|      0|[0;41m      return [0m[0;41mFALSE_REP[0m[0;41m;[0m
 1003|      0|[0;41m    }[0m
 1004|  [0;35m1.68k[0m|    sym->type = SYMBOL_TAG;
 1005|  1.68k|    sym->name = (long)str + PTR_TAG;
 1006|  1.68k|    sym->val = UNDEFINED_TAG;
 1007|       |  
 1008|       |    // DUP the string, so that this one is immutable.
 1009|  1.68k|    auto str2 = (string_s *)GC_malloc_no_collect(16 + strlen + 1);
 1010|  [0;35m1.68k[0m|    if (!str2) [0;41m{[0m
 1011|      0|[0;41m      return [0m[0;41mFALSE_REP[0m[0;41m;[0m
 1012|      0|[0;41m    }[0m
 1013|       |  
 1014|  [0;35m1.68k[0m|    str2->type = STRING_TAG;
 1015|  1.68k|    str2->len = strlen << 3;
 1016|  1.68k|    memcpy(str2->str, str->str, strlen+1);
 1017|       |  
 1018|  1.68k|    sym->name = (long)str2 + PTR_TAG;
 1019|  1.68k|    symbol_table_insert(sym);
 1020|       |
 1021|  1.68k|    return (long)sym + SYMBOL_TAG;
 1022|  12.4M|  } else {
 1023|  12.4M|    return (long)res + SYMBOL_TAG;
 1024|  12.4M|  }
 1025|  12.4M|}
 1026|       |
 1027|   [0;35m258k[0m|LIBRARY_FUNC_B_LOAD_NAME(STRING->SYMBOL, STRING_SYMBOL)
 1028|   [0;35m258k[0m|  LOAD_TYPE_WITH_CHECK(str, string_s, fb, STRING_TAG);
 1029|   258k|  auto res = symbol_table_find(str);
 1030|   [0;35m258k[0m|  if (!res) {
 1031|       |    // Build a new symbol.
 1032|       |    // Must dup the string, since strings are not immutable.
 1033|  31.7k|    auto strlen = str->len >> 3;
 1034|  31.7k|    auto sym = (symbol *)GC_malloc(sizeof(symbol));
 1035|  31.7k|    sym->type = SYMBOL_TAG;
 1036|       |  
 1037|       |    // Note re-load of str after allocation.
 1038|  31.7k|    sym->name = frame[rb];
 1039|  31.7k|    sym->val = UNDEFINED_TAG;
 1040|       |  
 1041|       |    // Save new symbol in frame[ra].
 1042|  31.7k|    frame[ra] = (long)sym + SYMBOL_TAG;
 1043|       |  
 1044|       |    // DUP the string, so that this one is immutable.
 1045|       |    // Note that original is in sym->name temporarily
 1046|       |    // since ra could be eq to rb.
 1047|  31.7k|    auto str2 = (string_s *)GC_malloc(16 + strlen + 1);
 1048|       |    // Re-load sym after GC
 1049|  31.7k|    sym = (symbol *)(frame[ra] - SYMBOL_TAG);
 1050|       |  
 1051|       |    // Re-load str after GC
 1052|  31.7k|    str = (string_s *)(sym->name - PTR_TAG);
 1053|       |  
 1054|  31.7k|    str2->type = STRING_TAG;
 1055|  31.7k|    str2->len = strlen << 3;
 1056|  31.7k|    memcpy(str2->str, str->str, strlen+1);
 1057|       |  
 1058|  31.7k|    sym->name = (long)str2 + PTR_TAG;
 1059|  31.7k|    symbol_table_insert(sym);
 1060|   226k|  } else {
 1061|   226k|    frame[ra] = (long)res + SYMBOL_TAG;
 1062|   226k|  }
 1063|   258k|END_LIBRARY_FUNC
 1064|       |
 1065|  [0;35m43.4M[0m|LIBRARY_FUNC_B_LOAD_NAME(CHAR->INTEGER, CHAR_INTEGER)
 1066|  [0;35m43.4M[0m|  TYPECHECK_IMMEDIATE(fb, CHAR_TAG);
 1067|  43.4M|  frame[ra] = fb >> 5;
 1068|  43.4M|END_LIBRARY_FUNC
 1069|       |
 1070|  [0;35m4.18M[0m|LIBRARY_FUNC_B_LOAD_NAME(INTEGER->CHAR, INTEGER_CHAR)
 1071|  [0;35m4.18M[0m|  TYPECHECK_FIXNUM(fb);
 1072|  4.18M|  frame[ra] = (fb << 5) + CHAR_TAG;
 1073|  4.18M|END_LIBRARY_FUNC
 1074|       |
 1075|  [0;35m98.1k[0m|LIBRARY_FUNC_BC(OPEN)
 1076|  98.1k|  auto fc = frame[rc];
 1077|  [0;35m98.1k[0m|  TYPECHECK_IMMEDIATE(fc, BOOL_TAG);
 1078|       |  
 1079|  98.1k|  auto port = (port_s *)GC_malloc(sizeof(port_s));
 1080|       |  // Load FB (potentially a ptr) after GC
 1081|  98.1k|  auto fb = frame[rb];
 1082|       |  
 1083|  98.1k|  port->type = PORT_TAG;
 1084|  98.1k|  port->input_port = fc;
 1085|  98.1k|  port->eof = FALSE_REP;
 1086|       |  
 1087|  [0;35m98.1k[0m|  if ((fb & TAG_MASK) == FIXNUM_TAG) {
 1088|    168|    port->fd = frame[rb] >> 3;
 1089|  [0;35m97.9k[0m|  } else if ((fb & TAG_MASK) == PTR_TAG) {
 1090|  [0;35m97.9k[0m|    auto str = (string_s *)(fb - PTR_TAG);
 1091|  [0;35m97.9k[0m|    if (unlikely(str->type != STRING_TAG)) [0;41m{[0m
 1092|      [0;35m0[0m|[0;41m      [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);[0m
 1093|      0|[0;41m    }[0m
 1094|  97.9k|    port->fd = open(
 1095|  [0;35m97.9k[0m|        str->str, fc == TRUE_REP ? O_RDONLY : O_WRONLY | O_CREAT | O_TRUNC, 0777);
 1096|  [0;35m97.9k[0m|    if (port->fd == -1) [0;41m{[0m
 1097|      0|[0;41m      printf("Could not open fd for file %s\n", str->str);[0m
 1098|      0|[0;41m      exit(-1);[0m
 1099|      0|[0;41m    }[0m
 1100|  97.9k|  } else [0;41m{[0m
 1101|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);[0m
 1102|      0|[0;41m  }[0m
 1103|  [0;35m98.1k[0m|  port->file = fdopen((int)port->fd, fc == TRUE_REP ? "r" : "w");
 1104|  [0;35m98.1k[0m|  if (port->file == NULL) [0;41m{[0m
 1105|      0|[0;41m    printf("FDopen fail\n");[0m
 1106|      0|[0;41m    exit(-1);[0m
 1107|      0|[0;41m  }[0m
 1108|  [0;35m98.1k[0m|  frame[ra] = (long)port + PTR_TAG;
 1109|  98.1k|END_LIBRARY_FUNC
 1110|       |
 1111|  [0;35m97.4k[0m|LIBRARY_FUNC_B_LOAD(CLOSE)
 1112|  [0;35m97.4k[0m|  LOAD_TYPE_WITH_CHECK(port, port_s, fb, PORT_TAG);
 1113|  [0;35m97.4k[0m|  if (port->file) {
 1114|  97.4k|    fclose(port->file);
 1115|  97.4k|    port->file = NULL;
 1116|  97.4k|  }
 1117|  [0;35m97.4k[0m|  if (port->fd != -1) {
 1118|  97.4k|    close((int)port->fd);
 1119|  97.4k|    port->fd = -1;
 1120|  97.4k|  }
 1121|  97.4k|END_LIBRARY_FUNC
 1122|       |
 1123|   204M|__attribute__((always_inline)) long vm_peek_char(port_s* port) {
 1124|       |  // TODO jit still as the ptr tag.
 1125|   204M|  port = (port_s*)((long)port & ~TAG_MASK);
 1126|   204M|  int res = fgetc(port->file);
 1127|   [0;35m204M[0m|  if (res == EOF) {
 1128|  37.2k|    port->eof = TRUE_REP;
 1129|  37.2k|    return EOF_TAG;
 1130|   204M|  } else {
 1131|   204M|    ungetc(res, port->file);
 1132|   204M|    return (((long)res) << 8) + CHAR_TAG;
 1133|   204M|  }
 1134|   204M|}
 1135|       |
 1136|  [0;35m2.05M[0m|LIBRARY_FUNC_B_LOAD(PEEK)
 1137|  [0;35m2.05M[0m|  LOAD_TYPE_WITH_CHECK(port, port_s, fb, PORT_TAG);
 1138|  2.05M|  frame[ra] = vm_peek_char(port);
 1139|  2.05M|END_LIBRARY_FUNC
 1140|       |
 1141|   616M|__attribute__((always_inline)) long vm_read_char(port_s* port) {
 1142|       |  // TODO jit still as the ptr tag.
 1143|   616M|  port = (port_s*)((long)port & ~TAG_MASK);
 1144|   616M|  int res = fgetc(port->file);
 1145|   [0;35m616M[0m|  if (res == EOF) {
 1146|   140k|    port->eof = TRUE_REP;
 1147|   140k|    return EOF_TAG;
 1148|   616M|  } else {
 1149|   616M|    return (((long)res) << 8) + CHAR_TAG;
 1150|   616M|  }
 1151|   616M|}
 1152|       |
 1153|  [0;35m1.34M[0m|LIBRARY_FUNC_B_LOAD(READ)
 1154|  [0;35m1.34M[0m|  LOAD_TYPE_WITH_CHECK(port, port_s, fb, PORT_TAG);
 1155|  1.34M|  frame[ra] = vm_read_char(port);
 1156|  1.34M|END_LIBRARY_FUNC
 1157|       |
 1158|  [0;35m1.55M[0m|LIBRARY_FUNC_B_LOAD_NAME(READ-LINE, READ_LINE)
 1159|  [0;35m1.55M[0m|  LOAD_TYPE_WITH_CHECK(port, port_s, fb, PORT_TAG);
 1160|  1.55M|  size_t sz = 0;
 1161|  1.55M|  char *bufptr = NULL;
 1162|  1.55M|  auto pos = 0;
 1163|  1.55M|  ssize_t res = getline(&bufptr, &sz, port->file);
 1164|  [0;35m1.55M[0m|  if (res == -1) {
 1165|     50|    port->eof = TRUE_REP;
 1166|     50|    frame[ra] = EOF_TAG;
 1167|  1.55M|  } else {
 1168|  1.55M|   auto str = (string_s*)GC_malloc(res + 16);
 1169|  1.55M|   str->type = STRING_TAG;
 1170|  1.55M|   str->len = res << 3;
 1171|  1.55M|   memcpy(str->str, bufptr, res);
 1172|  1.55M|   str->str[res - 1] = '\0';
 1173|  1.55M|   frame[ra] = (long)str + PTR_TAG;
 1174|  1.55M| }
 1175|  1.55M| free(bufptr);
 1176|  1.55M|END_LIBRARY_FUNC
 1177|       |
 1178|  [0;35m31.4M[0m|LIBRARY_FUNC_B_LOAD(INEXACT)
 1179|  [0;35m31.4M[0m|  if ((fb & TAG_MASK) == FIXNUM_TAG) {
 1180|  20.7M|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));
 1181|  20.7M|    r->type = FLONUM_TAG;
 1182|  20.7M|    r->x = (double)(fb >> 3);
 1183|  20.7M|    frame[ra] = (long)r + FLONUM_TAG;
 1184|  [0;35m20.7M[0m|  } else if ((fb & TAG_MASK) == FLONUM_TAG) {
 1185|  10.7M|    frame[ra] = fb;
 1186|  10.7M|  } else [0;41m{[0m
 1187|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);[0m
 1188|      0|[0;41m  }[0m
 1189|  31.4M|END_LIBRARY_FUNC
 1190|       |
 1191|   [0;35m427k[0m|LIBRARY_FUNC_B_LOAD(EXACT)
 1192|   [0;35m427k[0m|  if ((fb & TAG_MASK) == FIXNUM_TAG) {
 1193|   427k|    frame[ra] = fb;
 1194|   [0;35m427k[0m|  } else if ((fb & TAG_MASK) == FLONUM_TAG) {
 1195|      [0;35m3[0m|    auto flo = (flonum_s *)(fb - FLONUM_TAG);
 1196|      3|    frame[ra] = ((long)flo->x) << 3;
 1197|      3|  } else [0;41m{[0m
 1198|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);[0m
 1199|      0|[0;41m  }[0m
 1200|   427k|END_LIBRARY_FUNC
 1201|       |
 1202|   [0;35m500k[0m|LIBRARY_FUNC_B_LOAD(ROUND)
 1203|   [0;35m500k[0m|  if ((fb & TAG_MASK) == FIXNUM_TAG) {
 1204|     51|    frame[ra] = fb;
 1205|   [0;35m500k[0m|  } else if ((fb & TAG_MASK) == FLONUM_TAG) {
 1206|   [0;35m500k[0m|    auto flo = (flonum_s *)(fb - FLONUM_TAG);
 1207|       |    //auto res = roundeven(flo->x);
 1208|   500k|    auto res = flo->x - remainder(flo->x, 1.0);
 1209|       |    //auto res = round(flo->x);
 1210|       |  
 1211|   500k|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));
 1212|   500k|    r->type = FLONUM_TAG;
 1213|   500k|    r->x = res;
 1214|   500k|    frame[ra] = (long)r + FLONUM_TAG;
 1215|   500k|  } else [0;41m{[0m
 1216|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);[0m
 1217|      0|[0;41m  }[0m
 1218|   500k|END_LIBRARY_FUNC
 1219|       |
 1220|       |#define LIBRARY_FUNC_FLONUM_MATH(name, func)                                   \
 1221|  [0;35m11.1M[0m|  LIBRARY_FUNC_B_LOAD(name)                                                    \
 1222|  [0;35m11.1M[0m|  if ((fb & TAG_MASK) == FLONUM_TAG) {                                         \
 1223|  [0;35m11.1M[0m|    auto flo = (flonum_s *)(fb - FLONUM_TAG);                                  \
 1224|  11.1M|    auto res = func(flo->x);                                                   \
 1225|  11.1M|                                                                               \
 1226|  11.1M|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));                          \
 1227|  11.1M|    r->type = FLONUM_TAG;                                                      \
 1228|  11.1M|    r->x = res;                                                                \
 1229|  11.1M|    frame[ra] = (long)r + FLONUM_TAG;                                          \
 1230|  11.1M|  } else [0;41m{                                                                     \[0m
 1231|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
 1232|      0|[0;41m  }[0m                                                                            \
 1233|  11.1M|  END_LIBRARY_FUNC
  ------------------
  | [0;36mINS_SIN:
[0m  | 1221|  [0;35m2.01M[0m|  LIBRARY_FUNC_B_LOAD(name)                                                    \
  | 1222|  [0;35m2.01M[0m|  if ((fb & TAG_MASK) == FLONUM_TAG) {                                         \
  | 1223|  [0;35m2.01M[0m|    auto flo = (flonum_s *)(fb - FLONUM_TAG);                                  \
  | 1224|  2.01M|    auto res = func(flo->x);                                                   \
  | 1225|  2.01M|                                                                               \
  | 1226|  2.01M|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));                          \
  | 1227|  2.01M|    r->type = FLONUM_TAG;                                                      \
  | 1228|  2.01M|    r->x = res;                                                                \
  | 1229|  2.01M|    frame[ra] = (long)r + FLONUM_TAG;                                          \
  | 1230|  2.01M|  } else [0;41m{                                                                     \[0m
  | 1231|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  | 1232|      0|[0;41m  }[0m                                                                            \
  | 1233|  2.01M|  END_LIBRARY_FUNC
  ------------------
  | [0;36mINS_SQRT:
[0m  | 1221|  [0;35m5.05M[0m|  LIBRARY_FUNC_B_LOAD(name)                                                    \
  | 1222|  [0;35m5.05M[0m|  if ((fb & TAG_MASK) == FLONUM_TAG) {                                         \
  | 1223|  [0;35m5.05M[0m|    auto flo = (flonum_s *)(fb - FLONUM_TAG);                                  \
  | 1224|  5.05M|    auto res = func(flo->x);                                                   \
  | 1225|  5.05M|                                                                               \
  | 1226|  5.05M|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));                          \
  | 1227|  5.05M|    r->type = FLONUM_TAG;                                                      \
  | 1228|  5.05M|    r->x = res;                                                                \
  | 1229|  5.05M|    frame[ra] = (long)r + FLONUM_TAG;                                          \
  | 1230|  5.05M|  } else [0;41m{                                                                     \[0m
  | 1231|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  | 1232|      0|[0;41m  }[0m                                                                            \
  | 1233|  5.05M|  END_LIBRARY_FUNC
  ------------------
  | [0;36mINS_ATAN:
[0m  | 1221|  [0;35m2.00M[0m|  LIBRARY_FUNC_B_LOAD(name)                                                    \
  | 1222|  [0;35m2.00M[0m|  if ((fb & TAG_MASK) == FLONUM_TAG) {                                         \
  | 1223|  [0;35m2.00M[0m|    auto flo = (flonum_s *)(fb - FLONUM_TAG);                                  \
  | 1224|  2.00M|    auto res = func(flo->x);                                                   \
  | 1225|  2.00M|                                                                               \
  | 1226|  2.00M|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));                          \
  | 1227|  2.00M|    r->type = FLONUM_TAG;                                                      \
  | 1228|  2.00M|    r->x = res;                                                                \
  | 1229|  2.00M|    frame[ra] = (long)r + FLONUM_TAG;                                          \
  | 1230|  2.00M|  } else [0;41m{                                                                     \[0m
  | 1231|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  | 1232|      0|[0;41m  }[0m                                                                            \
  | 1233|  2.00M|  END_LIBRARY_FUNC
  ------------------
  | [0;36mINS_COS:
[0m  | 1221|  [0;35m2.00M[0m|  LIBRARY_FUNC_B_LOAD(name)                                                    \
  | 1222|  [0;35m2.00M[0m|  if ((fb & TAG_MASK) == FLONUM_TAG) {                                         \
  | 1223|  [0;35m2.00M[0m|    auto flo = (flonum_s *)(fb - FLONUM_TAG);                                  \
  | 1224|  2.00M|    auto res = func(flo->x);                                                   \
  | 1225|  2.00M|                                                                               \
  | 1226|  2.00M|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));                          \
  | 1227|  2.00M|    r->type = FLONUM_TAG;                                                      \
  | 1228|  2.00M|    r->x = res;                                                                \
  | 1229|  2.00M|    frame[ra] = (long)r + FLONUM_TAG;                                          \
  | 1230|  2.00M|  } else [0;41m{                                                                     \[0m
  | 1231|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  | 1232|      0|[0;41m  }[0m                                                                            \
  | 1233|  2.00M|  END_LIBRARY_FUNC
  ------------------
  | [0;36mINS_TRUNCATE:
[0m  | 1221|  [0;35m30.0k[0m|  LIBRARY_FUNC_B_LOAD(name)                                                    \
  | 1222|  [0;35m30.0k[0m|  if ((fb & TAG_MASK) == FLONUM_TAG) {                                         \
  | 1223|  [0;35m30.0k[0m|    auto flo = (flonum_s *)(fb - FLONUM_TAG);                                  \
  | 1224|  30.0k|    auto res = func(flo->x);                                                   \
  | 1225|  30.0k|                                                                               \
  | 1226|  30.0k|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));                          \
  | 1227|  30.0k|    r->type = FLONUM_TAG;                                                      \
  | 1228|  30.0k|    r->x = res;                                                                \
  | 1229|  30.0k|    frame[ra] = (long)r + FLONUM_TAG;                                          \
  | 1230|  30.0k|  } else [0;41m{                                                                     \[0m
  | 1231|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  | 1232|      0|[0;41m  }[0m                                                                            \
  | 1233|  30.0k|  END_LIBRARY_FUNC
  ------------------
  | [0;36mINS_FLOOR:
[0m  | 1221|      [0;35m1[0m|  LIBRARY_FUNC_B_LOAD(name)                                                    \
  | 1222|      [0;35m1[0m|  if ((fb & TAG_MASK) == FLONUM_TAG) {                                         \
  | 1223|      [0;35m1[0m|    auto flo = (flonum_s *)(fb - FLONUM_TAG);                                  \
  | 1224|      1|    auto res = func(flo->x);                                                   \
  | 1225|      1|                                                                               \
  | 1226|      1|    auto r = (flonum_s *)GC_malloc(sizeof(flonum_s));                          \
  | 1227|      1|    r->type = FLONUM_TAG;                                                      \
  | 1228|      1|    r->x = res;                                                                \
  | 1229|      1|    frame[ra] = (long)r + FLONUM_TAG;                                          \
  | 1230|      1|  } else [0;41m{                                                                     \[0m
  | 1231|      [0;35m0[0m|[0;41m    [0m[0;41mMUSTTAIL[0m[0;41m return FAIL_SLOWPATH([0m[0;41mARGS[0m[0;41m);                                       \[0m
  | 1232|      0|[0;41m  }[0m                                                                            \
  | 1233|      1|  END_LIBRARY_FUNC
  ------------------
  | [0;31mUnexecuted instantiation: INS_CEILING
[0m  ------------------
  | [0;31mUnexecuted instantiation: INS_EXP
[0m  ------------------
  | [0;31mUnexecuted instantiation: INS_LOG
[0m  ------------------
  | [0;31mUnexecuted instantiation: INS_TAN
[0m  ------------------
  | [0;31mUnexecuted instantiation: INS_ASIN
[0m  ------------------
  | [0;31mUnexecuted instantiation: INS_ACOS
[0m  ------------------
 1234|       |
 1235|       |LIBRARY_FUNC_FLONUM_MATH(SIN, sin);
 1236|       |LIBRARY_FUNC_FLONUM_MATH(SQRT, sqrt);
 1237|       |LIBRARY_FUNC_FLONUM_MATH(ATAN, atan);
 1238|       |LIBRARY_FUNC_FLONUM_MATH(COS, cos);
 1239|       |LIBRARY_FUNC_FLONUM_MATH(TRUNCATE, trunc);
 1240|       |LIBRARY_FUNC_FLONUM_MATH(FLOOR, floor);
 1241|       |LIBRARY_FUNC_FLONUM_MATH(CEILING, ceil);
 1242|       |LIBRARY_FUNC_FLONUM_MATH(EXP, exp);
 1243|       |LIBRARY_FUNC_FLONUM_MATH(LOG, log);
 1244|       |LIBRARY_FUNC_FLONUM_MATH(TAN, tan);
 1245|       |LIBRARY_FUNC_FLONUM_MATH(ASIN, asin);
 1246|       |LIBRARY_FUNC_FLONUM_MATH(ACOS, acos);
 1247|       |
 1248|  79.4M|long vm_callcc(long* frame) {
 1249|  79.4M|  auto sz = frame - stack;
 1250|  79.4M|  auto cont = (vector_s *)GC_malloc_no_collect(sz * sizeof(long) + 16);
 1251|  [0;35m79.4M[0m|  if (!cont) {
 1252|     26|    return FALSE_REP;
 1253|     26|  }
 1254|  [0;35m79.4M[0m|  cont->type = CONT_TAG;
 1255|  79.4M|  cont->len = sz << 3;
 1256|  79.4M|  memcpy(cont->v, stack, sz * sizeof(long));
 1257|       |
 1258|  79.4M|  return (long)cont | PTR_TAG;
 1259|  79.4M|}
 1260|       |
 1261|    [0;35m470[0m|LIBRARY_FUNC(CALLCC)
 1262|    470|  auto sz = frame - stack;
 1263|    470|  auto cont = (vector_s *)GC_malloc(sz * sizeof(long) + 16);
 1264|    470|  cont->type = CONT_TAG;
 1265|    470|  cont->len = sz << 3;
 1266|    470|  memcpy(cont->v, stack, sz * sizeof(long));
 1267|       |  
 1268|    470|  frame[ra] = (long)cont | PTR_TAG;
 1269|    470|END_LIBRARY_FUNC
 1270|       |
 1271|  83.1M|long vm_cc_resume(long c) {
 1272|  83.1M|  closure_s* cont = (closure_s*)(c & ~TAG_MASK);
 1273|  83.1M|  memcpy(stack, cont->v, (cont->len >> 3) * sizeof(long));
 1274|  83.1M|  return (long)&stack[cont->len >> 3];
 1275|  83.1M|}
 1276|       |
 1277|    [0;35m651[0m|LIBRARY_FUNC_BC_LOAD_NAME(CALLCC-RESUME, CALLCC_RESUME)
 1278|    [0;35m651[0m|  LOAD_TYPE_WITH_CHECK(cont, vector_s, fb, CONT_TAG);
 1279|    651|  memcpy(stack, cont->v, (cont->len >> 3) * sizeof(long));
 1280|    651|  frame = &stack[cont->len >> 3];
 1281|       |  
 1282|       |  // DO A RET
 1283|    651|  pc = (unsigned int *)frame[-1];
 1284|    651|  frame[-1] = fc;
 1285|    651|  frame -= (INS_A(*(pc - 1)) + 1);
 1286|       |
 1287|    [0;35m651[0m|  NEXT_INSTR[0;41m;[0m
 1288|      0|[0;41m}[0m
 1289|       |
 1290|  [0;35m66.1k[0m|LIBRARY_FUNC_B_LOAD_NAME(FILE-EXISTS?, FILE_EXISTS)
 1291|  [0;35m66.1k[0m|  LOAD_TYPE_WITH_CHECK(str, string_s, fb, STRING_TAG)
 1292|  [0;35m66.1k[0m|  if (0 == access(str->str, F_OK)) {
 1293|  35.6k|    frame[ra] = TRUE_REP;
 1294|  35.6k|  } else {
 1295|  30.4k|    frame[ra] = FALSE_REP;
 1296|  30.4k|  }
 1297|  66.1k|END_LIBRARY_FUNC
 1298|       |
 1299|  [0;35m58.1k[0m|LIBRARY_FUNC_B_LOAD_NAME(DELETE-FILE, DELETE_FILE)
 1300|  [0;35m58.1k[0m|  LOAD_TYPE_WITH_CHECK(str, string_s, fb, STRING_TAG)
 1301|  [0;35m58.1k[0m|  if (0 == unlink(str->str)) {
 1302|  58.1k|    frame[ra] = TRUE_REP;
 1303|  58.1k|  } else [0;41m{[0m
 1304|      0|[0;41m    frame[ra] = [0m[0;41mFALSE_REP[0m[0;41m;[0m
 1305|      0|[0;41m  }[0m
 1306|  58.1k|END_LIBRARY_FUNC
 1307|       |
 1308|       |///////////
 1309|       |#ifdef PROFILER
 1310|      0|void INS_PROFILE_RET1_ADJ(PARAMS) [0;41m{[0m
 1311|      0|[0;41m profile_pop_frame();[0m
 1312|      0|[0;41m profile_set_pc(pc);[0m
 1313|      [0;35m0[0m|[0;41m [0m[0;41mMUSTTAIL[0m[0;41m return INS_RET1([0m[0;41mARGS[0m[0;41m);[0m
 1314|      0|[0;41m}[0m
 1315|       |
 1316|      0|void INS_PROFILE_CALL_ADJ(PARAMS) [0;41m{[0m
 1317|      0|[0;41m profile_add_frame(pc);[0m
 1318|      0|[0;41m profile_set_pc(pc);[0m
 1319|      [0;35m0[0m|[0;41m [0m[0;41mMUSTTAIL[0m[0;41m return INS_CALL([0m[0;41mARGS[0m[0;41m);[0m
 1320|      0|[0;41m}[0m
 1321|       |
 1322|      0|void INS_PROFILE_CALLCC_RESUME_ADJ(PARAMS) [0;41m{[0m
 1323|       |[0;41m[0m  // TODO make callcc resume work[0;41m[0m
 1324|      0|[0;41m profile_pop_all_frames();[0m
 1325|      0|[0;41m profile_set_pc(pc);[0m
 1326|      [0;35m0[0m|[0;41m [0m[0;41mMUSTTAIL[0m[0;41m return INS_CALLCC_RESUME([0m[0;41mARGS[0m[0;41m);[0m
 1327|      0|[0;41m}[0m
 1328|       |#endif
 1329|       |//////////////
 1330|       |
 1331|       |#include "opcodes-table.h"
 1332|       |
 1333|    167|EXPORT void run(bcfunc *func, long argcnt, const long *args) {
 1334|    167|  vm_init();
 1335|       |
 1336|       |  // Bytecode stub to get us to HALT.
 1337|    [0;35m167[0m|  unsigned int final_code[] = {CODE(CALL, 0, 1, 0), CODE(HALT, 0, 0, 0)};
 1338|    167|  unsigned int *code = &func->code[0];
 1339|       |
 1340|    167|  long *frame;
 1341|       |  // Initial stack setup has a return to bytecode stub above.
 1342|       |
 1343|    167|  stack[0] = (long)&final_code[1]; // return pc
 1344|    167|  frame = &stack[1];
 1345|    167|  frame_top = stack + stacksz - 256;
 1346|       |
 1347|    [0;35m279[0m|  for (long i = 0; i < argcnt; i++) {
 1348|    112|    frame[i] = args[i];
 1349|    112|  }
 1350|       |
 1351|    167|  unsigned int *pc = &code[0];
 1352|       |
 1353|  [0;35m10.8k[0m|  for (int i = 0; i < hotmap_sz; i++) {
 1354|  10.6k|    hotmap[i] = hotmap_cnt;
 1355|  10.6k|  }
 1356|       |
 1357|    167|  opcode_table_init();
 1358|       |  // Setup instruction table.
 1359|  [0;35m17.8k[0m|  for (int i = 0; i < INS_MAX; i++) {
 1360|  17.7k|    l_op_table_record[i] = RECORD;
 1361|  17.7k|  }
 1362|    167|#ifdef PROFILER
 1363|    [0;35m167[0m|  if (profile) [0;41m{[0m
 1364|      0|[0;41m    l_op_table_profile[RET1] = INS_PROFILE_RET1_ADJ;[0m
 1365|      0|[0;41m    l_op_table_profile[CALL] = INS_PROFILE_CALL_ADJ;[0m
 1366|      0|[0;41m    l_op_table_profile[CALLCC_RESUME] = INS_PROFILE_CALLCC_RESUME_ADJ;[0m
 1367|      0|[0;41m  }[0m
 1368|    167|#endif
 1369|       |
 1370|       |  // Initial tailcalling-interpreter variable setup.
 1371|    167|  unsigned int instr = *pc;
 1372|    167|  unsigned char op = instr & 0xff;
 1373|    167|  unsigned char ra = (instr >> 8) & 0xff;
 1374|    167|  instr >>= 16;
 1375|    167|  auto op_table_arg = (void **)l_op_table;
 1376|    167|#ifdef PROFILER
 1377|    [0;35m167[0m|  if (profile) [0;41m{[0m
 1378|      0|[0;41m    op_table_arg = (void **)l_op_table_profile;[0m
 1379|      0|[0;41m    l_op_table_profile[op]([0m[0;41mARGS[0m[0;41m);[0m
 1380|    167|[0;41m  }[0m else {
 1381|    167|    l_op_table[op](ARGS);
 1382|    167|  }
 1383|       |#else
 1384|       |    l_op_table[op](ARGS);
 1385|       |#endif
 1386|       |
 1387|       |  // And after the call returns, we're done.  only HALT returns.
 1388|    167|}
 1389|       |

[0;36m/home/davejwatson/myprojects/boom/vm.h:
[0m    1|       |#pragma once
    2|       |
    3|       |#include <stdint.h>
    4|       |
    5|       |#include "bytecode.h"
    6|       |#include "types.h"
    7|       |
    8|       |void run(bcfunc *func, long argcnt, const long *args);
    9|       |bcfunc *find_func_for_frame(const uint32_t *pc);
   10|       |void free_vm();
   11|       |
   12|       |extern bcfunc **funcs;
   13|       |
   14|   118M|#define hotmap_sz 64
   15|  1.57M|#define hotmap_cnt 200
   16|   117M|#define hotmap_loop 2
   17|       |#define hotmap_rec 1
   18|       |#define hotmap_tail_rec 1
   19|   [0;35m118M[0m|#define hotmap_mask (hotmap_sz - 1)
   20|       |
   21|       |__attribute__((always_inline)) long vm_read_char(port_s *port);
   22|       |__attribute__((always_inline)) long vm_peek_char(port_s *port);
   23|       |long vm_string_symbol(string_s* str);
   24|       |void vm_write(long obj, long port);
   25|       |void vm_make_string(long str, long ch);
   26|       |void vm_make_vector(long vec, long v);
   27|       |long vm_callcc(long* frame);
   28|       |long vm_cc_resume(long c);

