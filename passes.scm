;; Map including improper
(define (imap f l)
  (if (null? l) 
      '()
      (if (atom? l)
	  (f l)
	  (cons (f (car l)) (imap f (cdr l))))))

(define (improper? l)
  (if (null? l) #f
      (if (atom? l) #t
	  (improper? (cdr l)))))

;;(define (atom? e) (not (pair? e)))

(define gensym-var 0)
(define (gensym . s)
  (let ((sym (if (pair? s) (car s) 'gensym)))
    (set! gensym-var (+ 1 gensym-var))
    (string->symbol (string-append "var-" (symbol->string sym) "-" (number->string gensym-var)))))


;; Change ((lambda ..) ...) to
;; (let (...) ...)
(define (optimize-direct c)
  (define (sexp-direct f)
    (define params (second (first f)))
    (define args (cdr f))
    (define body (cddr (first f)))
    (sexp `(let ,(map list params args) ,@body)))
  (define (sexp f)
    (if (not (pair? f))
	f
	(case (car f)
	  ((quote) f)
	  (else
	   (if (and (pair? (car f)) (eq? 'lambda (caar f)))
	       (sexp-direct f)
	       (imap sexp f))))))
  (imap sexp c))

(define (union a b) (lset-union eq? a b))
(define (assignment-conversion c)
  (define (find-assigned f)
    (if (atom? f)
	'()
	(case (car f)
	  ((set!) (list (second f)))
	  ((quote) '())
	  (else (fold union '() (imap find-assigned f))))))
  (define (convert-assigned f assigned boxes)
    (display (format "~a BOXES ~a\n" f boxes))
    (if (atom? f)
	(if (assoc f boxes)
	    `($unbox ,(cdr (assoc f boxes)))
	    f)
	(case (car f)
	  ((set!)
	   `($set-box! ,(cdr (assq (second f) boxes)) ,@(cddr f)))
	  ((lambda)
	   (let* ((new-boxes (filter-map
			 (lambda (x)
			   (if (memq x assigned)
			       (cons x (gensym x))
			       #f))
			 (second f)))
		 (boxes (append new-boxes boxes)))
	     (if (null? new-boxes)
		 `(lambda ,(second f)
		    ,@(imap (lambda (x) (convert-assigned x assigned boxes)) (cddr f)))
		 `(lambda ,(second f)
		    (let
			,(map (lambda (x) `(,(cdr x) ($box ,(car x)))) boxes)
		      ,@(imap (lambda (x) (convert-assigned x assigned boxes)) (cddr f)))))))
	  ((letrec)
	   (let* ((new-boxes (filter-map
			 (lambda (x)
			   (if (memq x assigned)
			       (cons x (gensym x))
			       #f))
			 (map car (second f))))
		 (boxes (append new-boxes boxes)))
	     (if (null? new-boxes)
		 `(letrec ,(second f)
		    ,@(imap (lambda (x) (convert-assigned x assigned boxes)) (cddr f)))
		 `(letrec ,(second f)
		    (let
			,(map (lambda (x) `(,(cdr x) ($box ,(car x)))) boxes)
		      ,@(imap (lambda (x) (convert-assigned x assigned boxes)) (cddr f)))))))
	  ((quote) f)
	  (else (imap (lambda (a) (convert-assigned a assigned boxes)) f)))))
  (define assigned (find-assigned c))
  (display (format "Assigned: ~a\n" assigned))
  (convert-assigned c assigned '()))
