(import (r7rs))

(import (srfi 151)
	(chicken pretty-print))
;(include "str2num.scm")

(define line 1)
(define (read2 port)
  (define (read-to-delimited)
    (let loop ((res '()) (c (peek-char port)))
      (cond
       ((eof-object? c) (if (not (null? res)) (list->string (reverse res)) c))
       ((memv c '(#\( #\) #\" #\| #\newline #\return #\space #\tab #\;))
	(list->string (reverse res)))
       (else
	(loop (cons (read-char port) res ) (peek-char port))))))
  (define (skip-whitespace)
    (let ((c (peek-char port)))
      (cond
       ((eof-object? c) c)
       ((char=? #\newline c) (set! line (+ 1 line)) (read-char port) (skip-whitespace))
       ((char-whitespace? c) (read-char port) (skip-whitespace)))))
  (define (skip-whitespace-and-comments)
    (let ((c (peek-char port)))
      (cond
       ((eof-object? c) c)
       ((char=? #\newline c) (set! line (+ 1 line)) (read-char port) (skip-whitespace-and-comments))
       ((char-whitespace? c) (read-char port) (skip-whitespace-and-comments))
       ((char=? #\; c) (skip-line) (skip-whitespace-and-comments)))))
  (define (skip-line)
    (let ((c (read-char port)))
      (if (char=? c #\newline)
	  (begin
	    (set! line (+ 1 line))
	    (read-one))
	  (skip-line))))
  (define (read-escape)
    (let ((c (read-char port)))
      (if (eof-object? c) (error "Incomplete escape sequence"))
      (case c
	((#\a) #\alarm)
	((#\n) #\newline)
	((#\r) #\return)
	((#\t) #\tab)
	((#\b) #\backspace)
	((#\tab #\space) (skip-line) (skip-whitespace) #f)
	((#\newline) (skip-whitespace) #f)
	((#\x #\X)
	 (let* ((delim (read-to-delimited))
		(ch (string->number delim 16))
		(next (read-char port)))
	   (if (not (eq? #\; next))
	       (error "Invalid hex string escape")
	       (integer->char ch))))
	(else  c)))
    )
  (define (read-delimited term)
    (let loop ((res '()) (c (read-char port)))
      (cond
       ((eof-object? c) (error "incomplete object:" (list->string (reverse res)) "line: " line))
       ((char=? #\\ c)
	(let ((es (read-escape)))
	  (if es (loop (cons es res) (read-char port))
	      (loop res (read-char port)))))
       ((char=? term c) (list->string (reverse res)))
       (else (loop (cons c res) (read-char port))))
      )
    )
  (define (read-list)
    (define line-start line)
    (let loop ((res '()))
      (skip-whitespace-and-comments)
      (let ((c (peek-char port)))
	(cond
	 ((eof-object? c) (error "EOF found while parsing list starting on line " line-start " and ending " line))
	 ((char=? c #\)) (read-char port) (reverse res))
	 ((char=? c #\.) (let ((token (read-to-delimited)))
		  (if (= 1 (string-length token))
		      (let ((fin (read-one)))
			(skip-whitespace-and-comments)
			(if (not (eq? #\) (read-char port)))
			    (error "Invalid dotted list")
			    (append (reverse res) fin)))
		      (loop (cons (cond
				   ((string->number token) => (lambda (num) num))
				   (else (string->symbol token))) res)))))
	 (else (loop (cons (read-one) res)))))))
  (define named-chars '(("tab" . #\tab)
			("space" . #\space)
			("return" . #\return)
			("newline" . #\newline)
			("alarm" . #\alarm)
			("backspace" . #\backspace)
			("delete" . #\delete)
					;("escape" . #\escape)
					;		      ("null" . #\null)
			))
  (define delims '(#\( #\) #\; #\| #\"))
  (define (do-read-char)
    (let ((ch (peek-char port)))
      (if (memv ch delims)
	  (read-char port))
      (let ((token (read-to-delimited)))
	(cond
	 ((= 1 (string-length token)) (string-ref token 0))
	 ((assoc token named-chars) => cdr)
	 (else "Error invalid char: " token)))))
  (define (skip-comment depth)
    (case (read-char port)
      ((#\#) (skip-comment (if (char=? #\| (peek-char port)) (+ 1 depth) depth)))
      ((#\|) (if (char=? #\# (peek-char port))
		 (if (= 0 depth)
		     (read-char port)
		     (skip-comment (- depth 1)))
		 (skip-comment depth)))
      ((#\newline) (set! line (+ 1 line))
       (skip-comment depth))
      (else (if (eof-object? (peek-char port))
		(error "unterminated comment")
		(skip-comment depth)))))
  (define (read-hash)
    (let ((c (peek-char port)))
      (case c
	((#\|) (skip-comment 0))
	((#\;) (read-char port) (read-one) (read-one))
	((#\() (read-char port) (list->vector (read-list)))
	((#\\) (read-char port) (do-read-char))
	((#\t) (read-char port) #t)
	((#\f) (read-char port) #f)
	((#\b #\o #\d #\x #\i #\e) (string->number (string-append "#" (read-to-delimited))))
	((#\u) (read-char port)
	 (if (not (char=? #\8 (peek-char port))) (error "Not a bytevector:" (peek-char port))
	     (read-char port))
	 (let ((ls (read-one)))
	   (if (not (list? ls))
	       (error "Not a bytevector list:" ls)
	       ls)))
	(else (error "Unknown hash: " c)))))
  (define (read-one)
    (skip-whitespace)
    (let ((c (peek-char port)))
      (case (peek-char port)
	((#\#) (read-char port) (read-hash))
	((#\() (read-char port) (read-list))
	((#\") (read-char port) (read-delimited #\"))
	((#\;) (read-char port) (skip-line))
	((#\|) (read-char port) (string->symbol (read-delimited #\|)))
	((#\') (read-char port) (list 'quote (read-one)))
	((#\`) (read-char port) (list 'quasiquote (read-one)))
	((#\,) (read-char port)
	 (case (peek-char port)
	   ((#\@) (read-char port) (list 'unquote-splicing (read-one)))
	   (else
	    (list 'unquote (read-one)))))
	(else
	 (let  ((token (read-to-delimited)))
	   (cond 
	    ((eof-object? token) token)
	    ((string->number token) => (lambda (num) num))
	    (else (string->symbol token))))))))
  (read-one))
(define (read-file)
  (define (read-file-rec sexps)
    (define next (read2 (current-input-port)))
    (pretty-print next)
    (if (eof-object? next)
	(let ((res (reverse sexps)))
					;(dformat "Expanding: ~a\n" res)
	  res)
	(read-file-rec (cons next sexps))))

  (read-file-rec '()))

(read-file)
