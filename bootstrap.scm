;;These have to match memory_layout.scm and types.h.
(define (number? x) (or (fixnum? x) (flonum? x)))
(define (flonum? x) ($guard x 2))
(define (fixnum? x) ($guard x 0))
(define (null? x) ($guard x 23))
(define (boolean? x) ($guard x 7))
(define (char? x) ($guard x #b00001111))
(define (pair? x) ($guard x 3))
(define (procedure? x) ($guard x 5))
(define (symbol? x) ($guard x 4))
(define (vector? x) ($guard x 17))
(define (string? x) ($guard x 9))
(define (port? x) ($guard x #b011001))
(define complex? number?)
(define real? number?)
(define rational? number?)
(define integer? fixnum?)
(define exact? fixnum?)
(define inexact? flonum?)

(define (reducer f init args)
  (if (pair? args)
      (reducer f (f init (car args)) (cdr args))
      init))
(define (+ . rest)
  (reducer (lambda (a b) ($+ a b)) 0 rest))
(define (- . rest)
  (if (= (length rest) 1)
      (* -1 (car rest))
      (if ($< (length rest) 3)
	  ($- (car rest) (cadr rest))
	  (reducer (lambda (a b) ($- a b)) (car rest) (cdr rest))
	  )))
(define (* . rest)
  (reducer (lambda (a b) ($* a b)) 1 rest))
(define (comparer f args)
  (if (and (pair? args) (pair? (cdr args)))
      (if (f (car args) (cadr args))
	  (comparer f (cdr args))
	  #f)
      #t))
(define (/ a b) ($/ a b))
(define (quotient x y)
  (/ x y))
(define (modulo x y)
  (let ((z (remainder x y)))
    (if (negative? y)
	(if (positive? z) (+ z y) z)
	(if (negative? z) (+ z y) z))))
(define (remainder a b) ($% a b))
(define (gcd2 a b)
  (if (= b 0)
      (abs a)
      (gcd b (remainder a b))))

(define (gcd . args)
  (if (null? args)
      0
      (let lp ((x (car args)) (ls (cdr args)))
        (if (null? ls) x (lp (gcd2 x (car ls)) (cdr ls))))))
(define (lcm2 a b)
  (abs (quotient (* a b) (gcd a b))))

(define (lcm . args)
  (if (null? args)
      1
      (let lp ((x (car args)) (ls (cdr args)))
        (if (null? ls) x (lp (lcm2 x (car ls)) (cdr ls))))))
(define (< . rest)
  (comparer (lambda (a b) ($< a b)) rest))
(define (> . rest)
  (comparer (lambda (a b) ($> a b)) rest))
(define (>= . rest)
  (comparer (lambda (a b) (not ($< a b))) rest))
(define (<= . rest)
  (comparer (lambda (a b) (not ($> a b))) rest))
(define (= . rest)
  (comparer (lambda (a b) ($= a b)) rest))
(define (not a) (if a #f #t))
(define ($> a b) (not (or ($= a b) ($< a b))))

(define (eq? a b) ($eq a b))
(define (eqv? a b)
  (or ($eq a b)
      (and (flonum? a) (flonum? b)
	   ($= a b))))
(define (equal? a b)
  (if (eqv? a b) #t
      (cond
       ((pair? a)
	(and (pair? b) (equal? (car a) (car b)) (equal? (cdr a) (cdr b))))
       ((string? a)
	(and (string? b) (string=? a b)))
       ((vector? a) ; TODO make faster
	(and (vector? b) (equal? (vector->list a) (vector->list b)))) 
       (else #f))))

(define (car a) ($car a))
(define (cdr a) ($cdr a))
(define (set-car! c a) ($set-car! c a))
(define (set-cdr! c a) ($set-cdr! c a))
(define (cons a b) ($cons a b))
(define (list . x) x)

(define (cddr e) (cdr (cdr e)))
(define (caar e) (car (car e)))
(define (cadr e) (car (cdr e)))
(define (cdar e) (cdr (car e)))

(define (caddr e) (car (cddr e))) 
(define (cdddr e) (cdr (cddr e))) 
(define (caaar e) (car (caar e)))
(define (cdaar e) (cdr (caar e)))
(define (caadr e) (car (cadr e)))
(define (cdadr e) (cdr (cadr e)))
(define (cadar e) (car (cdar e)))
(define (cddar e) (cdr (cdar e)))

(define (caaddr e) (car (caddr e))) 
(define (cdaddr e) (cdr (caddr e))) 
(define (cadddr e) (car (cdddr e))) 
(define (cddddr e) (cdr (cdddr e))) 
(define (caaaar e) (car (caaar e)))
(define (cdaaar e) (cdr (caaar e)))
(define (cadaar e) (car (cdaar e)))
(define (cddaar e) (cdr (cdaar e)))
(define (caaadr e) (car (caadr e)))
(define (cdaadr e) (cdr (caadr e)))
(define (cadadr e) (car (cdadr e)))
(define (cddadr e) (cdr (cdadr e)))
(define (caadar e) (car (cadar e)))
(define (cdadar e) (cdr (cadar e)))
(define (caddar e) (car (cddar e)))
(define (cdddar e) (cdr (cddar e)))

(define (map . lst)
  (let loop ((lsts (cons (cadr lst) (cddr lst))))
    (let ((hds (let loop2 ((lsts lsts))
		 (if (null? lsts)
		     '()
		     (let ((x (car lsts)))
		       (and (not (null? x))
			    (let ((r (loop2 (cdr lsts))))
			      (and r (cons (car x) r)))))))))
      (if hds
	  (cons
	   (apply (car lst) hds)
	   (loop
	    (let loop3 ((lsts lsts))
	      (if (null? lsts)
		  '()
		  (cons (cdr (car lsts)) (loop3 (cdr lsts)))))))
	  '())))  )

(define (append . lsts)
  (if (null? lsts) '()
      (let loop ((lsts lsts))
	(if (null? (cdr lsts))
	    (car lsts)
	    (let copy ((node (car lsts)))
	      (if (pair? node)
		  (cons (car node) (copy (cdr node)))
		  (loop (cdr lsts))))))))

(define (reverse lst)
  (let loop ((lst lst) (rest '()))
    (if (pair? lst)
	(loop (cdr lst) (cons (car lst) rest))
	rest)))

(define (list-ref lst n)
  (if (zero? n)
      (car lst)
      (list-ref (cdr lst) (- n 1))))

(define (assv obj1 alist1)
  (let loop ((obj obj1) (alist alist1))
  (if (null? alist) #f
      (if (eqv? (caar alist) obj) 
	  (car alist)
	  (loop obj (cdr alist))))))
(define (assq obj1 alist1)
  (let loop ((obj obj1) (alist alist1))
  (if (null? alist) #f
      (begin
	(if (eq? (caar alist) obj) 
	    (car alist)
	    (loop obj (cdr alist)))))))
(define (assoc obj1 alist1)
  (let loop ((obj obj1) (alist alist1))
  (if (null? alist) #f
      (begin
	(if (equal? (caar alist) obj) 
	    (car alist)
	    (loop obj (cdr alist)))))))


(define (memq obj list) 
  (if (null? list) #f
      (if (eq? obj (car list)) 
	  list
	  (memq obj (cdr list)))))
(define (memv obj list) 
  (if (null? list) #f
      (if (eqv? obj (car list)) 
	  list
	  (memv obj (cdr list)))))
(define (member obj list) 
  (if (null? list) #f
      (if (equal? obj (car list)) 
	  list
	  (member obj (cdr list)))))

(define (zero? a) ($= a 0))

(define (make-vector len . val)
  ($make-vector len (if (pair? val) (car val) #f)))
(define (vector-set! v k obj)
  ($vector-set! v k obj))
(define (vector-ref v k)
  ($vector-ref v k))
(define (vector->list v)
    (let loop ((l (- (vector-length v) 1)) 
	       (lst '()))
      (if (not (< l 0))
	    (loop (- l 1) (cons (vector-ref v l) lst))
	    lst)))
(define (vector-length v)
  ($vector-length v))
(define (string-length v)
  ($string-length v))

(define (negative? a)
  ($< a 0))
(define (positive? a)
  ($> a 0))
(define (odd? n)
  (not (even? n)))
(define (even? n)
  (= 0 (remainder n 2)))
(define (abs a)
  (if (negative? a)
      (* a -1)
      a))

(define (max . args)
  (let loop ((args args))
    (if (eq? (length args) 1)
	(car args)
	(let* ((a (car args))
	       (b (cadr args))
	       (m (if (< a b) b a))
	       (i (if (or (inexact? a) (inexact? b)) (inexact m) m)))
	  (loop (cons i (cddr args)))))))

(define (min . args)
  (let loop ((args args))
    (if (eq? (length args) 1)
	(car args)
	(let* ((a (car args))
	       (b (cadr args))
	       (m (if (> a b) b a))
	       (i (if (or (inexact? a) (inexact? b)) (inexact m) m)))
	  (loop (cons i (cddr args)))))))


(define (length e)
  (let length-loop ((e e) (cnt 0))
    (if (pair? e)
	(length-loop (cdr e) (+ 1 cnt))
	cnt)))
(define (list->vector lst)
  (define v (make-vector (length lst)))
  (define (setloop place item v)
    (if (not (pair? item))
	v
	(begin
	  (vector-set! v place (car item))
	  (setloop (+ 1 place) (cdr item) v))))
  (setloop 0 lst v)
  )



(define (list? x)
  (let loop ((fast x) (slow x))
    (or (null? fast)
	(and (pair? fast)
	     (let ((fast (cdr fast)))
	       (or (null? fast)
		   (and (pair? fast)
			(let ((fast (cdr fast))
			      (slow (cdr slow)))
			  (and (not (eq? fast slow))
			       (loop fast slow))))))))))


(define (display arg)
  (cond
   ((null? arg) (display "()" ))
   ((pair? arg)
    (display "(" )
    (let loop ((arg arg))
      (if (not (pair? arg)) (begin (display ". " ) (display arg ))
	  (begin (display (car arg) ) 
		 (if (not (null? (cdr arg)))
		     (begin
		       (display " " )
		       (loop (cdr arg)))))))
    (display ")" ))
   ((vector? arg)
    (display "#" )
    (display (vector->list arg) ))
   (else ($display arg ))))

(define (write arg)
  (cond
   ((null? arg) (display "()" ))
   ((pair? arg)
    (display "(" )
    (let loop ((arg arg))
      (if (not (pair? arg)) (begin (display ". " ) (write arg ))
	  (begin (write (car arg) ) 
		 (if (not (null? (cdr arg)))
		     (begin
		       (display " " )
		       (loop (cdr arg)))))))
    (display ")" ))
   ((vector? arg)
    (display "#" )
    (write (vector->list arg) ))
   ((char? arg)
    (cond
     ((char=? #\newline arg) (display "#\\newline" ))
     ((char=? #\tab arg) (display "#\\tab" ))
     ((char=? #\space arg) (display "#\\space" ))
     ((char=? #\return arg) (display "#\\return" ))
     (else (display "#\\" ) (display arg ))))
   ((string? arg)
    (display "\"" ) 
    (for-each 
     (lambda (chr) 
       (cond
	((char=? #\" chr) (display "\\\"" ))
	((char=? #\\ chr) (display "\\\\" ))
	(else (display chr ))))
     (string->list arg))
    (display "\"" ))
   (else 
    ($display arg))))

(define (for-each proc lst )
  (if (not (null? lst))
      (begin
	(proc (car lst))
	(for-each proc (cdr lst)))))

(define (for-each3 proc lst1 lst2)
  (if (and  (not (null? lst1)) (not (null? lst2)))
      (begin
	(proc (car lst1) (car lst2))
	(for-each3 proc (cdr lst1) (cdr lst2)))))

(define (make-string len . val)
  ($make-string len (if (pair? val) (car val) #\space)))
(define (string-set! s k obj)
  ($string-set! s k obj))
(define (string-ref s k)
  ($string-ref s k))
(define (string->list str)
  (let ((n (string-length str)))
    (let loop ((i (- n 1)) (lst '()))
      (if (< i 0)
	  lst
	  (loop (- i 1) (cons (string-ref str i) lst))))))
(define (char=? a b)
  ($eq a b))

(define (newline)
  (display #\newline))

(define (apply . lst)
  (let* ((firstargs (reverse (cdr (reverse (cdr lst)))))
	 (args (append firstargs (car (reverse (cdr lst))))))
    (apply2 (car lst) args)))

(define (apply2 fun args)
  ($apply fun args))

(define (strcmp f a b eq lt gt)
  (let loop ((pos 0) (rema (string-length a)) (remb (string-length b)))
    (cond
     ((and (= rema 0 ) (= remb 0))  eq)
     ((= rema 0)  lt)
     ((= remb 0)  gt)
     ((eq? (string-ref a pos) (string-ref b pos))
      (loop (+ 1 pos) (- rema 1) (- remb 1)))
     (else
      (f (string-ref a pos) (string-ref b pos))))))

(define (string<? a b) (strcmp char<? a b #f #t #f))
(define (string>? a b) (strcmp char>? a b #f #f #f))
(define (string<=? a b) (strcmp char<=? a b #t #t #f))
(define (string>=? a b) (strcmp char>=? a b #t #f #f))
(define (string-ci<? a b) (strcmp char-ci<? a b #f #t #f))
(define (string-ci>? a b) (strcmp char-ci>? a b #f #f #f))
(define (string-ci<=? a b) (strcmp char-ci<=? a b #t #t #f))
(define (string-ci>=? a b) (strcmp char-ci>=? a b #t #f #f))
(define (string-ci=? a b) (strcmp char-ci=? a b #t #f #f))
(define (string=? a b) (strcmp char=? a b #t #f #f))

(define (char-alphabetic? c)
  (let ((n (char->integer c)))
    (cond ((< n #x41) #f)		; A
	  ((> n #x7a) #f)		; z
	  ((> n #x60))		; a-1
	  ((< n #x5b))		; Z+1
	  (else #f))))

(define (char-numeric? c)
  (let ((n (char->integer c)))
    (cond ((< n #x30) #f)		; 0
	  ((> n #x39) #f)		; 9
	  (else #t))))

(define (char-whitespace? c)
  (let ((n (char->integer c)))
    (or (eq? n 32) (eq? n 9) (eq? n 12) (eq? n 10) (eq? n 13))))

(define (char-upper-case? c)
  (let ((n (char->integer c)))
    (cond ((< n #x41) #f)		; A
	  ((> n #x5a) #f)		; Z
	  (else #t))))

(define (char-lower-case? c)
  (let ((n (char->integer c)))
    (cond ((< n #x61) #f)		; a
	  ((> n #x7a) #f)		; z
	  (else #t))))

(define (char-upcase c)
  (let ((n (char->integer c)))
    (if (or (< n #x61)		; a
	    (> n #x7a))		; z
	(integer->char n)
	(integer->char (- n 32)))))
(define (char-downcase c) 
  (let ((n (char->integer c)))
    (if (or (< n #x41)		; A
	    (> n #x5a))		; Z
	(integer->char n)
	(integer->char (+ n 32)))))
(define (char->integer e)
  ($char->integer e))
(define (integer->char e)
  ($integer->char e))

(define (char=? x y)
  ($eq x y))
(define (char>? x y)
  (> (char->integer x) (char->integer y)))
(define (char<? x y)
  (< (char->integer x) (char->integer y)))
(define (char>=? x y)
  (>= (char->integer x) (char->integer y)))
(define (char<=? x y)
  (<= (char->integer x) (char->integer y)))
(define (char-ci=? x y)
  (char=? (char-downcase x) (char-downcase y)))
(define (char-ci>? x y)
  (char>? (char-downcase x) (char-downcase y)))
(define (char-ci<? x y)
  (char<? (char-downcase x) (char-downcase y)))
(define (char-ci>=? x y)
  (char>=? (char-downcase x) (char-downcase y)))
(define (char-ci<=? x y)
  (char<=? (char-downcase x) (char-downcase y)))

(define (symbol->string sym)
  ($symbol->string sym))
(define (string->symbol sym)
  ($string->symbol sym))

(define (string . chars) (list->string chars))
(define (list->string chars)
  (let* ((len (length chars))
	 (c (make-string len)))
    (let loop ((i 0) (chars chars))
      (if (< i len)
	  (begin
	    (string-set! c i (car chars))
	    (loop (+ 1 i) (cdr chars)))))
    c))
(define (substring str start end)
  (define c (make-string (- end start)))
  (let loop ((i start) (j 0))
    (if (< i end)
	(begin
	  (string-set! c j (string-ref str i))
	  (loop (+ 1 i) (+ 1 j)))))
  c)
(define (string-append . strs)
  (let* ((totallen (apply + (map string-length strs)))
	 (newstr (make-string totallen)))
    (let loop ((strs strs) (place 0))
      (if (not (null? strs))
	  (begin
	    (let loop ((pos 0))
	      (if (< pos (string-length (car strs)))
		  (begin
		    (string-set! newstr (+ place pos) (string-ref (car strs) pos))
		    (loop (+ 1 pos)))))
	    (loop (cdr strs) (+ place (string-length (car strs)))))))
    newstr))

(define (vector . rest) (list->vector rest))

(define (number->string num . base)
  (if (pair? base)
      (number->string2 num (car base))
      (number->string2 num 10)))
(define (number->string2 num base)
  (let* ((buflen 100)
	 (buffer (make-string buflen)))
    (cond ((inexact? num) ($primcall dtoa num))
	  ((eq? num 0) "0")
	  (else
	   (let ((neg (negative? num)))
	     (let loop ((p buflen) (n (if neg (- 0 num) num)))
	       (cond ((eq? n 0)
		      (if neg
			  (begin
			    (set! p (- p 1))
			    (string-set! buffer p #\-)))
		      (substring buffer p buflen))
		     (else
		      (let ((q (/ n base))
			    (r (modulo n base))
			    (p (- p 1)))
			(string-set! buffer p (integer->char (+ (if (>= r 10) 87 48) r)))
			(loop p q))))))))))
(define (string->number str . base)
  (if (pair? base)
      (%string->number str (car base))
      (%string->number str 10)))
(define (%string->number str base)
  (if (> (string-length str) 17) #f ;; TODO make a better overflow check
      (let* ((len (string-length str))
	     (s 1)
	     (p 0))
	(cond ((eq? 0 len) #f)
	      (else
	       (case (string-ref str 0)
		 ((#\-) 
		  (set! s -1)
		  (set! p 1))
		 ((#\+)
		  (set! p 1)))
	       (and (> len p)
		    (let loop ((p p) (n 0))
		      (if (>= p len)
			  (* s n)
			  (let* ((c (char-downcase (string-ref str p)))
				 (r (- (char->integer c) (if (char>=? c #\a) 87 48))))
			    (and (>= r 0) (< r base)
				 (loop (+ p 1) (+ (* n base) r))))))))))))

(define (pp arg) (display arg) (newline))
(define println pp)

(define (call-with-current-continuation l)
  (let ((cc ($callcc 0)))
    (l (lambda (res) ($callcc-resume cc res)))))


