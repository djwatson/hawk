(define (mask-byte b)
  (modulo b 256))

(define char-standard-case char-upcase)
(if (string=? (symbol->string 'A) "a")
    (set! char-standard-case char-downcase))

;; srfi 23
(define (error reason . args)
      (display "Error: ")
      (display reason)
      (for-each (lambda (arg) 
                  (display " ")
		  (write arg))
		args)
      (newline)
      (car -1))

(define (dformat format-string . objects)
  (define (format-error message)
    (error message format-string))
  (let loop ((format-list (string->list format-string))
             (objects objects))
    (cond ((null? format-list) #f) ;; done
          ((char=? (car format-list) #\~)
           (if (null? (cdr format-list))
               (format-error "Incomplete escape sequence")
               (case (cadr format-list)
                 ((#\a)
                  (if (null? objects)
                      (format-error "No value for escape sequence")
                      (begin
                        (display (car objects))
                        (loop (cddr format-list) (cdr objects)))))
                 ((#\s)
                  (if (null? objects)
                      (format-error "No value for escape sequence")
                      (begin
                        (write (car objects))
                        (loop (cddr format-list) (cdr objects)))))
                 ((#\%)
                  (newline)
                  (loop (cddr format-list) objects))
                 ((#\~)
                  (write-char #\~)
                  (loop (cddr format-list) objects))
                 (else
                  (format-error "Unrecognized escape sequence")))))
          (else (write-char (car format-list))
                (loop (cdr format-list) objects)))))

(define (arithmetic-shift n count)
  (if (negative? count)
      (let ((k (expt 2 (- count))))
        (if (negative? n)
            (+ -1 (quotient (+ 1 n) k))
            (quotient n k)))
      (* (expt 2 count) n)))
(define (map-in-order f list)
  (let recur ((lis list))
    (if (null? lis) lis
	(let ((tail (cdr lis))
	      (x (f (car lis))))
	  (cons x (recur tail))))))
(define (fold kons knil lis1 )
  (let lp ((lis lis1) (ans knil))	; Fast path
    (if (null? lis) ans
	(lp (cdr lis) (kons (car lis) ans)))))
(define (element? x lst)
  (let element_loop ((x x) (lst lst))
    (cond ((null? lst) #f)
          ((equal? x (car lst)) #t)
          (#t (element_loop x (cdr lst))))))
(define (union a b)
  (let union_loop ((a a) (b b))
    (cond ((null? b) a)
          ((element? (car b) a)
           (union_loop a (cdr b)))
          (#t (union_loop (cons (car b) a) (cdr b))))))
(define (difference a b)
  (let difference_loop ((a a) (b b))
    (cond ((null? a) '())
          ((element? (car a) b)
           (difference_loop (cdr a) b))
          (#t (cons (car a) (difference_loop (cdr a) b))))))
(define first car)
(define (second f) (cadr f))
(define (third f) (caddr f))
(define (fourth f) (cadddr f))
(define (fifth f) (cadddr (cdr f)))
(define (reverse! lis)
  (let lp ((lis lis) (ans '()))
    (if (null? lis) ans
        (let ((tail (cdr lis)))
          (set-cdr! lis ans)
          (lp tail lis)))))
(define (iota count )
  (if (< count 0) (error "Negative step count" iota count))
  (let ((start 0) (step 1))
    (let loop ((n 0) (r '()))
      (if (= n count)
	  (reverse r)
	  (loop (+ 1 n)
		(cons (+ start (* n step)) r))))))
(define (filter-map f list1 . list2)
  (if (not (pair? list2))
      (let recur ((lis list1))
	(if (null? lis) lis
	    (let ((tail (recur (cdr lis))))
	      (cond ((f (car lis)) => (lambda (x) (cons x tail)))
		    (else tail)))))
      (let recur ((lis1 list1) (lis2 (car list2)))
	(if (or (null? lis2) (null? lis1)) '()
	    (let ((tail (recur (cdr lis1) (cdr lis2))))
	      (cond ((f (car lis1) (car lis2)) => (lambda (x) (cons x tail)))
		    (else tail)))))))
  
(define (filter pred lis)			; Sleazing with EQ? makes this
  (let recur ((lis lis))
    (if (null? lis) lis			; Use NOT-PAIR? to handle dotted lists.
	(let ((head (car lis))
	      (tail (cdr lis)))
	  (if (pred head)
	      (let ((new-tail (recur tail)))	; Replicate the RECUR call so
		(if (eq? tail new-tail) lis
		    (cons head new-tail)))
	      (recur tail))))))		

(define next-id
  (let ((cur-node 0))
    (lambda ()
      (inc! cur-node)
      cur-node)))
