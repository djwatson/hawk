(define-syntax unless
  (syntax-rules ()
    ((_ cond body ...)
     (if (not cond) (begin body ...)))))

;; Map including improper
(define (imap f l)
  (if (null? l) 
      '()
      (if (atom? l)
	  (f l)
	  (cons (f (car l)) (imap f (cdr l))))))

(define (improper? l)
  (let improper_loop ((l l))
    (if (null? l) #f
	(if (atom? l) #t
	    (improper_loop (cdr l))))))

(define (to-proper l)
  (if (null? l) '()
      (if (atom? l) (list l) 
	  (cons (car l) (to-proper (cdr l))))))

;;(define (atom? e) (not (pair? e)))

(define gensym-var 0)
(define (compiler-gensym . s)
  (let ((sym (if (pair? s) (car s) 'gensym)))
    (set! gensym-var (+ 1 gensym-var))
    (string->symbol (string-append "var-" (symbol->string sym) "-" (number->string gensym-var)))))


;; Change ((lambda ..) ...) to
;; (let (...) ...)
(define (optimize-direct c)
  (define (sexp-direct f)
    (let* ((params (second (first f)))
	   (args (cdr f))
	   (body (map sexp (cddr (first f))))
	   (is-letrec (fold (lambda (a b) (and a b)) #t (map (lambda (a) (and (pair? a) (eq? (car a) 'lambda))) args))))
      (if (and (pair? params) (not (improper? params)))
	  `(,(if is-letrec 'letrec 'let) ,(map list params (map sexp args)) ,@(map sexp body))
	  `((lambda ,params ,@body) ,@args))))
  (define (sexp f)
    (if (not (pair? f))
	f
	(case (car f)
	  ((quote) f)
	  (else
	   (if (and (pair? (car f)) (eq? 'lambda (caar f)))
	       (sexp-direct f)
	       (imap sexp f))))))
  (imap sexp c))

(define (inline-called-once c)
  (define (pass f)
    (if (atom? f)
	f
	(case (car f)
	  ((quote) f)
	  ((let letrec)
	   (if (and (= 1 (length (second f)))
		    (pair? (second (first (second f))))
		    (eq? 'lambda (first (second (first (second f))))))
	       ;; It still might escape
	       (begin
		 ;;(dformat "Maybe inline: ~a\n" (cons (first f) (first (second f))))
		 (imap pass f))
	       (imap pass f)))
	  (else (imap pass f)))))
  (imap pass c))

;; At this point, 'letrec' is fixed and only contains lambdas,
;; and 'let' hasn't appeared yet, so we only have to add bindings for lambda.
(define (find-assigned f bindings)
  (if (atom? f)
      '()
      (case (car f)
	((set!) (if (memq (second f) bindings) (list (second f)) '()))
	((lambda) (find-assigned (cddr f) (union bindings (to-proper (second f)))))
	((quote) '())
	(else (fold union '() (imap (lambda (f) (find-assigned f bindings)) f))))))
(define (assignment-conversion c)
  (define (convert-assigned f assigned boxes)
    ;;(display (format "Convert assigned f ~a assigned ~a boxes ~a\n" f assigned boxes))
    (if (atom? f)
	(if (assoc f boxes)
	    `($unbox ,(cdr (assoc f boxes)))
	    f)
	(case (car f)
	  ((set!)
	   (let ((value (convert-assigned (third f) assigned boxes)))
	     (if (memq (second f) assigned)
		       `($set-box! ,(cdr (assq (second f) boxes)) ,value)
		       `(set! ,(second f) ,value))))
	  ((lambda)
	   (let* ((new-boxes (filter-map
			 (lambda (x)
			   (if (memq x assigned)
			       (cons x (compiler-gensym x))
			       #f))
			 (to-proper (second f))))
		  (boxes (append new-boxes boxes)))
	     (if (null? new-boxes)
		 `(lambda ,(second f)
		    ,@(imap (lambda (x) (convert-assigned x assigned boxes)) (cddr f)))
		 `(lambda ,(second f)
		    (let
			,(map (lambda (x) `(,(cdr x) ($box ,(car x)))) new-boxes)
		      ,@(imap (lambda (x) (convert-assigned x assigned boxes)) (cddr f)))))))
	  ((quote) f)
	  (else (imap (lambda (a) (convert-assigned a assigned boxes)) f)))))
  (define assigned (find-assigned c '()))
  ;;(display (format "Assigned: ~a\n" assigned))
  (convert-assigned c assigned '()))

;; TODO also case-lambda?
(define (fix-letrec-specific sexp)
  (define assigned (find-assigned sexp (map car (second sexp))))
  (let*
      ((vars (map car (cadr sexp)))
       (bindings (map fix-letrec (map cadr (cadr sexp))))
       (body (fix-letrec (cddr sexp)))
       (fixed (filter-map (lambda (v b)
			    (if
			     (and (pair? b) (eq? 'lambda (car b))
				  (not (memq v assigned)))
			     (list v b) #f))
			  vars bindings)  )
       (set (filter (lambda (v) (not (member v (map car fixed)))) vars))
       (tmp (map compiler-gensym set))
       (setters (map (lambda (s t) `(set! ,s ,t)) set tmp))
       (set-bindings (filter-map (lambda (v b)
				   (if (not (member v (map car fixed)))
				       ;; CONS here, because some default values could be #f.
				       (cons b #t)
				       #f)) vars bindings)))
    (cond
     ((and (pair? set) (pair? fixed))
      `((lambda ,set
	  (letrec ,fixed
	    ((lambda ,tmp
	       (begin
		 ,@setters
		 ,@body))
	     ,@(map car set-bindings))
	    )) ,@(map (lambda (unused) #f) set)))
      ((pair? set)
       `((lambda ,set
	   ((lambda ,tmp
	      (begin
		,@setters
		,@body))
	    ,@(map car set-bindings)))
	 ,@(map (lambda (unused) #f) set)))
      ((pair? fixed)
       `(letrec ,fixed
	  ,@body))
      (else #f))))

(define (fix-letrec sexp)
  (if (pair? sexp)
      (case (car sexp)
	((quote) sexp)
	((letrec) (fix-letrec-specific sexp))
	(else
	 (imap fix-letrec sexp)))
      sexp))

;; Any lambdas not currently wrapped in a letrec form are wrapped in a letrec:
;; (lambda (x) e) â†’ (letrec ([f' (lambda (x) e)]) f')
(define (letrec-ify-prepass sexp)
  (define (pass f)
    (if (atom? f)
	f
	(case (car f)
	  ((quote) f)
	  ((letrec)
	   `(letrec ,(map (lambda (f)
			    (define lam (second f))
			   `(,(car f)
			     (named-lambda ,(second lam) ,(third lam) ,@(imap pass (cdddr lam))))) (second f))
	      ,@(imap pass (cddr f))))
	  ((named-lambda)
	   (let ((name (compiler-gensym (string->symbol (second f)))))
	     `(letrec ((,name (named-lambda ,(second f) ,(third f) ,@(imap pass (cdddr f))))) ,name)))
	  (else (imap pass f)))))
  (imap pass sexp))

(define (tarjan-scc graph)
  (define stack '())
  (define index 0)
  (define indices '())
  (define lowlinks '())
  (define on-stack '())
  (define result '())

  (define (update-lowlink v link)
    (let ((cur (assq v lowlinks)))
      (if cur (set-cdr! cur link)
	  (set! lowlinks (cons (cons v link) lowlinks)))))

  (define (strongconnect v)
    (set! indices (cons (cons v index) indices))
    (set! lowlinks (cons (cons v index) lowlinks))
    (set! index (+ index 1))
    (set! on-stack (cons v on-stack))
  
    (for-each (lambda (w)
                (let ((w-index (assq w indices)))
                  (if (not w-index)
		      (begin
			(strongconnect w)
			(update-lowlink v (min (cdr (assq v lowlinks)) (cdr (assq w lowlinks)))))
		      (when (memq w on-stack)
			(update-lowlink v (min (cdr (assq v lowlinks)) (cdr (assq w indices))))))))
	      (assq v graph))

    (when (= (cdr (assq v lowlinks)) (cdr (assq v indices)))
      (let loop ((scc '()))
	(let ((w (car on-stack)))
          (set! on-stack (cdr on-stack))
          (if (eq? v w)
              (set! result (cons (cons v scc) result))
              (loop (cons w scc)))))))

  (for-each (lambda (v)
              (unless (assq v indices)
                (strongconnect v)))
            (map car graph))
  
  result)

(define scc-table '())
(define free-table '())
;; Find free variables in named-lambdas
(define (find-free sexp)
  ;; Takes in a set of current bindings, returns a list of free
  ;; variables at each sexp.  Does *not* modify the graph, stores
  ;; free-vars in a side table.
  ;; For letrec groups, is a alist of (lambda (list of lambdas it uses, not including itself))
  (define (find-free f bindings)
    (if (atom? f)
	(if (memq f bindings) (list f) '())
	(case (car f)
	  ((quote) '())
	  ;; let, case, and loop (and letrec and named-lambda) introduce new bindings
	  ((let)
	   (let* ((new-bindings (map car (second f)))
		  (all-bindings (append new-bindings bindings))
		  (body-free (fold union '() (imap (lambda (f) (find-free f all-bindings)) (cddr f))))
		  (binding-free (fold union '() (imap (lambda (f) (find-free f bindings)) (map second (second f))))))
	     (union (difference body-free new-bindings) binding-free)))
	  ((letrec)
	   (let ()
	     (define (lambda-find-free f bindings letrec-bindings name)
	       (let* ((new-bindings (to-proper (third f)))
		      (all-bindings (append new-bindings bindings))
		      (body-free (fold union '() (imap (lambda (f) (find-free f all-bindings)) (cdddr f))))
		      (all-free (difference body-free new-bindings))
		      (scc (difference (intersection letrec-bindings all-free) (list name)))
		      (free (difference all-free letrec-bindings)))
		 (when (assq name free-table)
		   (error "Already found free for " name))
		 (set! free-table (cons (cons name free) free-table))
		 (set! scc-table (cons (cons name scc) scc-table))
		 free))
	     (let* ((new-bindings (map car (second f)))
		    (all-bindings (append new-bindings bindings))
		    (body-free (fold union '() (imap (lambda (f) (find-free f all-bindings)) (cddr f))))
		    (binding-free (fold union '() (imap (lambda (f) (lambda-find-free (second f) all-bindings new-bindings (first f)))
							(second f)))))
	       (union (difference body-free new-bindings) (difference binding-free new-bindings)))))
	  (($case $loop)
	   (let* ((new-bindings (to-proper (second f)))
		  (all-bindings (append new-bindings bindings))
		  (body-free (fold union '() (imap (lambda (f) (find-free f all-bindings)) (cddr f)))))
	     (difference body-free new-bindings)))
	  ((named-lambda) (error "Should not happen, lambdas only in letrec"))
	  (else (fold union '()  (imap (lambda (f) (find-free f bindings)) f))))))
  (map (lambda (f) (find-free f '())) sexp)
  sexp)

;; Replace all calls to known lambdas with (label-call label ...)

;; Also calculates any escaping procedures, which is the inverse of
;; well-known procedures.
(define escapes-table '())
(define (update-direct-calls sexp)
  (define (update f bindings)
    (if (atom? f)
	(begin
	  (when (memq f bindings)
	    (when (not (memq f escapes-table))
	      (set! escapes-table (cons f escapes-table))))
	  f)
	(case (car f)
	  ((quote) f)
	  ((letrec)
	   (let* ((new-bindings (map car (second f)))
		  (all-bindings (append new-bindings bindings)))
	     `(letrec ,(map (lambda (f) `(,(car f) ,(update (cdr f) all-bindings))) (second f))
		,@(map (lambda (f) (update f all-bindings)) (cddr f)))))
	  (else
	   (if (memq (car f) bindings)
	       `($label-call ,(car f) ,@(imap (lambda (f) (update f bindings)) (cdr f)))
	       (imap (lambda (f) (update f bindings)) f))))))
  (imap (lambda (f) (update f '())) sexp))

;; Split letrec to letrec groups based on scc tarjan algorithm.
(define (scletrec sexp)
  (define (update f)
    (if (atom? f)
	f
	(case (car f)
	  ((quote) f)
	  ((letrec)
	   (let* ((bindings (map car (second f)))
		  (new-bindings (map (lambda (f) `(,(car f) ,@(update (second f)))) (second f)))
		  (new-body (imap update (cddr f)))
		  (tarjan (tarjan-scc (filter (lambda (x) (memq (car x) bindings)) scc-table))))
	     (let loop ((sccp tarjan) (body new-body))
	       (if (null? sccp)
		   (car body)
		   (loop (cdr sccp) `((letrec ,(map (lambda (f) (assq f new-bindings)) (car sccp)) ,@body)))))))
	  (else (imap update f)))))
  (imap update sexp))

;; Group all well known procedures with a single not-well-known
(define (scletrec2 sexp)
  (define (update f)
    (if (atom? f)
	f
	(case (car f)
	  ((quote) f)
	  ((letrec)
	   (let* ((bindings (map car (second f)))
		  (new-bindings (map (lambda (f) `(,(car f) ,(update (second f)))) (second f)))
		  (new-body (imap update (cddr f)))
		  (well-known (filter (lambda (b) (not (memq b escapes-table))) bindings))
		  (not-well-known (difference bindings well-known)))
	     (define (binding-set s)
	       (filter (lambda (b) (if (memq (car b) s) b #f)) new-bindings))
	     ;;(dformat "well known: ~a not: ~a\n" well-known not-well-known)
	     (if (null? not-well-known)
		 `($scletrec (,new-bindings) ,@new-body)
		 `($scletrec (,(append (binding-set (list (car not-well-known)))
				       (binding-set well-known))
			      ,@(map binding-set (map list (cdr not-well-known)))) ,@new-body))))
	  (else (imap update f)))))
  ;; (for-each (lambda (f)
  ;; 	      (dformat "free in ~a: ~s\n " (car f) (cdr f))) free-table)
  (imap update sexp))

;; Calculate final free: We need to add additional free variables if
;; one of its dependant letrec vars needs a non-constant closure.
;; Proced outermost to innermost doing the determination.
(define final-free-table '())
(define (final-free sexp)
  (define (update f)
    (if (atom? f)
	f
	(case (car f)
	  ((quote) f)
	  (($scletrec)
	   (let ((again #f))
	     (define (analyze-group1 g)
	       (define (try-reduce f)
		 ;;(dformat "try treduce f ~a final-free-table ~a ~a\n" f final-free-table (assq f final-free-table))
		 (if (and (assq f final-free-table)
			  (not (memq f escapes-table))
			  (= 0 (length (cdr (assq f final-free-table)))))
		     #f
		     f))
	       (let* ((free (fold union '() (map (lambda (f) (cdr (assq (car f) free-table))) g)))
		      (reduced-free (filter-map try-reduce free)))
		 ;;(dformat "Analyze group ~a\n" (map car g))
		 (for-each (lambda (f) (set! final-free-table (cons (cons (car f) reduced-free) final-free-table))) g)))
	     (define (analyze-group2 g)
	       (define (add-if-needs-closure link g)
		 (define free (cdr (assq link final-free-table)))
		 ;;(dformat "add if needs closure: link ~a free ~a\n" link free)
		 (when (not (null? free))
		   (for-each (lambda (f)
			       (let* ((cur-free (assq f final-free-table))
				     (needs-update (not (memq link (cdr cur-free)))))
				(when needs-update
				  (set-cdr! cur-free (union (list link) (cdr cur-free)))
				  (set! again #t)
				  )))
			     g)))
	       (define (add-links f g)
		 (define links (cdr (assq f scc-table)))
		 ;;(dformat "Adding links for ~a:~a\n" f links)
		 (for-each (lambda (link) (add-if-needs-closure link g)) (difference links g)))
	       (for-each (lambda (f) (add-links (car f) (map car g))) g))
	     (define (descend g)
	       (map (lambda (f) (update (second f))) g))
	     (for-each analyze-group1 (second f))
	     (let loop ()
	       (set! again #f)
	       (for-each analyze-group2 (second f))
	       (when again (loop)))
	     (for-each descend (second f))
	     (for-each update (cddr f))))
	  (else (imap update f)))))
  (imap update sexp)
  ;;(for-each (lambda (f) (dformat "free in ~a:~a\n" (car f) (cdr f))) final-free-table)
  sexp)

;; Final free vars are decided.  Decide on closure representation, and
;; update the code.
(define (closure-conversion-scc sexp)
  (define (update f replace)
    ;;(dformat "update ~a\n" f)
    (if (atom? f)
	(let ((repl (assq f replace)))
	  (if repl (cdr repl) f))
	(case (car f)
	  (($label-call)
	   `($label-call ,(second f) ,(cdr (assq (second f) replace)) ,@(map (lambda (f) (update f replace)) (cddr f))))
	  ((quote) f)
	  (($scletrec)
	   (let ()
	     (define (is-group-well-known g)
	       (define names (map car g))
	       (fold (lambda (a b) (and a b)) #t
		     (map (lambda (name) (not (memq name escapes-table))) names)))
	     (define (get-free-cnt g)
	       (define representative (caar g))
	       (length (cdr (assq representative final-free-table))))
	     (let* ((group-well-known (map is-group-well-known (second f)))
		    (groups (second f))
		    (free-cnt (map get-free-cnt (second f)))
		    (closures (map (lambda (wk free) (if (and wk (= free 0)) #f
							   (compiler-gensym 'closure)))
				   group-well-known free-cnt))
		    (clo-bind (apply append (map (lambda (g clo) (map (lambda (f) (cons (car f) clo)) g))
						 (second f) closures))))
	       (define (update-group g clo)
		 (let* ((representative (caar g))
		       (free (cdr (assq (caar g) final-free-table)))
		       (free-bind (map (lambda (f n) (cons f `($closure-get ,clo ,n))) free (iota (length free))))
		       ;; Clo-bind must be done for all groups
		       (new-replace (append free-bind clo-bind replace))
		       ;;(foo (dformat "update grou ~a bindings: ~a\n" (map car g) free-bind))
		       )
		   (define (update-lambda f)
		     (define lam (second f))
		     (if clo
			 `(,(car f) (named-lambda ,(second lam) ,(cons clo (third lam)) ,@(imap (lambda (f) (update f new-replace)) (cdddr lam))))
			 `(,(car f) (named-lambda ,(second lam) ,(third lam) ,@(imap (lambda (f) (update f new-replace)) (cdddr lam))))))
		   (map update-lambda g)))
	       (define (generate-closure g clo)
		 (let* ((free (cdr (assq (caar g) final-free-table)))
		       (all-names (apply append (map (lambda (g) (map car g)) (second f))))
		       ;; Map function pointers to closures
		       (free-replaced (map (lambda (f)
						    (define r (assq f replace))
						    (if r
							(cdr r)
							f)) free)))
		   ;;(dformat "Gen closure \n")
		   ;; The unknown binding that needs a pointer is always first.
		   `(,clo (,(if (= (length free-replaced) 0) '$const-closure '$closure)
			   ($label ,(caar g))
			   ,@(map (lambda (f) (if (memq f all-names) #f f)) free-replaced)))))
	       (define (generate-closure-set g clo)
		 (define (find-closure f)
		   (let loop ((groups groups) (closures closures))
		     (let loop2 ((lams (map car groups)))
		       (if (null? lams)
			   (loop (cdr groups) (cdr closures))
			   (if (eq? f (caar lams))
			       (car closures)
			       (loop2 (cdr lams)))))))
		 (let* ((free (cdr (assq (caar g) final-free-table)))
			(all-names (apply append (map (lambda (g) (map car g)) (second f))))
			(set-names (map car g))
			(other-names (difference all-names set-names)))
		   (if clo
		       (map (lambda (f n) (if (memq f other-names)
					      `($closure-set ,clo ,(find-closure f) ,n)
					      #f))
			    free (iota (length free)))
		       '())))
	       (define (id a) a)
	       (define body-clo-bind (apply append (map (lambda (g clo) (map (lambda (f) (cons (car f) clo)) g)) (second f) closures)))
	       ;;(dformat "Well known groups:~a ~a ~a ~a\n" (second f) group-well-known free-cnt closures)
	       ;; The function labels
	       ;; TODO $labels
	       `($labels ,(apply append (map update-group (second f) closures))
			 ;; The closures
		  (let ,(filter-map (lambda (f) (if (car f) f #f)) (map generate-closure (second f) closures))
		    ;; Any letrec groups that need closure-set!
		    (begin
		      ,@(filter-map id (apply append (map generate-closure-set (second f) closures)))
		      ;; The body
		      ,@(imap (lambda (f) (update f (append body-clo-bind replace))) (cddr f))))))))
	  (else (imap (lambda (f) (update f replace)) f)))))
  (imap (lambda (f) (update f '())) sexp))

(define (case-insensitive s)
  (if (pair? s)
      (imap case-insensitive s)
      (if (symbol? s)
	  (string->symbol (list->string (map char-downcase (string->list (symbol->string s)))))
	  s)))

;; Alexpander currently doesn't fully alpha-rename.
(define (alpha-rename f)
  (define (rename f bindings)
    (if (atom? f)
	(if (and (symbol? f) (assoc f bindings))
	    (cdr (assoc f bindings))
	    f)
	(case (car f)
	  ;; Being careful about rest arguments...
	  ((lambda) (let* ((params (second f))
			   (newbind (imap compiler-gensym params))
			   (newenv (append (map cons (to-proper params) (to-proper newbind)) bindings)))
		      `(lambda ,newbind
			 ,@(map (lambda (f) (rename f newenv)) (cddr f)))))
	  ((letrec) (let* ((params (map car (second f)))
			   (newbind (imap compiler-gensym params))
			   (newenv (append (map cons (to-proper params) (to-proper newbind)) bindings)))
		      `(letrec ,(map (lambda (param f) `(,param ,(rename (second f) newenv))) newbind (second f))
			 ,@(map (lambda (f) (rename f newenv)) (cddr f)))))
	  ((quote) f)
	  (else (imap (lambda (f) (rename f bindings)) f)))))
  (imap (lambda (f) (rename f '())) f))
;; TODO all of these need error/arg cnt checking.
(define (integrate-r5rs f)
  (define (integrate f)
    (if (atom? f) f
	(case (car f)
	  ;; TODO cleanup.  lol.
	  ((+ - * /) (if (= 3 (length f))
			       (cons (string->symbol (string-append "$" (symbol->string (car f)))) (imap integrate (cdr f)))
			       (let* ((sym (string->symbol (string-append "$" (symbol->string (car f))))))
				      (if (> (length f) 3)
					  `(,sym (,sym
						  ,(integrate (second f))
						  ,(integrate (third f)))
						 ,(if (> (length (cdddr f)) 1)
						      (integrate (cons (car f) (cdddr f)))
						      (integrate (cadddr f))))
					  (imap integrate f)))))
	  ;; TODO could make this n-ary
	  ((< = > <= >=) (if (= 3 (length f))
			     (cons (string->symbol (string-append "$" (symbol->string (car f)))) (imap integrate (cdr f)))
			     (imap integrate f)))
	  ((car cdr set-car! set-cdr! cons vector-ref vector-length string-length string-ref string-set! vector-set! 
		char->integer integer->char symbol->string string->symbol round vector eqv?
		)
	   (cons (string->symbol (string-append "$" (symbol->string (car f)))) (imap integrate (cdr f))))
	  ;; TODO these need a JISEQ?
	  ((quotient) `($exact ($/ ,@(imap integrate (cdr f)))))
	  ((remainder) `($% ,@(imap integrate (cdr f))))
	  ((zero?) `($= ,@(imap integrate (cdr f)) 0))
	  ((eq? char=?) (cons '$eq (imap integrate (cdr f))))
	  ((quote) f)
	  ((if) (if (and (pair? (second f))
			 (eq? (first (second f)) 'not))
		    `(if ,(integrate (second (second f)))
			 ,(if (= 4 (length f)) (integrate (fourth f)) #f)
			 ,(integrate (third f)))
		    (imap integrate f)))
	  ((not) `(if ,(integrate (second f)) #f #t))
	  ((read-char) (if (= 2 (length f))
			   `($read ,(integrate (second f)))
			   `($read current-input-port-internal)))
	  ((write-char) (if (= 3 (length f))
			   `($write ,(integrate (second f)) ,(integrate (third f)))
			   `($write ,(integrate (second f)) current-output-port-internal)))
	  ((pair?) `($guard ,(integrate (second f)) ,cons-tag))
	  ((boolean?) `($guard ,(integrate (second f)) ,literal-tag))
	  ((procedure?) `($guard ,(integrate (second f)) ,closure-tag))
	  ((vector?) `($guard ,(integrate (second f)) ,vector-tag))
	  ((string?) `($guard ,(integrate (second f)) ,string-tag))
	  ((port?) `($guard ,(integrate (second f)) ,port-tag))
	  ((char?) `($guard ,(integrate (second f)) ,char-tag))
	  ((symbol?) `($guard ,(integrate (second f)) ,symbol-tag))
	  ((eof-object?) `($guard ,(integrate (second f)) ,eof-tag))
	  ((flonum? inexact?) `($guard ,(integrate (second f)) ,flonum-tag))
	  ((fixnum? exact? exact-integer?) `($guard ,(integrate (second f)) ,fixnum-tag)) 
	  ((null?) `($guard ,(integrate (second f)) ,nil-tag))
	  ;; TODO add the rest of c*r
	  ((caar) `($car ($car ,(integrate (second f)))))
	  ((cddr) `($cdr ($cdr ,(integrate (second f)))))
	  ((cadr) `($car ($cdr ,(integrate (second f)))))
	  ;((eqv?) `($eq ,(integrate (second f)) ,(integrate (third f)))) ;; TODO flonums
	  (else (imap integrate f)))))
  (imap integrate f))

;; Must run after alpha-conversion
;; Lower individual cases inline.  The code generator will emit CLFUNC/CLFUNCV instead of FUNC/FUNCV for each case,
;; followed by a jump t
(define (lower-case-lambda f)
  (define (test-cases cases)
    (if (pair? cases)
	`($case ,(second (car cases)) (begin ,@(cddr (car cases))) ,(test-cases (cdr cases)))
	`(error "Can't find case for case-lambda")))
  (define (lower-cl f)
    (if (atom? f)
	f
	(if (eq? '$case-lambda (car f))
	    (let* ((lambdas (map lower-cl (cdr f))))
	      `(lambda () ,(test-cases lambdas)))
	    (imap lower-cl f))))
  (imap lower-cl f))

;; Optional loop-detection pass.
(define (lower-loops f)
  (define (no-refs? var f)
    ;;(dformat "no refs ~a ~a\n" var f)
    (if (atom? f)
	(not (eq? f var))
	(fold (lambda (a b) (and (no-refs? var a) b)) #t f)))
  (define (only-tailcalls? var f)
    ;;(dformat "only tailcalls ~a ~a\n" var f)
    (if (atom? f)
	(not (eq? f var))
	(case (car f)
	  ((if) (and (no-refs? var (second f)) (only-tailcalls? var (third f))
		     (or (= 3 (length f)) (only-tailcalls? var (fourth f)))))
	  ((let) (and (no-refs? var (second f)) (only-tailcalls? var (third f))))
	  ((begin) (case (length f)
		     ((1) #t)
		     ((2) (only-tailcalls? var (second f)))
		     (else (and (no-refs? var (second f)) (only-tailcalls? var `(begin ,@(cddr f)))))))
	  ((lambda) (no-refs? var f))
	  (else (if (atom? (car f))
		    (no-refs? var (cdr f))
		    (no-refs? var f))))))
  (define (lower f)
    (if (atom? f)
	f
	(if (and (pair? (first f))
		 (eq? 'letrec (caar f))
		 (= 1 (length (second (car f))))
		 (eq? (caar (second (car f))) (third (car f)))
		 (only-tailcalls? (caar (second (car f))) (third (second (car (second (car f)))))))
	    (begin
	      ;;(dformat "Loopify: ~a\n" f)
	      `($loop ,(second (second (car (second (car f)))))
		      ,(cdr f)
		      ,(caar (second (car f)))
		      ,(lower (third (second (car (second (car f))))))))
	    (if (eq? 'quote (car f)) f
		(imap lower f)))))
  (imap lower f))

(define (name-lambdas f)
  (define (name f cur)
    (if (pair? f)
	(case (car f)
	  ((define)
	   (if (> (length f) 2)
	       (list 'define (second f) (name (third f) (symbol->string (second f))))
	       (imap (lambda (f) (name f cur)) f)))
	  ((lambda) `(named-lambda ,cur ,@(imap (lambda (f) (name f (string-append cur "-lambda"))) (cdr f))))
	  ((quote) f)
	  ;; Letrecs are already fixed and contain only lambdas.
	  ((letrec)
	   (let* ((vars (second f))
		  (named (map (lambda (f) (list (first f) (name (second f) (symbol->string (first f))))) (second f))))
	     `(letrec ,named ,@(imap (lambda (f) (name f cur)) (cddr f)))))
	  (else (imap (lambda (f) (name f cur)) f)))
	f))
  (imap (lambda (f) (name f "repl")) f))
